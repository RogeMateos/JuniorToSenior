<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lambda Cold Start | Ciclo de Software</title>
    <link rel="stylesheet" href="../../assets/css/styles.css">
</head>
<body>
    <div class="container">
        <main class="main-content">
            <section id="section-lambda-cold-start">
                <h1>‚ùÑÔ∏è 3.1 Lambda Cold Start</h1>
                <p><strong>Arquitectura Serverless con AWS Lambda: Ventajas, Cold Starts y Decisiones Reales</strong></p>

                <h2>1Ô∏è‚É£ Arquitectura m√≠nima serverless</h2>

                <p>Arquitectura t√≠pica:</p>

                <pre><code>Cliente ‚Üí API Gateway ‚Üí Lambda ‚Üí Base de datos</code></pre>

                <h3>üîπ Componentes</h3>

                <p><strong>üõ° API Gateway</strong></p>

                <ul>
                    <li>Expone endpoint p√∫blico</li>
                    <li>Throttling (protecci√≥n contra abuso)</li>
                    <li>Autenticaci√≥n (JWT, Cognito, etc.)</li>
                    <li>Rate limiting</li>
                    <li>Validaci√≥n de requests</li>
                </ul>

                <p><strong>‚öô Lambda</strong></p>

                <ul>
                    <li>Ejecuta tu c√≥digo (Node.js, Python, etc.)</li>
                    <li>Escala autom√°ticamente</li>
                    <li>Pagas por ejecuci√≥n (no servidor fijo)</li>
                </ul>

                <p><strong>üóÑ Base de datos</strong></p>

                <p>Puede ser:</p>

                <ul>
                    <li>DynamoDB (serverless)</li>
                    <li>RDS (relacional)</li>
                    <li>Redis</li>
                    <li>Otro servicio gestionado</li>
                </ul>

                <h2>2Ô∏è‚É£ ¬øQu√© es un Cold Start?</h2>

                <p>Un cold start ocurre cuando:</p>

                <ul>
                    <li>Tu Lambda no ha recibido tr√°fico durante un tiempo</li>
                    <li>AWS ha apagado el entorno de ejecuci√≥n</li>
                    <li>Llega una nueva petici√≥n</li>
                </ul>

                <p>AWS debe:</p>

                <ul>
                    <li>Crear entorno</li>
                    <li>Cargar runtime</li>
                    <li>Descargar tu c√≥digo</li>
                    <li>Ejecutar c√≥digo de inicializaci√≥n</li>
                </ul>

                <p>üëâ <strong>Ese proceso a√±ade latencia extra (500ms ‚Äì 2s o m√°s).</strong></p>

                <h2>3Ô∏è‚É£ Qu√© compone realmente un Cold Start</h2>

                <p>Error com√∫n: pensar que es solo "descargar c√≥digo". No.</p>

                <p>Un cold start incluye:</p>

                <ul>
                    <li>üèó Provisionar el entorno</li>
                    <li>üß© Cargar runtime (Node, Python‚Ä¶)</li>
                    <li>üì¶ Cargar dependencias</li>
                    <li>üöÄ Ejecutar c√≥digo fuera del handler</li>
                    <li>üåê Conectar VPC (si aplica)</li>
                </ul>

                <p>Como senior debes entender:</p>

                <ul>
                    <li>Algunas cosas dependen de AWS</li>
                    <li>Otras dependen completamente de ti</li>
                </ul>

                <h2>4Ô∏è‚É£ ¬øPor qu√© el Cold Start es un problema real?</h2>

                <p>No afecta tanto al promedio.</p>

                <p>Afecta a:</p>

                <ul>
                    <li>p95</li>
                    <li>p99</li>
                    <li>Experiencia del usuario</li>
                    <li>Timeouts</li>
                    <li>Retries innecesarios</li>
                </ul>

                <p><strong>Ejemplo pr√°ctico:</strong></p>

                <p>Usuario entra tras 10 minutos sin tr√°fico<br>
                Primera request tarda 1.8s<br>
                Usuario percibe lentitud<br>
                M√©trica global parece buena, pero UX mala</p>

                <p>Esto es ingenier√≠a real, no marketing.</p>

                <h2>5Ô∏è‚É£ Qu√© empeora el Cold Start</h2>

                <p>Errores comunes de junior:</p>

                <ul>
                    <li>üì¶ Bundle enorme (5‚Äì10MB)</li>
                    <li>üîÅ Mucho c√≥digo ejecut√°ndose fuera del handler</li>
                    <li>üóÑ Conexi√≥n a base de datos mal gestionada</li>
                    <li>üåê Lambda dentro de VPC sin necesidad</li>
                    <li>üß± Librer√≠as pesadas innecesarias</li>
                    <li>üîê Validaciones JWT mal implementadas</li>
                </ul>

                <h2>6Ô∏è‚É£ C√≥mo Mitigar el Cold Start</h2>

                <h3>‚úÖ 1. Hacer la funci√≥n ligera</h3>

                <p>Buenas pr√°cticas:</p>

                <ul>
                    <li>Usar esbuild / bundling optimizado</li>
                    <li>Eliminar dependencias innecesarias</li>
                    <li>Lazy loading</li>
                    <li>Minimizar c√≥digo global</li>
                </ul>

                <p><strong>Mentalidad senior:</strong></p>

                <p>El cold start debe hacer lo m√≠nimo indispensable.</p>

                <h3>‚ö† 2. Warmup con EventBridge (cron)</h3>

                <p>Se programa un evento cada minuto que llama la Lambda.</p>

                <p><strong>Pros:</strong></p>

                <ul>
                    <li>Reduce probabilidad de enfriamiento</li>
                </ul>

                <p><strong>Cons:</strong></p>

                <ul>
                    <li>No garantiza nada</li>
                    <li>M√°s complejidad</li>
                    <li>M√°s coste</li>
                    <li>M√°s moving pieces</li>
                    <li>Mala soluci√≥n si tienes muchas Lambdas</li>
                </ul>

                <p><strong>Como senior:</strong></p>

                <p>Es un hack, no una soluci√≥n arquitect√≥nica limpia.</p>

                <h3>üí∞ 3. Provisioned Concurrency (soluci√≥n oficial)</h3>

                <p>Mantiene instancias pre-calentadas.</p>

                <p><strong>Ventajas:</strong></p>

                <ul>
                    <li>Reduce cold start significativamente</li>
                    <li>Ideal para endpoints cr√≠ticos</li>
                </ul>

                <p><strong>Desventaja importante:</strong></p>

                <ul>
                    <li>Pagas continuamente</li>
                    <li>Ya no es "casi gratis sin tr√°fico"</li>
                </ul>

                <p>Aqu√≠ es donde muchos proyectos dejan de ser realmente "serverless barato".</p>

                <h2>7Ô∏è‚É£ Coste Real vs Marketing</h2>

                <p>Lambda es genial cuando:</p>

                <ul>
                    <li>Hay tr√°fico irregular</li>
                    <li>Eventos as√≠ncronos</li>
                    <li>Procesamiento puntual</li>
                    <li>Integraciones con otros servicios AWS</li>
                </ul>

                <p>Lambda puede no ser ideal cuando:</p>

                <ul>
                    <li>Tr√°fico constante alto</li>
                    <li>API ultra sensible a latencia</li>
                    <li>Mucha conexi√≥n a RDS tradicional</li>
                    <li>Necesitas control fino del runtime</li>
                </ul>

                <p>A veces:</p>

                <ul>
                    <li>ECS/Fargate</li>
                    <li>EC2</li>
                    <li>Contenedores</li>
                </ul>

                <p>pueden ser m√°s simples y m√°s baratos a largo plazo.</p>

                <h2>8Ô∏è‚É£ Ejemplo mental: anti-patr√≥n vs patr√≥n correcto</h2>

                <h3>‚ùå Anti-patr√≥n</h3>

                <pre><code>Importas 15 librer√≠as pesadas
Inicializas cliente DB en cada request
Cargas secrets din√°micamente siempre
Bundle gigante

Resultado:
Cold start lento + rendimiento pobre</code></pre>

                <h3>‚úÖ Patr√≥n correcto</h3>

                <pre><code>Bundle peque√±o
Cliente DB inicializado una vez (reutilizable)
Trabajo m√≠nimo en init
M√©tricas configuradas

Resultado:
Cold start reducido + rendimiento estable</code></pre>

                <h2>9Ô∏è‚É£ Observabilidad (clave que muchos olvidan)</h2>

                <p>Debes medir:</p>

                <ul>
                    <li>Init Duration</li>
                    <li>Duration</li>
                    <li>Throttles</li>
                    <li>Concurrent Executions</li>
                    <li>p95 / p99</li>
                </ul>

                <p>Herramientas:</p>

                <ul>
                    <li>CloudWatch Logs</li>
                    <li>X-Ray</li>
                    <li>M√©tricas personalizadas</li>
                </ul>

                <p><strong>Como senior:</strong></p>

                <p>Nunca optimizas lo que no mides.</p>

                <h2>üîü Checklist Final de Ingenier√≠a</h2>

                <p>Antes de lanzar a producci√≥n:</p>

                <ul>
                    <li>‚òë Bundle optimizado</li>
                    <li>‚òë C√≥digo fuera del handler m√≠nimo</li>
                    <li>‚òë Lambda en VPC solo si necesario</li>
                    <li>‚òë Conexi√≥n DB bien gestionada</li>
                    <li>‚òë M√©tricas activas</li>
                    <li>‚òë p95 medido</li>
                    <li>‚òë Provisioned concurrency solo si justificado</li>
                    <li>‚òë Coste estimado con tr√°fico realista</li>
                </ul>

                <h2>1Ô∏è‚É£1Ô∏è‚É£ Decisiones Clave como Ingeniero Senior</h2>

                <table class="cheat-sheet-table">
                    <tr>
                        <th>Decisi√≥n</th>
                        <th>Enfoque Junior</th>
                        <th>Enfoque Senior</th>
                    </tr>
                    <tr>
                        <td>¬øUsar Lambda?</td>
                        <td>"Es cool y nuevo"</td>
                        <td>Basado en caracter√≠sticas de carga</td>
                    </tr>
                    <tr>
                        <td>Cold start</td>
                        <td>"AWS lo maneja"</td>
                        <td>Medir, optimizar, mitigar si es necesario</td>
                    </tr>
                    <tr>
                        <td>Coste</td>
                        <td>"Es por uso"</td>
                        <td>Comparar vs alternativas, calcular coste real</td>
                    </tr>
                    <tr>
                        <td>Observabilidad</td>
                        <td>"Logs son suficientes"</td>
                        <td>Logs estructurados, m√©tricas, tracing, alertas</td>
                    </tr>
                </table>

                <h2>1Ô∏è‚É£2Ô∏è‚É£ La Verdad Sobre Serverless</h2>

                <p>Lambda no es magia.<br>
                Lambda no es siempre m√°s barato.<br>
                Lambda no es siempre mejor.</p>

                <p>Lambda es excelente para:</p>

                <ul>
                    <li>Arquitecturas event-driven</li>
                    <li>Tr√°fico irregular</li>
                    <li>Equipos peque√±os que quieren menos operaci√≥n</li>
                </ul>

                <p>Pero como ingeniero senior piensa en:</p>

                <ul>
                    <li>Latencia real</li>
                    <li>Coste real</li>
                    <li>Complejidad real</li>
                    <li>Escalabilidad real</li>
                    <li>Experiencia del usuario</li>
                </ul>

                <h2>1Ô∏è‚É£3Ô∏è‚É£ Cu√°ndo Elegir Qu√©</h2>

                <table class="cheat-sheet-table">
                    <tr>
                        <th>Escenario</th>
                        <th>Mejor Opci√≥n</th>
                        <th>Por Qu√©</th>
                    </tr>
                    <tr>
                        <td>API con tr√°fico irregular</td>
                        <td>Lambda + API Gateway</td>
                        <td>Escala bajo demanda, paga por uso</td>
                    </tr>
                    <tr>
                        <td>Tr√°fico constante alto</td>
                        <td>ECS/Fargate o EC2</td>
                        <td>Coste fijo, mejor para carga base</td>
                    </tr>
                    <tr>
                        <td>Procesamiento de eventos</td>
                        <td>Lambda + SQS/SNS</td>
                        <td>Modelo async natural</td>
                    </tr>
                    <tr>
                        <td>API cr√≠tica con baja latencia</td>
                        <td>ECS/Fargate o EC2</td>
                        <td>Evita riesgo de cold start</td>
                    </tr>
                </table>

                <h2>üéØ Conclusi√≥n</h2>

                <p>Los cold starts son reales, pero gestionables.</p>

                <p>La clave es:</p>

                <ul>
                    <li>‚úî Entender qu√© los causa</li>
                    <li>‚úî Medirlos</li>
                    <li>‚úî Optimizar cuando sea necesario</li>
                    <li>‚úî Tomar decisiones conscientes de trade-offs</li>
                    <li>‚úî Nunca elegir arquitectura por hype</li>
                </ul>

                <p><strong>Esto es ingenier√≠a senior.</strong></p>

                <h2>üìö Recursos</h2>

                <ul>
                    <li><a href="https://chatgpt.com/g/g-p-69925f6597e88191b8bcb93447c5bb78-dragos/c/6998648f-2cdc-8387-b119-c6245393bab6" target="_blank">Arquitectura Serverless con AWS Lambda: Cold Starts - Dragos</a></li>
                </ul>

                <div class="navigation-buttons">
                    <button class="btn btn-secondary" onclick="window.location.href='../index.html'">‚Üê Volver Atr√°s</button>
                    <button class="btn btn-primary" onclick="window.location.href='../../index.html'">Volver al Inicio ‚Üí</button>
                </div>
            </section>
        </main>
    </div>

    <script src="../../assets/js/app.js"></script>
</body>
</html>
