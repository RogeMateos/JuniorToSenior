<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>El Blueprint Universal para CI/CD | Ciclo de Software</title>
    <link rel="stylesheet" href="../../assets/css/styles.css">
</head>
<body>
    <div class="container">
        <main class="main-content">
            <section id="section-universal-blueprint">
                <h1>ğŸ“ El Blueprint Universal para CI/CD</h1>
                <p><strong>Un modelo mental que puedes aplicar en cualquier lugar</strong></p>

                <h2>ğŸ¯ Objetivo de esta lecciÃ³n</h2>

                <p>Entender cÃ³mo pasar de:</p>

                <p><strong>"Tengo cÃ³digo en mi mÃ¡quina"</strong></p>

                <p>a</p>

                <p><strong>"Tengo software estable funcionando en producciÃ³n, con despliegues seguros y automatizados"</strong></p>

                <p>Y lo mÃ¡s importante:</p>

                <p>ğŸ‘‰ <strong>Desarrollar el modelo mental universal que puedes aplicar en:</strong></p>

                <ul>
                    <li>una startup con Vercel</li>
                    <li>un backend en Node</li>
                    <li>una SPA en React</li>
                    <li>un microservicio en Docker</li>
                    <li>un cluster en Kubernetes</li>
                    <li>o un entorno serverless</li>
                </ul>

                <p><strong>Las herramientas cambian.<br>
                El modelo mental NO cambia.</strong></p>

                <h2>ğŸ§  El Modelo Mental Universal</h2>

                <p>Todo sistema moderno se puede dividir en 4 grandes fases:</p>

                <p><strong>Develop â†’ Build â†’ Release â†’ Monitor</strong></p>

                <p>Este es el blueprint que debes tener en la cabeza siempre.</p>

                <h2>1ï¸âƒ£ DEVELOP â€“ Desarrollo y Control de Versiones</h2>

                <h3>Â¿QuÃ© ocurre aquÃ­?</h3>

                <ul>
                    <li>Trabajas en ramas (feature/*)</li>
                    <li>Haces commits pequeÃ±os</li>
                    <li>Abres Pull Requests</li>
                    <li>Recibes revisiÃ³n de cÃ³digo</li>
                    <li>Se integra al branch principal (main)</li>
                </ul>

                <h3>ğŸ§  Mentalidad Senior</h3>

                <p><strong>El branch main debe estar SIEMPRE desplegable.</strong></p>

                <p>Eso significa:</p>

                <ul>
                    <li>Nada se mergea si rompe tests</li>
                    <li>Nada se mergea sin revisiÃ³n</li>
                    <li>Nada se mergea sin pasar el pipeline</li>
                </ul>

                <h3>ğŸ“Œ Conceptos clave</h3>

                <p><strong>Branching strategy (Git Flow simplificado)</strong></p>

                <p><strong>Ejemplo tÃ­pico:</strong></p>

                <pre><code>main
 â”œâ”€â”€ feature/login
 â”œâ”€â”€ feature/payment
 â””â”€â”€ hotfix/bug-123</code></pre>

                <p><strong>Flujo comÃºn:</strong></p>

                <ul>
                    <li>Creas feature/*</li>
                    <li>Abres PR</li>
                    <li>Pipeline corre automÃ¡ticamente</li>
                    <li>Si pasa â†’ merge</li>
                    <li>Se dispara CI oficial</li>
                </ul>

                <h2>2ï¸âƒ£ BUILD â€“ Convertir CÃ³digo en Artefacto</h2>

                <h3>ğŸ¯ Objetivo</h3>

                <p>Transformar el cÃ³digo en algo ejecutable y reproducible.</p>

                <p>Ese resultado se llama:</p>

                <p>ğŸ“¦ <strong>Artefacto</strong></p>

                <h3>ğŸ” Â¿QuÃ© es un artefacto?</h3>

                <p>Depende del tipo de aplicaciÃ³n:</p>

                <table class="cheat-sheet-table">
                    <tr>
                        <th>Tipo de app</th>
                        <th>Artefacto</th>
                    </tr>
                    <tr>
                        <td>React SPA</td>
                        <td>carpeta dist/</td>
                    </tr>
                    <tr>
                        <td>Node API</td>
                        <td>JS compilado</td>
                    </tr>
                    <tr>
                        <td>TypeScript</td>
                        <td>JS transpileado</td>
                    </tr>
                    <tr>
                        <td>Java</td>
                        <td>.jar</td>
                    </tr>
                    <tr>
                        <td>.NET</td>
                        <td>.dll o ejecutable</td>
                    </tr>
                    <tr>
                        <td>Docker</td>
                        <td>Imagen Docker</td>
                    </tr>
                </table>

                <h3>ğŸ” QuÃ© debe ocurrir en el build</h3>

                <p><strong>Orden correcto (feedback rÃ¡pido primero):</strong></p>

                <ul>
                    <li>Lint</li>
                    <li>Type check</li>
                    <li>Unit tests</li>
                    <li>Build</li>
                    <li>Empaquetado del artefacto</li>
                </ul>

                <h3>ğŸ§  Regla de oro senior</h3>

                <p>ğŸ”¥ <strong>Build una vez. Despliega muchas veces.</strong></p>

                <p>Nunca reconstruyas en producciÃ³n.<br>
                El mismo artefacto que probaste en staging debe ir a producciÃ³n.</p>

                <h2>3ï¸âƒ£ RELEASE â€“ Desplegar el Artefacto</h2>

                <p>AquÃ­ es donde muchas empresas fallan.</p>

                <p><strong>Release NO es solo "subir archivos".</strong></p>

                <p>Es:</p>

                <ul>
                    <li>Desplegar artefacto</li>
                    <li>Ejecutar migraciones</li>
                    <li>Configurar variables de entorno</li>
                    <li>Cambiar trÃ¡fico</li>
                    <li>Garantizar disponibilidad</li>
                </ul>

                <h3>ğŸ— Entornos tÃ­picos</h3>

                <p>Local â†’ Dev â†’ Staging â†’ Production</p>

                <p><strong>Staging</strong></p>

                <p>RÃ©plica cercana a producciÃ³n<br>
                AquÃ­ corren integration / e2e tests<br>
                Puede requerir aprobaciÃ³n manual</p>

                <h3>ğŸ“Š Tipos de Deployment</h3>

                <p><strong>1ï¸âƒ£ Recreate</strong></p>

                <p>Apagas servidor viejo â†’ arrancas nuevo<br>
                âŒ Downtime</p>

                <p><strong>2ï¸âƒ£ Rolling Deployment</strong></p>

                <p>Reemplazas instancias progresivamente<br>
                âœ… Sin downtime<br>
                âœ… Muy comÃºn</p>

                <p><strong>3ï¸âƒ£ Blue/Green</strong></p>

                <p>Dos entornos paralelos<br>
                Cambias trÃ¡fico cuando el nuevo estÃ¡ listo<br>
                âœ… Muy seguro<br>
                âš ï¸ MÃ¡s costoso</p>

                <p><strong>4ï¸âƒ£ Canary</strong></p>

                <p>Despliegas a 5% de usuarios primero<br>
                Si todo va bien â†’ 100%<br>
                âœ… Muy profesional<br>
                âœ… Minimiza riesgo</p>

                <h2>4ï¸âƒ£ MONITOR â€“ OperaciÃ³n Continua</h2>

                <p>AquÃ­ termina el cicloâ€¦ y empieza otro.</p>

                <p>Monitorizar significa:</p>

                <ul>
                    <li>Logs centralizados</li>
                    <li>MÃ©tricas (CPU, memoria, latencia)</li>
                    <li>Alertas automÃ¡ticas</li>
                    <li>Dashboards</li>
                </ul>

                <h3>ğŸ”¥ Punto clave senior: Â¿Y si algo falla?</h3>

                <p>Debes tener plan de:</p>

                <p>ğŸ”„ <strong>Rollback</strong></p>

                <p>Volver a versiÃ³n anterior</p>

                <p>o</p>

                <p>ğŸ”§ <strong>Rollforward</strong></p>

                <p>Sacar fix rÃ¡pido y desplegar</p>

                <p><strong>Sin esto, monitor no sirve de nada.</strong></p>

                <h2>âš™ï¸ CI vs CD â€“ Diferencia Real</h2>

                <h3>Continuous Integration (CI)</h3>

                <p>Cada merge:</p>

                <ul>
                    <li>Corre tests</li>
                    <li>Genera artefacto</li>
                    <li>Garantiza que el sistema estÃ¡ integrado</li>
                </ul>

                <h3>Continuous Delivery</h3>

                <p>Despliegue automÃ¡tico a staging<br>
                Requiere aprobaciÃ³n manual para prod</p>

                <h3>Continuous Deployment (CD real)</h3>

                <p>Sin intervenciÃ³n humana<br>
                Si pasa tests â†’ va directo a producciÃ³n</p>

                <p>âš ï¸ Solo viable con:</p>

                <ul>
                    <li>Alta cobertura de tests</li>
                    <li>Observabilidad sÃ³lida</li>
                    <li>Confianza en el pipeline</li>
                </ul>

                <h2>ğŸ“¦ Artifact Repository â€“ La Pieza Clave</h2>

                <p><strong>Ejemplos:</strong></p>

                <ul>
                    <li>Docker Registry</li>
                    <li>GitHub Packages</li>
                    <li>AWS ECR</li>
                    <li>Nexus</li>
                    <li>S3 versionado</li>
                </ul>

                <p>El repo NO es el artefacto.<br>
                El artefacto es el resultado del build.</p>

                <h2>ğŸ” Seguridad BÃ¡sica (Que Siempre Preguntan)</h2>

                <p>Un pipeline profesional incluye:</p>

                <ul>
                    <li>Escaneo de dependencias</li>
                    <li>Secrets fuera del repo</li>
                    <li>Permisos mÃ­nimos en CI</li>
                    <li>AuditorÃ­a de builds</li>
                </ul>

                <p>No necesitas ser DevSecOps,<br>
                pero debes saber que esto existe.</p>

                <h2>ğŸ§ª Ejemplo 1 â€“ SPA React</h2>

                <p><strong>Pipeline tÃ­pico:</strong></p>

                <p><strong>PR:</strong></p>

                <ul>
                    <li>lint</li>
                    <li>typecheck</li>
                    <li>tests</li>
                    <li>build</li>
                </ul>

                <p><strong>Merge a main:</strong></p>

                <ul>
                    <li>build</li>
                    <li>subir dist a S3</li>
                    <li>invalidar CDN</li>
                </ul>

                <p><strong>Deployment:</strong></p>

                <ul>
                    <li>automÃ¡tico</li>
                </ul>

                <h2>ğŸ§ª Ejemplo 2 â€“ API Node con Docker</h2>

                <p><strong>PR:</strong></p>

                <ul>
                    <li>tests</li>
                    <li>build imagen</li>
                </ul>

                <p><strong>Merge:</strong></p>

                <ul>
                    <li>push imagen api:&lt;sha&gt; a registry</li>
                </ul>

                <p><strong>Staging:</strong></p>

                <ul>
                    <li>deploy imagen</li>
                    <li>integration tests</li>
                </ul>

                <p><strong>Prod:</strong></p>

                <ul>
                    <li>promote misma imagen</li>
                    <li>rolling deployment</li>
                </ul>

                <h2>ğŸ§  Action Item Importante</h2>

                <p>Haz este ejercicio:</p>

                <p>En tu empresa actual responde:</p>

                <ul>
                    <li>Â¿CuÃ¡l es el artefacto?</li>
                    <li>Â¿DÃ³nde se guarda?</li>
                    <li>Â¿QuÃ© dispara el build?</li>
                    <li>Â¿QuÃ© dispara el deploy?</li>
                    <li>Â¿Hay aprobaciÃ³n manual?</li>
                    <li>Â¿QuÃ© estrategia de despliegue usan?</li>
                    <li>Â¿CÃ³mo hacen rollback?</li>
                </ul>

                <p><strong>Si no puedes responder estas 7 preguntas,<br>
                no entiendes tu pipeline aÃºn.</strong></p>

                <h2>ğŸ¯ CÃ³mo Responder en una Entrevista</h2>

                <p><strong>Respuesta senior modelo:</strong></p>

                <p>"Trabajamos con PR obligatorias. El merge a main dispara CI que corre lint, tests y build. Generamos una imagen Docker versionada con el commit SHA y la subimos al registry. Desplegamos esa misma imagen a staging, ejecutamos tests de integraciÃ³n y luego promovemos a producciÃ³n con rolling deployment. Monitorizamos logs y mÃ©tricas y podemos hacer rollback inmediato si es necesario."</p>

                <p>Esto demuestra:</p>

                <ul>
                    <li>âœ” Entiendes CI</li>
                    <li>âœ” Entiendes artefactos</li>
                    <li>âœ” Entiendes despliegue</li>
                    <li>âœ” Piensas en producciÃ³n</li>
                </ul>

                <h2>ğŸ ConclusiÃ³n Final</h2>

                <p><strong>CI/CD no es una herramienta.<br>
                No es GitLab.<br>
                No es Jenkins.<br>
                No es GitHub Actions.</strong></p>

                <p><strong>Es un modelo mental de automatizaciÃ³n.</strong></p>

                <p>Desarrollas.<br>
                Construyes.<br>
                Publicas.<br>
                Observas.</p>

                <p>Y repites.</p>

                <h2>ğŸ“š Recursos</h2>

                <ul>
                    <li><a href="https://chatgpt.com/g/g-p-69925f6597e88191b8bcb93447c5bb78-dragos/c/6995fec6-f638-838c-8a7d-b90e1aa6e3ab?tab=chats" target="_blank">CI/CD: El Blueprint Universal para Desplegar Software - Dragos</a></li>
                </ul>

                <div class="navigation-buttons">
                    <button class="btn btn-secondary" onclick="window.location.href='../index.html'">â† Volver AtrÃ¡s</button>
                    <button class="btn btn-primary" onclick="window.location.href='../../index.html'">Volver al Inicio â†’</button>
                </div>
            </section>
        </main>
    </div>

    <script src="../../assets/js/app.js"></script>
</body>
</html>
