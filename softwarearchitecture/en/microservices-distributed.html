<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Microservices & Distributed Systems | Software Architecture</title>
    <link rel="stylesheet" href="../../assets/css/styles.css">
</head>
<body>
    <div class="container">
        <main class="main-content">
            <section id="section-microservices-distributed">
                <h1>üéõÔ∏è 1.3 Microservices & Distributed Systems</h1>
                <p><strong>From Monolith to Distributed Systems (Senior Mindset)</strong></p>

                <h2>1Ô∏è‚É£ The Starting Point: Layered Architecture + SOA</h2>

                <p>When we apply:</p>

                <ul>
                    <li>SOLID</li>
                    <li>Layered Architecture</li>
                    <li>Separation of concerns</li>
                    <li>Service Oriented Architecture</li>
                </ul>

                <p>We end up with something like this:</p>

                <pre><code>Frontend (SPA)
      ‚Üì
Backend Monolith
  - Controllers
  - Services
  - Repositories
  - Shared Database</code></pre>

                <p>This is called:</p>

                <p>üß± <strong>Modular Monolith</strong></p>

                <p>A well-organized monolith.</p>

                <p>And this is important:</p>

                <p><strong>‚ö†Ô∏è Modular Monolith ‚â† Spaghetti Monolith</strong></p>

                <p>A modular monolith is well-structured internally.</p>

                <h2>2Ô∏è‚É£ What is a Modular Monolith</h2>

                <p>A single backend that:</p>

                <ul>
                    <li>Is divided into clear modules (Payments, Users, Orders‚Ä¶)</li>
                    <li>Follows layered architecture</li>
                    <li>Shares one database</li>
                    <li>Deploys as a single unit</li>
                </ul>

                <p><strong>Example:</strong></p>

                <pre><code>/src
  /users
  /payments
  /orders
  /email</code></pre>

                <p>Each module has:</p>

                <ul>
                    <li>Controller</li>
                    <li>Service</li>
                    <li>Repository</li>
                    <li>Domain logic</li>
                </ul>

                <p>All within the same deploy.</p>

                <h2>3Ô∏è‚É£ Why It Works Very Well at the Beginning</h2>

                <p>Because:</p>

                <ul>
                    <li>‚úÖ Simple debugging (everything in one process)</li>
                    <li>‚úÖ Simple transactions</li>
                    <li>‚úÖ INNER JOINs work fine</li>
                    <li>‚úÖ Simple infrastructure</li>
                    <li>‚úÖ Easy CI/CD</li>
                    <li>‚úÖ Easy for small teams</li>
                </ul>

                <p>For a team of 5‚Äì8 people, this is perfect.</p>

                <h2>4Ô∏è‚É£ The Problem Starts When You Scale the Team</h2>

                <p>Imagine now you have:</p>

                <ul>
                    <li>20 backend developers</li>
                    <li>15 frontend developers</li>
                    <li>QA</li>
                    <li>DevOps</li>
                    <li>Product</li>
                </ul>

                <p>Everyone touching the same repository.</p>

                <p>Problems start appearing.</p>

                <h2>5Ô∏è‚É£ Real Problems of Monolith at Scale</h2>

                <h3>üî¥ 1. Single Point of Failure</h3>

                <p>A bug in one module can affect the entire system.</p>

                <p>All or nothing.</p>

                <h3>üî¥ 2. Deploy Bottleneck</h3>

                <p>Every change requires:</p>

                <ul>
                    <li>Full build</li>
                    <li>Full tests</li>
                    <li>Full deploy</li>
                </ul>

                <p>Even if you only changed the Email module.</p>

                <p>The pipeline starts taking 30‚Äì40 minutes.</p>

                <h3>üî¥ 3. Inefficient Scaling</h3>

                <p>If only the Payments endpoint gets high load‚Ä¶</p>

                <p>You must scale the ENTIRE backend.</p>

                <p>That's expensive.</p>

                <h3>üî¥ 4. Database Risk</h3>

                <p>Shared database means:</p>

                <ul>
                    <li>Risky migrations</li>
                    <li>High production risk</li>
                    <li>Teams stepping on each other</li>
                </ul>

                <h3>üî¥ 5. Conway's Law (Very Important)</h3>

                <p>Conway's Law states:</p>

                <p><strong>The software reflects the communication structure of the team.</strong></p>

                <p>And this is brutally true.</p>

                <p>If you have 30 people working on one system:</p>

                <p>The system tends to be complex and full of friction.</p>

                <p>Also, communication scales exponentially:</p>

                <p><strong>Formula for communication lines:</strong></p>

                <pre><code>n(n-1)/2</code></pre>

                <p><strong>Example:</strong></p>

                <ul>
                    <li>3 people ‚Üí 3 lines</li>
                    <li>10 people ‚Üí 45 lines</li>
                    <li>14 people ‚Üí 91 lines</li>
                </ul>

                <p>Communication becomes the bottleneck.</p>

                <h2>6Ô∏è‚É£ Silos Form</h2>

                <p>In large monoliths this happens:</p>

                <ul>
                    <li>Database team</li>
                    <li>Backend team</li>
                    <li>Frontend team</li>
                    <li>Auth team</li>
                </ul>

                <p>And nobody delivers end-to-end features.</p>

                <p>That breaks agility.</p>

                <h2>7Ô∏è‚É£ The Solution Is Born: Microservices</h2>

                <p>The idea is:</p>

                <p>Extract modules from the monolith and turn them into independent services.</p>

                <p><strong>Before:</strong></p>

                <pre><code>Monolith
 - Users
 - Payments
 - Orders
 - Email</code></pre>

                <p><strong>After:</strong></p>

                <pre><code>Frontend
   ‚Üì
Users Service
Payments Service
Orders Service
Email Service</code></pre>

                <p>Each one:</p>

                <ul>
                    <li>Independent deploy</li>
                    <li>Own database</li>
                    <li>Own team</li>
                    <li>Independent scaling</li>
                </ul>

                <h2>8Ô∏è‚É£ What Microservices Really Is</h2>

                <p>Microservices is NOT:</p>

                <p>‚ùå "Many small projects"</p>

                <p>Microservices is:</p>

                <p><strong>Separating business domains into autonomous units that can evolve independently.</strong></p>

                <p><strong>Key:</strong></p>

                <p>Autonomy.</p>

                <h2>9Ô∏è‚É£ Real Advantages of Microservices</h2>

                <h3>üü¢ 1. Autonomous Teams</h3>

                <p>Payments team deploys without blocking Orders team.</p>

                <p>Less coordination = more speed.</p>

                <h3>üü¢ 2. Parallel Deployment</h3>

                <p>You can deploy:</p>

                <ul>
                    <li>Payments v2</li>
                    <li>Email improvements</li>
                    <li>Orders bugfix</li>
                </ul>

                <p>On the same day.</p>

                <h3>üü¢ 3. Selective Scaling</h3>

                <p>You only scale the service that needs more capacity.</p>

                <p>More efficient and cheaper.</p>

                <h3>üü¢ 4. Reduced Blast Radius</h3>

                <p>If Email fails‚Ä¶</p>

                <p>Payments still works.</p>

                <p>The system doesn't fall completely.</p>

                <h2>üîü But‚Ä¶ Microservices Has a Price (The "Microservices Tax")</h2>

                <p>Here comes the senior part.</p>

                <p>Microservices introduces distributed complexity.</p>

                <h3>üî¥ 1. Much Harder Debug</h3>

                <p><strong>Before:</strong></p>

                <ul>
                    <li>Step-through debugging in a single process</li>
                </ul>

                <p><strong>Now:</strong></p>

                <ul>
                    <li>Distributed logs</li>
                    <li>Tracing</li>
                    <li>Latency</li>
                    <li>Timeouts</li>
                    <li>Network failures</li>
                </ul>

                <p>You need:</p>

                <ul>
                    <li>Observability</li>
                    <li>Distributed tracing (Jaeger, Zipkin, etc.)</li>
                    <li>Centralized logging</li>
                </ul>

                <h3>üî¥ 2. No INNER JOINs</h3>

                <p>Each service owns its own database.</p>

                <p>You can't do:</p>

                <pre><code>SELECT * FROM users
JOIN payments</code></pre>

                <p>You must:</p>

                <ul>
                    <li>Make HTTP calls</li>
                    <li>Handle latency</li>
                    <li>Handle failures</li>
                    <li>Handle eventual consistency</li>
                </ul>

                <p>That complicates the mental model.</p>

                <h3>üî¥ 3. Distributed Transactions</h3>

                <p>ACID is easy in monolith.</p>

                <p>In microservices‚Ä¶</p>

                <p>You must use:</p>

                <ul>
                    <li>Saga pattern</li>
                    <li>Event-driven architecture</li>
                    <li>Eventual consistency</li>
                </ul>

                <p>That's advanced level.</p>

                <h3>üî¥ 4. More Complex Infrastructure</h3>

                <p>You need:</p>

                <ul>
                    <li>Service discovery</li>
                    <li>API Gateway</li>
                    <li>Load balancers</li>
                    <li>Circuit breakers</li>
                    <li>Retries</li>
                    <li>Monitoring</li>
                    <li>Versioning</li>
                    <li>Security per service</li>
                </ul>

                <p>It's not trivial.</p>

                <h2>1Ô∏è‚É£1Ô∏è‚É£ Correct Mental Model</h2>

                <p>Think of:</p>

                <p>üèùÔ∏è <strong>Microservices = Islands</strong></p>

                <p>Each island:</p>

                <ul>
                    <li>Lives alone</li>
                    <li>Has its own database</li>
                    <li>Communicates over network</li>
                </ul>

                <p>But the network is a hostile environment.</p>

                <p><strong>The network can fail.</strong></p>

                <p>Always assume it will.</p>

                <h2>1Ô∏è‚É£2Ô∏è‚É£ When NOT to Use Microservices</h2>

                <p>This is very important.</p>

                <p>DO NOT use microservices if:</p>

                <ul>
                    <li>Your team is small (< 10 devs)</li>
                    <li>Your product is not validated</li>
                    <li>You don't have DevOps maturity</li>
                    <li>You don't have observability</li>
                    <li>You don't have distributed systems experience</li>
                </ul>

                <p>In that case:</p>

                <p>üëâ <strong>Modular Monolith is superior.</strong></p>

                <h2>1Ô∏è‚É£3Ô∏è‚É£ Senior Real Strategy</h2>

                <p>The healthy evolution is:</p>

                <ol>
                    <li>Start with modular monolith</li>
                    <li>Design clear domain boundaries (DDD)</li>
                    <li>When the team grows and monolith becomes bottleneck‚Ä¶</li>
                    <li>Gradually extract services</li>
                </ol>

                <p><strong>Don't start with microservices for hype.</strong></p>

                <h2>1Ô∏è‚É£4Ô∏è‚É£ The Big Truth</h2>

                <p><strong>Microservices doesn't scale code.</strong></p>

                <p><strong>Microservices scales teams.</strong></p>

                <p>This is what almost nobody understands at first.</p>

                <h2>1Ô∏è‚É£5Ô∏è‚É£ Executive Summary</h2>

                <table class="cheat-sheet-table">
                    <tr>
                        <th></th>
                        <th>Modular Monolith</th>
                        <th>Microservices</th>
                    </tr>
                    <tr>
                        <td>Complexity</td>
                        <td>Simple</td>
                        <td>Complex</td>
                    </tr>
                    <tr>
                        <td>Debugging</td>
                        <td>Easy</td>
                        <td>Distributed debugging</td>
                    </tr>
                    <tr>
                        <td>Database</td>
                        <td>Single shared</td>
                        <td>DB per service</td>
                    </tr>
                    <tr>
                        <td>Deployment</td>
                        <td>Single deploy</td>
                        <td>Independent deploys</td>
                    </tr>
                    <tr>
                        <td>Scaling</td>
                        <td>All or nothing</td>
                        <td>Selective scaling</td>
                    </tr>
                    <tr>
                        <td>Best for</td>
                        <td>Small teams</td>
                        <td>Large teams</td>
                    </tr>
                </table>

                <h2>1Ô∏è‚É£6Ô∏è‚É£ The Cost of Each Approach</h2>

                <table class="cheat-sheet-table">
                    <tr>
                        <th>Cost</th>
                        <th>Monolith</th>
                        <th>Microservices</th>
                    </tr>
                    <tr>
                        <td>Code complexity</td>
                        <td>‚≠ê‚≠ê</td>
                        <td>‚≠ê‚≠ê‚≠ê</td>
                    </tr>
                    <tr>
                        <td>Operational complexity</td>
                        <td>‚≠ê</td>
                        <td>‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê</td>
                    </tr>
                    <tr>
                        <td>Infrastructure cost</td>
                        <td>‚≠ê‚≠ê</td>
                        <td>‚≠ê‚≠ê‚≠ê‚≠ê</td>
                    </tr>
                    <tr>
                        <td>Team coordination needed</td>
                        <td>‚≠ê‚≠ê‚≠ê‚≠ê</td>
                        <td>‚≠ê</td>
                    </tr>
                </table>

                <h2>1Ô∏è‚É£7Ô∏è‚É£ Common Mistakes</h2>

                <ul>
                    <li>‚ùå Using microservices for a startup</li>
                    <li>‚ùå Not having observability in place first</li>
                    <li>‚ùå Creating too many small services (nano-services)</li>
                    <li>‚ùå Forgetting about consistency challenges</li>
                    <li>‚ùå Not having clear domain boundaries (DDD)</li>
                    <li>‚ùå Ignoring the operational complexity</li>
                    <li>‚ùå Using async/messaging without a strategy</li>
                </ul>

                <h2>1Ô∏è‚É£8Ô∏è‚É£ The Evolution Path</h2>

                <pre><code>Monolith (Spaghetti)
   ‚Üì
Layered Architecture
   ‚Üì
Modular Monolith
   ‚Üì
Domain-Driven Design (clear boundaries)
   ‚Üì
Microservices (when team grows)
   ‚Üì
Distributed architecture (maturity)</code></pre>

                <h2>üéØ Final Conclusion (Senior Mindset)</h2>

                <p>Microservices is NOT a technical improvement.</p>

                <p><strong>It's an organizational decision.</strong></p>

                <p>It's a tool for:</p>

                <ul>
                    <li>Reducing organizational friction</li>
                    <li>Increasing autonomy</li>
                    <li>Scaling teams</li>
                </ul>

                <p>But you introduce:</p>

                <ul>
                    <li>Distributed complexity</li>
                    <li>Network failures</li>
                    <li>Eventual consistency</li>
                    <li>Advanced infrastructure</li>
                </ul>

                <p><strong>The decision to go to microservices should be based on organizational needs, not technical hype.</strong></p>

                <h2>üéØ Key Takeaways</h2>

                <ul>
                    <li>‚úî Modular Monolith scales well up to medium teams</li>
                    <li>‚úî Microservices is an organizational tool, not a technical one</li>
                    <li>‚úî The network always fails‚Äîdesign for it</li>
                    <li>‚úî ACID transactions become eventual consistency</li>
                    <li>‚úî Distributed debugging requires serious observability</li>
                    <li>‚úî Each service needs its own database (data isolation)</li>
                    <li>‚úî Conway's Law: system mirrors team structure</li>
                    <li>‚úî Don't start with microservices unless you need to scale teams</li>
                    <li>‚úî The operational complexity tax is real and heavy</li>
                    <li>‚úî A well-designed monolith beats a poorly designed distributed system</li>
                </ul>

                <h2>üìö Resources</h2>

                <ul>
                    <li><a href="https://chatgpt.com/g/g-p-69925f6597e88191b8bcb93447c5bb78-dragos/c/6998844a-a4ac-8392-b367-e0febd2e415a" target="_blank">Microservices & Distributed Systems - Dragos</a></li>
                </ul>

                <div class="navigation-buttons">
                    <button class="btn btn-secondary" onclick="window.location.href='../index.html'">‚Üê Back</button>
                    <button class="btn btn-primary" onclick="window.location.href='../../index.html'">Home ‚Üí</button>
                </div>
            </section>
        </main>
    </div>

    <script src="../../assets/js/app.js"></script>
</body>
</html>
