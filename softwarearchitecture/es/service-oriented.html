<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Service Oriented Architecture | Arquitectura de Software</title>
    <link rel="stylesheet" href="../../assets/css/styles.css">
</head>
<body>
    <div class="container">
        <main class="main-content">
            <section id="section-service-oriented">
                <h1>ü™Ü 1.2 Service Oriented Architecture</h1>
                <p><strong>De MVC a Monolito Modular con Service Layer (Y c√≥mo esto te prepara para Microservicios)</strong></p>

                <h2>1Ô∏è‚É£ El Problema Real: Cuando el C√≥digo Empieza a Crecer</h2>

                <p>Imagina que empiezas un backend peque√±o:</p>

                <pre><code>app.js
controllers/
models/
routes/</code></pre>

                <p>Todo funciona. A√±ades features. M√°s endpoints. M√°s reglas.</p>

                <p>Y de repente:</p>

                <ul>
                    <li>Controllers con l√≥gica de negocio</li>
                    <li>Llamadas directas entre m√≥dulos</li>
                    <li>Repetici√≥n de c√≥digo</li>
                    <li>Auth mezclado con l√≥gica de dominio</li>
                    <li>Cache copiada en 3 sitios</li>
                </ul>

                <p>Bienvenido al Spaghetti 2.0.</p>

                <h2>2Ô∏è‚É£ Primer Paso: Capas (MVC / Layered Architecture)</h2>

                <p>La primera mejora natural es separar por capas:</p>

                <ul>
                    <li>Presentation (Controllers)</li>
                    <li>Application / Domain (Services / Use Cases)</li>
                    <li>Persistence (Repositories / Models)</li>
                    <li>Database</li>
                </ul>

                <p>Por m√≥dulo:</p>

                <pre><code>modules/
  movies/
    MovieController.ts
    MovieService.ts
    MovieRepository.ts
    Movie.ts</code></pre>

                <h3>üéØ ¬øQu√© conseguimos?</h3>

                <ul>
                    <li>Separaci√≥n de responsabilidades</li>
                    <li>C√≥digo m√°s testeable</li>
                    <li>Menos acoplamiento</li>
                </ul>

                <p>Pero a√∫n no es suficiente.</p>

                <h2>3Ô∏è‚É£ El Siguiente Problema: L√≥gica Transversal (Cross-Cutting Concerns)</h2>

                <p>Empiezan a aparecer cosas que no encajan en MVC:</p>

                <ul>
                    <li>Autenticaci√≥n</li>
                    <li>Logging</li>
                    <li>Configuraci√≥n</li>
                    <li>Cache</li>
                    <li>Email</li>
                    <li>Encriptaci√≥n</li>
                    <li>Integraciones externas (Stripe, Auth0, etc.)</li>
                </ul>

                <p>Esto no es vista, no es modelo, no es controlador.</p>

                <p>Aqu√≠ nace el siguiente paso natural:</p>

                <h2>4Ô∏è‚É£ Introduciendo la Service Layer (Servicios Internos)</h2>

                <h3>üí° Idea Clave</h3>

                <p>Un servicio:</p>

                <ul>
                    <li>Encapsula l√≥gica</li>
                    <li>Expone una API m√≠nima</li>
                    <li>Oculta implementaci√≥n</li>
                    <li>Puede ser usado por m√∫ltiples m√≥dulos</li>
                </ul>

                <p>Piensa en ello como electricidad o internet en una casa.</p>

                <p>T√∫ solo ves el enchufe.<br>
                No ves la central el√©ctrica.</p>

                <h2>5Ô∏è‚É£ Tipos de Servicios (MUY Importante Separarlos)</h2>

                <p>Aqu√≠ es donde tu arquitectura mejora much√≠simo.</p>

                <h3>üü¢ 1) Domain Services (Servicios de Negocio)</h3>

                <p>Contienen reglas del dominio.</p>

                <p><strong>Ejemplos:</strong></p>

                <ul>
                    <li>PaymentService</li>
                    <li>MovieService</li>
                    <li>OrderService</li>
                </ul>

                <p><strong>Ejemplo:</strong></p>

                <pre><code>export class MovieService {
  constructor(private movieRepo: MovieRepository) {}

  async assignActor(movieId: string, actorId: string) {
    const movie = await this.movieRepo.getById(movieId);
    if (!movie) throw new Error("Movie not found");

    movie.assignActor(actorId);
    await this.movieRepo.save(movie);
  }
}</code></pre>

                <h3>üîµ 2) Infrastructure / Shared Services</h3>

                <p>Servicios transversales:</p>

                <ul>
                    <li>Cache</li>
                    <li>Logger</li>
                    <li>Config</li>
                    <li>Email</li>
                    <li>Auth Client</li>
                </ul>

                <p><strong>Ejemplo:</strong></p>

                <pre><code>export interface Cache {
  get<T>(key: string): Promise<T | null>;
  set<T>(key: string, value: T, ttl?: number): Promise<void>;
}

export class MemoryCache implements Cache {
  private store = new Map<string, unknown>();

  async get<T>(key: string): Promise<T | null> {
    return this.store.get(key) as T ?? null;
  }

  async set<T>(key: string, value: T): Promise<void> {
    this.store.set(key, value);
  }
}</code></pre>

                <p><strong>üéØ Ventaja:</strong><br>
                Si ma√±ana cambias MemoryCache por Redis, el dominio no se entera.</p>

                <h2>6Ô∏è‚É£ Modular Monolith: La Estructura Correcta</h2>

                <p>Ahora combinamos todo:</p>

                <pre><code>src/
  modules/
    movies/
      MovieController.ts
      MovieService.ts
      MovieRepository.ts
      domain/
        Movie.ts
    actors/
      ActorController.ts
      ActorService.ts
  shared/
    services/
      cache/
      logger/
      config/
      auth/
    db/</code></pre>

                <h3>üß† Concepto Clave</h3>

                <p>Cada m√≥dulo es due√±o de su dominio.</p>

                <p>Los m√≥dulos no acceden a internals de otros m√≥dulos.</p>

                <p>Se comunican a trav√©s de servicios.</p>

                <h2>7Ô∏è‚É£ Reglas de Oro para que No Vuelva el Spaghetti</h2>

                <p>Aqu√≠ viene la parte senior.</p>

                <h3>üìú Regla 1: Controllers No Contienen L√≥gica de Negocio</h3>

                <p><strong>‚ùå Mal:</strong></p>

                <pre><code>router.post("/order", async (req, res) => {
  // l√≥gica de pago aqu√≠ üò±
});</code></pre>

                <p><strong>‚úÖ Bien:</strong></p>

                <pre><code>router.post("/order", async (req, res) => {
  await orderService.createOrder(req.body);
});</code></pre>

                <h3>üìú Regla 2: Services No Conocen HTTP</h3>

                <p>Un Service no deber√≠a usar:</p>

                <ul>
                    <li>req</li>
                    <li>res</li>
                    <li>status codes</li>
                </ul>

                <p>Eso es responsabilidad de la capa de presentaci√≥n.</p>

                <h3>üìú Regla 3: Dependencias van hacia Abajo</h3>

                <pre><code>Controller ‚Üí Service ‚Üí Repository

Nunca al rev√©s.</code></pre>

                <h3>üìú Regla 4: Servicios Compartidos No Dependen del Dominio</h3>

                <p>Cache, Logger, Config no deben importar MovieService.</p>

                <p>Si eso ocurre, est√°s rompiendo arquitectura.</p>

                <h3>üìú Regla 5: Evita Ciclos</h3>

                <p>Si:</p>

                <pre><code>MovieService ‚Üí ActorService
ActorService ‚Üí MovieService</code></pre>

                <p>Tenemos un problema.</p>

                <p><strong>Soluciones:</strong></p>

                <ul>
                    <li>Extraer l√≥gica com√∫n</li>
                    <li>Crear un contrato</li>
                    <li>Usar eventos</li>
                </ul>

                <h2>8Ô∏è‚É£ Aplicando SOLID y DRY Correctamente</h2>

                <h3>üîπ DRY</h3>

                <p>Si repites l√≥gica de validaci√≥n o pagos, extr√°ela a un servicio.</p>

                <h3>üîπ Interface Segregation</h3>

                <p>No expongas m√©todos innecesarios.</p>

                <p><strong>‚ùå Mal:</strong></p>

                <pre><code>class DatabaseService {
  connect()
  disconnect()
  rawQuery()
  dropAllTables()
}</code></pre>

                <p><strong>‚úÖ Bien:</strong></p>

                <p>Exp√≥n solo lo necesario.</p>

                <h3>üîπ Dependency Inversion</h3>

                <p>Depende de interfaces, no implementaciones.</p>

                <pre><code>constructor(private cache: Cache)</code></pre>

                <p>No:</p>

                <pre><code>constructor(private cache: MemoryCache)</code></pre>

                <h2>9Ô∏è‚É£ ¬øD√≥nde Entran los Use Cases?</h2>

                <p>Nivel a√∫n m√°s profesional:</p>

                <pre><code>Controller ‚Üí UseCase ‚Üí Services ‚Üí Repositories</code></pre>

                <p><strong>Ejemplo:</strong></p>

                <pre><code>export class CreatePayment {
  constructor(private paymentService: PaymentService) {}

  async execute(input: PaymentDTO) {
    return this.paymentService.create(input);
  }
}</code></pre>

                <p><strong>Ventajas:</strong></p>

                <ul>
                    <li>Ultra testeable</li>
                    <li>Separaci√≥n perfecta</li>
                    <li>Escala mejor</li>
                </ul>

                <h2>üîü Testing: Donde se Nota la Arquitectura</h2>

                <p>Con esta estructura puedes:</p>

                <ul>
                    <li>Mockear repositorios</li>
                    <li>Mockear cache</li>
                    <li>Testear servicios sin base de datos</li>
                    <li>Testear controllers con integraci√≥n</li>
                </ul>

                <p><strong>Ejemplo:</strong></p>

                <pre><code>it("assigns actor to movie", async () => {
  const mockRepo = { getById: jest.fn(), save: jest.fn() };
  const service = new MovieService(mockRepo as any);

  await service.assignActor("1", "2");

  expect(mockRepo.save).toHaveBeenCalled();
});</code></pre>

                <h2>1Ô∏è‚É£1Ô∏è‚É£ ¬øCu√°ndo Pasar a Microservicios?</h2>

                <p>Una pregunta senior.</p>

                <p><strong>NO cuando:</strong></p>

                <ul>
                    <li>El c√≥digo crece</li>
                    <li>Te apetece</li>
                    <li>Lo viste en YouTube</li>
                </ul>

                <p><strong>S√ç cuando:</strong></p>

                <ul>
                    <li>Equipos separados por dominio</li>
                    <li>Necesitas despliegue independiente</li>
                    <li>Necesitas escalado independiente</li>
                    <li>Boundaries muy claros</li>
                </ul>

                <p>Microservices es b√°sicamente:</p>

                <p>üëâ Sacar esos Domain Services fuera del monolito<br>
                üëâ Desplegarlos por separado<br>
                üëâ A√±adir red, resiliencia, observabilidad</p>

                <p>Pero si tu monolito est√° mal dise√±ado, tus microservicios ser√°n un desastre distribuido.</p>

                <h2>1Ô∏è‚É£2Ô∏è‚É£ Resumen Mental para Entrevistas</h2>

                <p><strong>"Empiezo con MVC para organizar. Cuando el sistema crece, extraigo l√≥gica transversal y de negocio a una Service Layer, aplicando DRY y SOLID. Mantengo m√≥dulos independientes, dependencias hacia abajo y contratos claros. Esto me permite escalar el monolito limpiamente y me prepara para una futura migraci√≥n a microservicios si el contexto lo requiere."</strong></p>

                <h2>1Ô∏è‚É£3Ô∏è‚É£ Arquitectura vs Implementaci√≥n</h2>

                <table class="cheat-sheet-table">
                    <tr>
                        <th>Aspecto</th>
                        <th>MVC</th>
                        <th>Service Layer</th>
                        <th>Microservicios</th>
                    </tr>
                    <tr>
                        <td>Organizaci√≥n del c√≥digo</td>
                        <td>Por funci√≥n (C/M/V)</td>
                        <td>Por dominio + servicios</td>
                        <td>Por bounded context</td>
                    </tr>
                    <tr>
                        <td>Despliegue</td>
                        <td>Monolito √∫nico</td>
                        <td>Monolito √∫nico</td>
                        <td>Servicios independientes</td>
                    </tr>
                    <tr>
                        <td>Direcci√≥n de dependencias</td>
                        <td>Model es core</td>
                        <td>Domain + Shared services</td>
                        <td>Services + messaging</td>
                    </tr>
                    <tr>
                        <td>Testing</td>
                        <td>M√°s integraci√≥n</td>
                        <td>Unit + integraci√≥n</td>
                        <td>Contract testing</td>
                    </tr>
                </table>

                <h2>1Ô∏è‚É£4Ô∏è‚É£ Errores Comunes</h2>

                <ul>
                    <li>‚ùå Crear demasiados servicios muy pronto</li>
                    <li>‚ùå Servicios que hacen todo (God Services)</li>
                    <li>‚ùå Dependencias circulares entre servicios</li>
                    <li>‚ùå Controllers que a√∫n contienen l√≥gica de negocio</li>
                    <li>‚ùå Servicios compartidos dependiendo de servicios de dominio</li>
                    <li>‚ùå No tener contratos/interfaces claros</li>
                    <li>‚ùå Mezclar llamadas s√≠ncronas y asincr√≥nicas sin estrategia</li>
                </ul>

                <h2>1Ô∏è‚É£5Ô∏è‚É£ El Camino de Evoluci√≥n</h2>

                <pre><code>Simple CRUD
   ‚Üì
MVC con capas
   ‚Üì
Service Layer (actual)
   ‚Üì
Domain-Driven Design
   ‚Üì
Event-Driven Architecture
   ‚Üì
Microservicios (si es necesario)</code></pre>

                <p>No saltes pasos. Construye sobre fundamentos.</p>

                <h2>üéØ Puntos Clave</h2>

                <ul>
                    <li>‚úî Service Layer resuelve el problema "¬ød√≥nde pongo esta l√≥gica?"</li>
                    <li>‚úî Separa Domain Services de Infrastructure Services</li>
                    <li>‚úî Controllers se quedan finos, Services es donde vive la l√≥gica</li>
                    <li>‚úî Las dependencias siempre fluyen hacia abajo</li>
                    <li>‚úî Servicios compartidos son utilities, no l√≥gica de negocio</li>
                    <li>‚úî Cada m√≥dulo es due√±o de su dominio y contratos</li>
                    <li>‚úî Usa interfaces para Inversi√≥n de Dependencias</li>
                    <li>‚úî Esta estructura hace que testing sea natural</li>
                    <li>‚úî Buena arquitectura de monolito = mejores microservicios despu√©s</li>
                    <li>‚úî No saltes prematuramente a microservicios</li>
                </ul>

                <h2>üìö Recursos</h2>

                <ul>
                    <li><a href="https://chatgpt.com/g/g-p-69925f6597e88191b8bcb93447c5bb78-dragos/c/69988338-cd84-8390-bce9-c80059e8f901" target="_blank">Service Oriented Architecture - Dragos</a></li>
                </ul>

                <div class="navigation-buttons">
                    <button class="btn btn-secondary" onclick="window.location.href='../index.html'">‚Üê Volver Atr√°s</button>
                    <button class="btn btn-primary" onclick="window.location.href='../../index.html'">Volver al Inicio ‚Üí</button>
                </div>
            </section>
        </main>
    </div>

    <script src="../../assets/js/app.js"></script>
</body>
</html>
