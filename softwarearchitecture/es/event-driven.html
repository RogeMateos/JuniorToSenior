<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Event Driven Architecture | Arquitectura de Software</title>
    <link rel="stylesheet" href="../../assets/css/styles.css">
</head>
<body>
    <div class="container">
        <main class="main-content">
            <section id="section-event-driven">
                <h1>üîî 1.6 Event Driven Architecture</h1>
                <p><strong>De Cascadas S√≠ncronas a Sistemas Reactivos y Desacoplados</strong></p>

                <h2>1Ô∏è‚É£ El Problema: Cascadas de Requests</h2>

                <p>Imagina que tienes 30‚Äì40 microservicios.</p>

                <p>Un usuario hace login y:</p>

                <pre><code>Service A ‚Üí llama a B ‚Üí llama a C ‚Üí llama a D ‚Üí llama a E ‚Üí llama a F</code></pre>

                <p><strong>Problemas reales:</strong></p>

                <h3>‚ùå 1. Latencia Acumulada</h3>

                <p>Cada llamada HTTP suma tiempo.<br>
                5 servicios √ó 80ms = 400ms solo en red.</p>

                <h3>‚ùå 2. Cascading Failures</h3>

                <p>Si F falla ‚Üí E falla ‚Üí D falla ‚Üí A falla.</p>

                <p>Un peque√±o error tumba toda la experiencia.</p>

                <h3>‚ùå 3. Alto Acoplamiento</h3>

                <p>A depende directamente de B.<br>
                B depende de C.<br>
                Cambiar C puede romper todo.</p>

                <h3>‚ùå 4. Dif√≠cil de Depurar</h3>

                <p>¬øD√≥nde fall√≥?<br>
                ¬øQui√©n empez√≥ la cadena?<br>
                ¬øQui√©n depende de qui√©n?</p>

                <h2>2Ô∏è‚É£ El Cambio de Paradigma</h2>

                <p>En lugar de:</p>

                <p><strong>"Necesito llamar a todos los servicios para completar la acci√≥n"</strong></p>

                <p>Pensamos:</p>

                <p><strong>"Algo pas√≥. Voy a publicar un evento."</strong></p>

                <h2>3Ô∏è‚É£ ¬øQu√© es un Evento?</h2>

                <p>Un evento es un hecho que ya ocurri√≥.</p>

                <p><strong>Ejemplos:</strong></p>

                <ul>
                    <li>UserCreated</li>
                    <li>OrderPlaced</li>
                    <li>PaymentCaptured</li>
                    <li>EmailSent</li>
                </ul>

                <p>Un evento dice:</p>

                <p><strong>"Esto ya pas√≥"</strong></p>

                <p>No dice:</p>

                <p><strong>"Haz esto"</strong> (eso ser√≠a un comando)</p>

                <h3>üîé Evento vs Comando</h3>

                <table class="cheat-sheet-table">
                    <tr>
                        <th>Tipo</th>
                        <th>Significado</th>
                        <th>Ejemplo</th>
                    </tr>
                    <tr>
                        <td>Evento</td>
                        <td>Hecho ocurrido</td>
                        <td>UserCreated</td>
                    </tr>
                    <tr>
                        <td>Comando</td>
                        <td>Petici√≥n de acci√≥n</td>
                        <td>CreateUser</td>
                    </tr>
                </table>

                <p><strong>‚ö†Ô∏è Confundirlos genera caos arquitect√≥nico.</strong></p>

                <h2>4Ô∏è‚É£ Pub/Sub: El Modelo B√°sico</h2>

                <p>En vez de A ‚Üí B ‚Üí C:</p>

                <p>Tenemos:</p>

                <pre><code>Service A
   ‚Üì
Event Bus
   ‚Üì
Service B
Service C
Service D
Service E</code></pre>

                <p>Service A publica:</p>

                <pre><code>{
  "type": "UserCreated",
  "data": {
    "userId": "123",
    "email": "test@mail.com"
  }
}</code></pre>

                <p>Y los servicios interesados reaccionan.</p>

                <h2>5Ô∏è‚É£ Ejemplo Pr√°ctico: Registro de Usuario</h2>

                <h3>Paso 1</h3>

                <p>User Service crea el usuario.</p>

                <h3>Paso 2</h3>

                <p>Publica evento:</p>

                <pre><code>{
  "eventId": "abc-123",
  "type": "UserCreated",
  "occurredAt": "2026-02-20T14:00:00Z",
  "data": {
    "userId": "u1",
    "email": "user@mail.com"
  }
}</code></pre>

                <h3>Paso 3</h3>

                <p>Email Service escucha ‚Üí env√≠a email.</p>

                <h3>Paso 4</h3>

                <p>Analytics Service escucha ‚Üí guarda m√©trica.</p>

                <h3>Paso 5</h3>

                <p>Fraud Service escucha ‚Üí analiza comportamiento.</p>

                <p><strong>User Service no sabe qui√©n reacciona.</strong></p>

                <p><strong>Eso es desacoplamiento real.</strong></p>

                <h2>6Ô∏è‚É£ Ventajas Reales</h2>

                <h3>‚úÖ 1. Desacoplamiento</h3>

                <p>Los servicios no se conocen entre s√≠.</p>

                <h3>‚úÖ 2. Plug & Play</h3>

                <p>A√±ades un nuevo servicio que escuche eventos.<br>
                No rompes nada.</p>

                <h3>‚úÖ 3. Menos Latencia Cr√≠tica</h3>

                <p>El usuario no espera a:</p>

                <ul>
                    <li>enviar email</li>
                    <li>generar invoice</li>
                    <li>actualizar analytics</li>
                </ul>

                <h3>‚úÖ 4. Mejor Alineaci√≥n con el Negocio</h3>

                <p>Los negocios funcionan por eventos:</p>

                <ul>
                    <li>Usuario compra</li>
                    <li>Pago aprobado</li>
                    <li>Pedido enviado</li>
                </ul>

                <p>EDA refleja eso naturalmente.</p>

                <h2>7Ô∏è‚É£ El Precio que Pagas (Muy Importante)</h2>

                <p>Aqu√≠ empieza la parte senior.</p>

                <p><strong>EDA no es magia.</strong></p>

                <h3>‚ö†Ô∏è 1. Consistencia Eventual</h3>

                <p>No todo ocurre inmediatamente.</p>

                <p>Usuario compra ‚Üí<br>
                Inventory se actualiza unos ms despu√©s ‚Üí<br>
                Billing unos ms despu√©s ‚Üí<br>
                Analytics despu√©s.</p>

                <p>Aceptas:</p>

                <p><strong>"No todo estar√° sincronizado en el mismo instante."</strong></p>

                <h3>‚ö†Ô∏è 2. Duplicados (At-Least-Once Delivery)</h3>

                <p>Muchos sistemas de mensajer√≠a garantizan:</p>

                <p><strong>El mensaje llega al menos una vez.</strong></p>

                <p>Eso significa: Puede llegar dos veces.</p>

                <p>Tu consumidor debe ser idempotente.</p>

                <p><strong>Ejemplo:</strong></p>

                <p>‚ùå Email Service env√≠a 2 emails.</p>

                <p><strong>Soluci√≥n:</strong><br>
                Guardar eventIds procesados.</p>

                <h3>‚ö†Ô∏è 3. Orden</h3>

                <p>¬øImporta el orden de eventos?</p>

                <p>En Kafka depende de particiones.<br>
                En colas normales no hay orden global garantizado.</p>

                <p>Si tu dominio depende del orden, debes dise√±arlo expl√≠citamente.</p>

                <h3>‚ö†Ô∏è 4. Retries y Dead Letter Queue</h3>

                <p>Si un evento falla:</p>

                <ul>
                    <li>Retry autom√°tico</li>
                    <li>Si sigue fallando ‚Üí DLQ</li>
                </ul>

                <p>Sin esto, pierdes mensajes.</p>

                <h2>8Ô∏è‚É£ Orchestration vs Choreography</h2>

                <h3>üéº Choreography</h3>

                <p>Servicios reaccionan libremente a eventos.</p>

                <p><strong>Ventajas:</strong></p>

                <ul>
                    <li>Muy desacoplado</li>
                    <li>Escalable</li>
                </ul>

                <p><strong>Problemas:</strong></p>

                <ul>
                    <li>Dif√≠cil entender el flujo global</li>
                    <li>Debugging complejo</li>
                </ul>

                <h3>üé¨ Orchestration</h3>

                <p>Un servicio central coordina el proceso.</p>

                <p><strong>Ejemplo:</strong></p>

                <pre><code>Order Service:
  env√≠a comando a Payment
  espera evento PaymentConfirmed
  env√≠a comando a Shipping</code></pre>

                <p><strong>Ventajas:</strong></p>

                <ul>
                    <li>Flujo claro</li>
                    <li>M√°s control</li>
                </ul>

                <p><strong>Desventajas:</strong></p>

                <ul>
                    <li>Puede volverse un mega-servicio si se hace mal</li>
                </ul>

                <h2>9Ô∏è‚É£ Tecnolog√≠a: ¬øQu√© Usar?</h2>

                <h3>üü¢ SQS (Queue)</h3>

                <p>Trabajo puntual</p>

                <p>1 consumidor procesa</p>

                <p>Ideal para:</p>

                <ul>
                    <li>Jobs</li>
                    <li>Procesamiento as√≠ncrono simple</li>
                </ul>

                <h3>üîµ Kafka (Streaming)</h3>

                <p>Topics, particiones, consumer groups, replay de eventos</p>

                <p>Ideal para:</p>

                <ul>
                    <li>Sistemas grandes</li>
                    <li>Auditor√≠a</li>
                    <li>Analytics</li>
                    <li>Alta escala</li>
                </ul>

                <h3>üü† Redis</h3>

                <p>Pub/Sub b√°sico o Streams (m√°s robusto)</p>

                <p>Bueno para:</p>

                <ul>
                    <li>Casos simples</li>
                    <li>Infra ligera</li>
                </ul>

                <h2>üîü Patr√≥n Cr√≠tico: Outbox Pattern</h2>

                <p><strong>Problema:</strong></p>

                <p>Guardas en DB ‚Üí publicas evento<br>
                Si el servicio cae entre ‚Üí inconsistencia.</p>

                <p><strong>Soluci√≥n:</strong></p>

                <ul>
                    <li>Guardas en DB</li>
                    <li>Guardas evento en tabla outbox</li>
                    <li>Un proceso publica desde outbox</li>
                </ul>

                <p>As√≠ nunca pierdes eventos.</p>

                <h2>1Ô∏è‚É£1Ô∏è‚É£ Observabilidad (Sin Esto Est√°s Muerto)</h2>

                <p>Siempre incluye:</p>

                <ul>
                    <li>correlationId</li>
                    <li>eventId</li>
                    <li>Logs estructurados</li>
                    <li>Tracing distribuido</li>
                </ul>

                <p><strong>Sin esto, EDA es imposible de debugear.</strong></p>

                <h2>1Ô∏è‚É£2Ô∏è‚É£ ¬øCu√°ndo NO Usar EDA?</h2>

                <p>No todo debe ser evento.</p>

                <p>Usa comunicaci√≥n s√≠ncrona cuando:</p>

                <ul>
                    <li>El usuario necesita respuesta inmediata</li>
                    <li>Necesitas validaci√≥n fuerte en tiempo real</li>
                    <li>Es una simple query</li>
                </ul>

                <p><strong>REST/GraphQL sigue existiendo.</strong></p>

                <p><strong>EDA no reemplaza todo.</strong></p>

                <h2>1Ô∏è‚É£3Ô∏è‚É£ Regla Mental</h2>

                <table class="cheat-sheet-table">
                    <tr>
                        <th>Necesidad</th>
                        <th>Soluci√≥n</th>
                    </tr>
                    <tr>
                        <td>Necesito respuesta inmediata</td>
                        <td>REST</td>
                    </tr>
                    <tr>
                        <td>Es un efecto secundario</td>
                        <td>Evento</td>
                    </tr>
                    <tr>
                        <td>Trabajo puntual</td>
                        <td>Queue</td>
                    </tr>
                    <tr>
                        <td>Evento para muchos</td>
                        <td>Pub/Sub</td>
                    </tr>
                    <tr>
                        <td>Flujo complejo</td>
                        <td>Orchestrator</td>
                    </tr>
                </table>

                <h2>1Ô∏è‚É£4Ô∏è‚É£ Resumen Senior</h2>

                <p>Cuando el sistema crece:</p>

                <ul>
                    <li>Las llamadas s√≠ncronas crean cascadas</li>
                    <li>Las cascadas crean fragilidad</li>
                    <li>Los eventos crean desacoplamiento</li>
                    <li>El desacoplamiento crea resiliencia</li>
                </ul>

                <p>Pero:</p>

                <ul>
                    <li>Ganas complejidad operacional</li>
                    <li>Necesitas idempotencia</li>
                    <li>Necesitas observabilidad</li>
                    <li>Necesitas disciplina</li>
                </ul>

                <p><strong>EDA no es para principiantes,<br>
                pero entender el patr√≥n es obligatorio para nivel senior.</strong></p>

                <h2>üéØ Puntos Clave</h2>

                <ul>
                    <li>‚úî Los eventos representan hechos, los comandos solicitan acciones</li>
                    <li>‚úî Pub/Sub desacopla servicios entre s√≠</li>
                    <li>‚úî Consistencia eventual es aceptable para efectos secundarios</li>
                    <li>‚úî Idempotencia es obligatoria (at-least-once delivery)</li>
                    <li>‚úî Outbox pattern asegura confiabilidad de eventos</li>
                    <li>‚úî Choreography es flexible, orchestration es clara</li>
                    <li>‚úî Kafka para escalar, SQS para simplicidad</li>
                    <li>‚úî Observabilidad con correlationId es cr√≠tica</li>
                    <li>‚úî No hagas todo asincr√≥nico</li>
                    <li>‚úî EDA + REST/GraphQL = arquitectura balanceada</li>
                </ul>

                <h2>üìö Recursos</h2>

                <ul>
                    <li><a href="https://chatgpt.com/g/g-p-69925f6597e88191b8bcb93447c5bb78-dragos/c/699888ca-7400-8395-b22a-b3d25067a420" target="_blank">Event Driven Architecture - Dragos</a></li>
                </ul>

                <div class="navigation-buttons">
                    <button class="btn btn-secondary" onclick="window.location.href='../index.html'">‚Üê Volver Atr√°s</button>
                    <button class="btn btn-primary" onclick="window.location.href='../../index.html'">Volver al Inicio ‚Üí</button>
                </div>
            </section>
        </main>
    </div>

    <script src="../../assets/js/app.js"></script>
</body>
</html>
