<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>La Arquitectura en Capas - MVC | Arquitectura de Software</title>
    <link rel="stylesheet" href="../../assets/css/styles.css">
</head>
<body>
    <div class="container">
        <main class="main-content">
            <section id="section-layered-architecture">
                <h1>ğŸ¥ 1.1 La Arquitectura en Capas - MVC</h1>
                <p><strong>De Spaghetti Code a Sistemas Limpios y Organizados</strong></p>

                <h2>ğŸ¯ Objetivos del Tutorial</h2>

                <p>Al final, entenderÃ¡s:</p>

                <ul>
                    <li>Por quÃ© el cÃ³digo se convierte en "spaghetti"</li>
                    <li>CÃ³mo aplicar SRP (Single Responsibility Principle)</li>
                    <li>CÃ³mo organizar un sistema en capas claras</li>
                    <li>La diferencia entre Layer y Tier</li>
                    <li>CÃ³mo aplicar esto en un proyecto real (Node + SPA)</li>
                    <li>QuÃ© errores evitar</li>
                    <li>CuÃ¡ndo usarlo y cuÃ¡ndo no</li>
                </ul>

                <h2>1ï¸âƒ£ El Problema: Spaghetti Code</h2>

                <p>Cuando empiezas un proyecto pequeÃ±o, todo parece fÃ¡cil:</p>

                <pre><code>app.post("/comment", async (req, res) => {
  const user = await db.getUser(req.body.userId)

  if (!user) return res.status(404).send("User not found")

  if (!req.body.text || req.body.text.length > 500) {
    return res.status(400).send("Invalid comment")
  }

  await db.insertComment({
    userId: user.id,
    text: req.body.text
  })

  res.send("OK")
})</code></pre>

                <p>Al principio funciona.</p>

                <p>Pero luego aÃ±ades:</p>

                <ul>
                    <li>Auth</li>
                    <li>Logging</li>
                    <li>Validaciones</li>
                    <li>MÃ©tricas</li>
                    <li>Emails</li>
                    <li>Nuevas reglas</li>
                </ul>

                <p>Y todo sigue viviendo en el mismo sitio.</p>

                <p><strong>Resultado:</strong></p>

                <p>Si tiras de un hiloâ€¦ se viene todo el bowl ğŸ</p>

                <h3>Problemas reales:</h3>

                <ul>
                    <li>Alto acoplamiento</li>
                    <li>DifÃ­cil de testear</li>
                    <li>DifÃ­cil de extender</li>
                    <li>Onboarding lento</li>
                    <li>Los cambios pequeÃ±os rompen cosas inesperadas</li>
                </ul>

                <h2>2ï¸âƒ£ Primer Principio: SRP (Single Responsibility)</h2>

                <p>Cada pieza de cÃ³digo deberÃ­a cambiar por una sola razÃ³n.</p>

                <p>PregÃºntate:</p>

                <ul>
                    <li>Â¿QuiÃ©n deberÃ­a cambiar esto?</li>
                    <li>Â¿La UI?</li>
                    <li>Â¿La regla de negocio?</li>
                    <li>Â¿La base de datos?</li>
                </ul>

                <p>Si la respuesta es "varios", tienes un problema.</p>

                <h2>3ï¸âƒ£ La SoluciÃ³n ClÃ¡sica: Arquitectura en Capas</h2>

                <p>Dividimos el sistema en 3 capas lÃ³gicas:</p>

                <pre><code>â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Presentation Layer   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Application/Domain   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Persistence Layer    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></pre>

                <p>Cada una con una responsabilidad clara.</p>

                <h2>4ï¸âƒ£ Presentation Layer</h2>

                <p>Responsable de:</p>

                <ul>
                    <li>HTTP</li>
                    <li>REST</li>
                    <li>GraphQL</li>
                    <li>UI</li>
                    <li>SerializaciÃ³n</li>
                    <li>Status codes</li>
                </ul>

                <p><strong>NO deberÃ­a contener:</strong></p>

                <ul>
                    <li>Reglas complejas de negocio</li>
                    <li>LÃ³gica de persistencia</li>
                </ul>

                <p><strong>Ejemplo:</strong></p>

                <pre><code>app.post("/comment", async (req, res) => {
  const result = await createCommentUseCase.execute({
    userId: req.body.userId,
    text: req.body.text
  })

  if (result.error) {
    return res.status(400).json(result.error)
  }

  res.json(result.data)
})</code></pre>

                <p>Observa algo importante:</p>

                <p>ğŸ‘‰ <strong>El controller es ahora tonto.</strong></p>

                <p>Eso es bueno.</p>

                <h2>5ï¸âƒ£ Application Layer (Use Cases)</h2>

                <p>AquÃ­ vive el flujo del sistema.</p>

                <p><strong>Ejemplo:</strong></p>

                <pre><code>class CreateCommentUseCase {
  constructor(private commentRepo: CommentRepository) {}

  async execute(input: CreateCommentInput) {
    const comment = Comment.create(input.text, input.userId)

    await this.commentRepo.save(comment)

    return { data: comment.toDTO() }
  }
}</code></pre>

                <p><strong>Responsabilidad:</strong></p>

                <ul>
                    <li>Orquestar</li>
                    <li>Coordinar repos</li>
                    <li>Aplicar reglas</li>
                    <li>Construir respuesta</li>
                </ul>

                <p><strong>NO deberÃ­a saber nada de:</strong></p>

                <ul>
                    <li>Express</li>
                    <li>Postgres</li>
                    <li>Prisma</li>
                    <li>Axios</li>
                </ul>

                <h2>6ï¸âƒ£ Domain Layer (Reglas Puras)</h2>

                <p>AquÃ­ viven las reglas reales.</p>

                <pre><code>class Comment {
  private constructor(
    public readonly text: string,
    public readonly userId: string
  ) {}

  static create(text: string, userId: string) {
    if (!text || text.length > 500) {
      throw new Error("Invalid comment")
    }

    return new Comment(text, userId)
  }

  toDTO() {
    return {
      text: this.text,
      userId: this.userId
    }
  }
}</code></pre>

                <p><strong>Importante:</strong></p>

                <ul>
                    <li>Sin dependencias externas</li>
                    <li>Sin frameworks</li>
                    <li>Sin base de datos</li>
                    <li>100% testeable</li>
                </ul>

                <p>Este es el corazÃ³n del sistema.</p>

                <h2>7ï¸âƒ£ Persistence Layer</h2>

                <p>Responsable de:</p>

                <ul>
                    <li>Guardar datos</li>
                    <li>Leer datos</li>
                    <li>Implementar interfaces</li>
                </ul>

                <p><strong>Primero definimos contrato en dominio:</strong></p>

                <pre><code>interface CommentRepository {
  save(comment: Comment): Promise<void>
}</code></pre>

                <p><strong>Luego implementamos en infraestructura:</strong></p>

                <pre><code>class PostgresCommentRepository implements CommentRepository {
  async save(comment: Comment) {
    await prisma.comment.create({
      data: {
        text: comment.text,
        userId: comment.userId
      }
    })
  }
}</code></pre>

                <p><strong>Clave arquitectÃ³nica:</strong></p>

                <p>El dominio define la interfaz.<br>
                La infraestructura la implementa.</p>

                <p>Esto es InversiÃ³n de Dependencias (SOLID).</p>

                <h2>8ï¸âƒ£ Regla de Dependencias (Muy Importante)</h2>

                <p>Las dependencias siempre apuntan hacia dentro:</p>

                <pre><code>Presentation â†’ Application â†’ Domain
Infrastructure â†’ Domain (implementa interfaces)</code></pre>

                <p><strong>âŒ El dominio no deberÃ­a importar Express</strong><br>
                <strong>âŒ El dominio no deberÃ­a importar Prisma</strong><br>
                <strong>âŒ El dominio no deberÃ­a importar Axios</strong></p>

                <p>Si eso ocurre, estÃ¡s rompiendo la arquitectura.</p>

                <h2>9ï¸âƒ£ Layer vs Tier (ConfusiÃ³n ClÃ¡sica)</h2>

                <table class="cheat-sheet-table">
                    <tr>
                        <th>Concepto</th>
                        <th>DefiniciÃ³n</th>
                    </tr>
                    <tr>
                        <td><strong>Layer</strong></td>
                        <td>Responsabilidad lÃ³gica en el cÃ³digo</td>
                    </tr>
                    <tr>
                        <td><strong>Tier</strong></td>
                        <td>UbicaciÃ³n fÃ­sica de despliegue</td>
                    </tr>
                </table>

                <p><strong>Ejemplos:</strong></p>

                <h3>Monolito (1 Tier)</h3>

                <pre><code>[Server]
  - Presentation
  - Application
  - Domain
  - DB connection

Todo en un proceso.</code></pre>

                <h3>2-Tier</h3>

                <pre><code>Client  â†’  Server
               â†’ Database</code></pre>

                <h3>SPA Moderna (3-Tier)</h3>

                <pre><code>Browser (SPA)
     â†“
API Server
     â†“
Database Server</code></pre>

                <p>AquÃ­:</p>

                <ul>
                    <li>Presentation layer vive en el frontend</li>
                    <li>Application + Domain en backend</li>
                    <li>Persistence en DB tier</li>
                </ul>

                <p><strong>Layer â‰  Tier.</strong></p>

                <h2>ğŸ”Ÿ Estructura de Carpetas Recomendada</h2>

                <p>Ejemplo Node + TypeScript:</p>

                <pre><code>src/
 â”œâ”€â”€ presentation/
 â”‚     â””â”€â”€ comment.controller.ts
 â”‚
 â”œâ”€â”€ application/
 â”‚     â””â”€â”€ create-comment.usecase.ts
 â”‚
 â”œâ”€â”€ domain/
 â”‚     â”œâ”€â”€ comment.entity.ts
 â”‚     â””â”€â”€ comment.repository.ts
 â”‚
 â””â”€â”€ infrastructure/
       â””â”€â”€ postgres-comment.repository.ts</code></pre>

                <p>Simple. Clara. Escalable.</p>

                <h2>1ï¸âƒ£1ï¸âƒ£ Ventajas Reales</h2>

                <table class="cheat-sheet-table">
                    <tr>
                        <th>Beneficio</th>
                        <th>Por QuÃ© Importa</th>
                    </tr>
                    <tr>
                        <td>âœ… Testabilidad</td>
                        <td>Testea dominio sin base de datos</td>
                    </tr>
                    <tr>
                        <td>âœ… Onboarding rÃ¡pido</td>
                        <td>Los nuevos devs saben dÃ³nde mirar</td>
                    </tr>
                    <tr>
                        <td>âœ… Escalabilidad</td>
                        <td>AÃ±adir features es predecible</td>
                    </tr>
                    <tr>
                        <td>âœ… Bajo acoplamiento</td>
                        <td>Cambiar Postgres a Mongo no rompe dominio</td>
                    </tr>
                </table>

                <h2>1ï¸âƒ£2ï¸âƒ£ Errores Comunes</h2>

                <ul>
                    <li>Separar por carpetas pero importar todo cruzado</li>
                    <li>Controllers gigantes</li>
                    <li>Entidades que saben de Prisma</li>
                    <li>Devolver modelos DB directamente al frontend</li>
                    <li>Overengineering para CRUD simple</li>
                </ul>

                <h2>1ï¸âƒ£3ï¸âƒ£ CuÃ¡ndo Usarlo</h2>

                <table class="cheat-sheet-table">
                    <tr>
                        <th>âœ” Usa Cuando</th>
                        <th>âŒ Omite Cuando</th>
                    </tr>
                    <tr>
                        <td>Hay reglas de negocio reales</td>
                        <td>Script pequeÃ±o</td>
                    </tr>
                    <tr>
                        <td>El sistema crecerÃ¡</td>
                        <td>MVP extremadamente simple</td>
                    </tr>
                    <tr>
                        <td>Equipos medianos/grandes</td>
                        <td>CRUD trivial (temporal)</td>
                    </tr>
                    <tr>
                        <td>Dominios complejos</td>
                        <td></td>
                    </tr>
                </table>

                <h2>1ï¸âƒ£4ï¸âƒ£ CÃ³mo Migrar desde Spaghetti (Sin Reescribir)</h2>

                <ol>
                    <li>Elige un endpoint</li>
                    <li>Extrae lÃ³gica a un use case</li>
                    <li>Extrae reglas puras a dominio</li>
                    <li>Crea interfaz de repositorio</li>
                    <li>Mueve acceso a DB a infraestructura</li>
                    <li>Deja controller mÃ­nimo</li>
                </ol>

                <p><strong>Refactor incremental. No big-bang.</strong></p>

                <h2>1ï¸âƒ£5ï¸âƒ£ QuÃ© Viene DespuÃ©s</h2>

                <p>Layered architecture es el fundamento.</p>

                <p>Luego puedes evolucionar hacia:</p>

                <ul>
                    <li>Hexagonal Architecture</li>
                    <li>Clean Architecture</li>
                    <li>CQRS</li>
                    <li>Microservices</li>
                </ul>

                <p>Pero todos parten de aquÃ­.</p>

                <h2>1ï¸âƒ£6ï¸âƒ£ El Viaje Mental</h2>

                <pre><code>Spaghetti
   â†“
Capas Claras
   â†“
LÃ­mites Definidos
   â†“
Sistema Escalable</code></pre>

                <p><strong>La clave no es separar carpetas.</strong></p>

                <p><strong>La clave es:</strong></p>

                <ul>
                    <li>âœ” Responsabilidades claras</li>
                    <li>âœ” Dependencias correctas</li>
                    <li>âœ” Dominio puro</li>
                    <li>âœ” Infraestructura como detalle</li>
                </ul>

                <h2>ğŸ¯ Puntos Clave</h2>

                <ul>
                    <li>âœ” SRP es el fundamento de la buena arquitectura</li>
                    <li>âœ” Las capas crean lÃ­mites claros de responsabilidad</li>
                    <li>âœ” El dominio debe ser agnÃ³stico a frameworks</li>
                    <li>âœ” Las dependencias apuntan hacia dentro, nunca hacia afuera</li>
                    <li>âœ” Layer es lÃ³gico, Tier es fÃ­sico</li>
                    <li>âœ” Presentation se queda tonto, Application orquesta, Domain regula</li>
                    <li>âœ” La testabilidad aumenta con capas correctas</li>
                    <li>âœ” No hagas overengineering en proyectos simples</li>
                    <li>âœ” Refactoriza incrementalmente, no todo de una vez</li>
                    <li>âœ” Esto es el fundamento para patrones mÃ¡s avanzados</li>
                </ul>

                <h2>ğŸ“š Recursos</h2>

                <ul>
                    <li><a href="https://chatgpt.com/g/g-p-69925f6597e88191b8bcb93447c5bb78-dragos/c/69987140-4578-8392-b936-af2b00cc8ed6" target="_blank">Arquitectura en Capas & MVC - Dragos</a></li>
                </ul>

                <div class="navigation-buttons">
                    <button class="btn btn-secondary" onclick="window.location.href='../index.html'">â† Volver AtrÃ¡s</button>
                    <button class="btn btn-primary" onclick="window.location.href='../../index.html'">Volver al Inicio â†’</button>
                </div>
            </section>
        </main>
    </div>

    <script src="../../assets/js/app.js"></script>
</body>
</html>
