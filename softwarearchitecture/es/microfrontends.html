<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Microfrontends | Arquitectura de Software</title>
    <link rel="stylesheet" href="../../assets/css/styles.css">
</head>
<body>
    <div class="container">
        <main class="main-content">
            <section id="section-microfrontends">
                <h1>üé® 1.5 Microfrontends</h1>
                <p><strong>La Evoluci√≥n del Frontend en Sistemas Distribuidos</strong></p>

                <h2>1Ô∏è‚É£ El Problema Real</h2>

                <p>Imagina esto:</p>

                <ul>
                    <li>Backend ‚Üí ya lo dividimos en microservicios ‚úÖ</li>
                    <li>Frontend ‚Üí sigue siendo una SPA gigante ‚ùå</li>
                </ul>

                <p>Tienes:</p>

                <ul>
                    <li>100+ desarrolladores frontend</li>
                    <li>Deploys constantes</li>
                    <li>Pull requests infinitos</li>
                    <li>Conflictos de dependencias</li>
                    <li>Cambios que rompen otras √°reas</li>
                </ul>

                <p>Aunque est√© "bien estructurado", sigue siendo un monolito frontend.</p>

                <p>üëâ <strong>Esto crea un cuello de botella organizativo.</strong></p>

                <h2>2Ô∏è‚É£ Qu√© Son Realmente los Microfrontends</h2>

                <p>Definici√≥n simple:</p>

                <p><strong>Microfrontends aplican los principios de microservicios al frontend.</strong></p>

                <p>Es decir:</p>

                <ul>
                    <li>Dividir la SPA en aplicaciones m√°s peque√±as</li>
                    <li>Cada una con ownership claro</li>
                    <li>Deploy independiente</li>
                    <li>Equipo independiente</li>
                </ul>

                <h2>3Ô∏è‚É£ ‚ö†Ô∏è Error Com√∫n: No es Dividir por Layout</h2>

                <p>Muchos ejemplos muestran:</p>

                <ul>
                    <li>Header</li>
                    <li>Sidebar</li>
                    <li>Content</li>
                </ul>

                <p>Eso sirve como visualizaci√≥n, pero no es la forma ideal de cortar.</p>

                <p><strong>‚ùå Dividir por layout<br>
                ‚úÖ Dividir por dominio/feature</strong></p>

                <p><strong>Ejemplo correcto:</strong></p>

                <ul>
                    <li>Checkout</li>
                    <li>Account</li>
                    <li>Search</li>
                    <li>Product</li>
                </ul>

                <p>Cada uno es un dominio del negocio.</p>

                <h2>4Ô∏è‚É£ El Modelo Mental Correcto</h2>

                <p>Piensa en tu web como un mosaico.</p>

                <p>Cada "tile":</p>

                <ul>
                    <li>Tiene su c√≥digo</li>
                    <li>Tiene su backend</li>
                    <li>Tiene su pipeline</li>
                    <li>Tiene su equipo</li>
                </ul>

                <p>Pero hay algo que une todo‚Ä¶</p>

                <h2>5Ô∏è‚É£ El Shell (La Plataforma)</h2>

                <p>El Shell NO es solo un contenedor visual.</p>

                <p><strong>Es la plataforma del frontend.</strong></p>

                <p>Debe encargarse de:</p>

                <ul>
                    <li>Bootstrap de aplicaciones remotas</li>
                    <li>Routing global</li>
                    <li>Autenticaci√≥n</li>
                    <li>Estado global m√≠nimo</li>
                    <li>Design system</li>
                    <li>Logging y monitorizaci√≥n</li>
                    <li>Feature flags</li>
                </ul>

                <p><strong>‚ö†Ô∏è Si no defines claramente qu√© hace el Shell, el sistema se vuelve caos.</strong></p>

                <h2>6Ô∏è‚É£ Arquitectura Completa</h2>

                <p>Ahora el sistema queda as√≠:</p>

                <p><strong>Backend distribuido</strong></p>

                <p>Microservicios.</p>

                <p><strong>Frontend distribuido</strong></p>

                <p>Microfrontends.</p>

                <p><strong>Equipos</strong></p>

                <p>Equipos end-to-end:</p>

                <pre><code>Team Checkout ‚Üí FE + BFF + microservicios + DB

Team Account ‚Üí FE + backend propio

Team Search ‚Üí FE + backend propio</code></pre>

                <p>Esto permite:</p>

                <ul>
                    <li>Deploy independiente</li>
                    <li>Ownership real</li>
                    <li>Trabajo en paralelo</li>
                </ul>

                <h2>7Ô∏è‚É£ Formas de Implementarlo</h2>

                <p>Microfrontend no es una tecnolog√≠a.<br>
                <strong>Es un patr√≥n.</strong></p>

                <p>Existen varios estilos:</p>

                <h3>üîπ 1. Runtime Composition</h3>

                <p><strong>Ejemplos:</strong></p>

                <ul>
                    <li>Single-SPA</li>
                    <li>Webpack Module Federation</li>
                    <li>Import Maps</li>
                </ul>

                <p><strong>Ventajas:</strong></p>

                <ul>
                    <li>Deploy independiente real</li>
                    <li>Integraci√≥n din√°mica</li>
                </ul>

                <p><strong>Desventajas:</strong></p>

                <ul>
                    <li>Mucha complejidad</li>
                    <li>Problemas de dependencias compartidas</li>
                </ul>

                <h3>üîπ 2. Build-Time Composition</h3>

                <p><strong>Ejemplos:</strong></p>

                <ul>
                    <li>Monorepo</li>
                    <li>Paquetes NPM internos</li>
                    <li>Micro-apps ensambladas en build</li>
                </ul>

                <p><strong>Ventajas:</strong></p>

                <ul>
                    <li>M√°s simple</li>
                    <li>Menos problemas de runtime</li>
                </ul>

                <p><strong>Desventajas:</strong></p>

                <ul>
                    <li>No hay independencia total de deploy</li>
                </ul>

                <h3>üîπ 3. Server-Side Composition</h3>

                <p><strong>Ejemplos:</strong></p>

                <ul>
                    <li>SSR distribuido</li>
                    <li>Fragmentos ensamblados en servidor</li>
                </ul>

                <p><strong>Ventajas:</strong></p>

                <ul>
                    <li>SEO y rendimiento potencialmente mejores</li>
                </ul>

                <p><strong>Desventajas:</strong></p>

                <ul>
                    <li>Cache complejo</li>
                    <li>Coordinaci√≥n dif√≠cil</li>
                </ul>

                <h2>8Ô∏è‚É£ Los Problemas Reales (Y C√≥mo Se Resuelven)</h2>

                <p>Aqu√≠ es donde un senior marca la diferencia.</p>

                <h3>üß† 1. Estado Compartido</h3>

                <p><strong>Problema:</strong></p>

                <p>Auth, idioma, usuario</p>

                <p><strong>Soluci√≥n madura:</strong></p>

                <p>NO compartir Redux gigante.</p>

                <p>S√≠ crear un contrato m√≠nimo:</p>

                <pre><code>auth.getToken()
i18n.getLocale()
eventBus.emit()</code></pre>

                <h3>üß≠ 2. Routing</h3>

                <p><strong>Problema:</strong></p>

                <p>¬øQui√©n controla /checkout/address?</p>

                <p><strong>Soluci√≥n:</strong></p>

                <p>Shell controla:</p>

                <pre><code>/checkout/*</code></pre>

                <p>Checkout MFE controla:</p>

                <pre><code>subrutas internas</code></pre>

                <p>Routing jer√°rquico.</p>

                <h3>üé® 3. Consistencia Visual</h3>

                <p>Gran problema.</p>

                <p><strong>Soluciones:</strong></p>

                <ul>
                    <li>Design tokens compartidos</li>
                    <li>Librer√≠a UI com√∫n</li>
                    <li>CSS Modules / aislamiento</li>
                    <li>Pol√≠tica clara de estilos globales</li>
                </ul>

                <p>Sin esto ‚Üí cada microfrontend parece un sitio distinto.</p>

                <h3>üì¶ 4. Dependencias Compartidas</h3>

                <p><strong>Ejemplo cl√°sico:</strong></p>

                <p>Dos versiones de React cargadas.</p>

                <p><strong>Soluci√≥n con Module Federation:</strong></p>

                <ul>
                    <li>React como singleton compartido</li>
                    <li>Pol√≠tica de versiones estricta</li>
                </ul>

                <h3>üí• 5. Fallos Distribuidos</h3>

                <p><strong>¬øQu√© pasa si Search falla?</strong></p>

                <p><strong>Soluciones:</strong></p>

                <ul>
                    <li>Error boundaries por microfrontend</li>
                    <li>Fallback UI</li>
                    <li>Timeout controlado</li>
                    <li>Circuit breaker</li>
                </ul>

                <h3>üß™ 6. Testing</h3>

                <p><strong>Estrategia madura:</strong></p>

                <ul>
                    <li>Unit tests por MFE</li>
                    <li>Contract tests Shell ‚Üî MFE</li>
                    <li>Pocos E2E cr√≠ticos</li>
                </ul>

                <h3>üöÄ 7. SSR + Microfrontends</h3>

                <p>Muy complejo.</p>

                <p>Necesitas:</p>

                <ul>
                    <li>Coordinaci√≥n de data fetching</li>
                    <li>Streaming</li>
                    <li>Control de hidrataci√≥n</li>
                </ul>

                <p>Solo recomendado si tienes equipo senior fuerte.</p>

                <h2>9Ô∏è‚É£ Ventajas Reales</h2>

                <p>No son t√©cnicas principalmente.</p>

                <p><strong>Son organizativas:</strong></p>

                <ul>
                    <li>Escalar equipos</li>
                    <li>Autonom√≠a</li>
                    <li>Deploy independiente</li>
                    <li>Paralelizaci√≥n del trabajo</li>
                </ul>

                <h2>üîü Coste Real</h2>

                <p>Complejidad:</p>

                <ul>
                    <li>Infraestructura</li>
                    <li>Versionado</li>
                    <li>Coordinaci√≥n</li>
                    <li>Performance</li>
                    <li>Observabilidad</li>
                </ul>

                <p><strong>Microfrontends no simplifican el sistema.</strong></p>

                <p><strong>Lo hacen m√°s complejo.</strong></p>

                <p>Pero permiten escalar organizaciones.</p>

                <h2>1Ô∏è‚É£1Ô∏è‚É£ ¬øCu√°ndo Tiene Sentido?</h2>

                <h3>S√≠:</h3>

                <ul>
                    <li>50+ desarrolladores frontend</li>
                    <li>Dominios bien definidos</li>
                    <li>Necesidad real de deploy independiente</li>
                    <li>Organizaci√≥n madura</li>
                </ul>

                <h3>No:</h3>

                <ul>
                    <li>Startup peque√±a</li>
                    <li>Producto en constante cambio</li>
                    <li>Sin design system</li>
                    <li>Sin equipo plataforma</li>
                </ul>

                <h2>1Ô∏è‚É£2Ô∏è‚É£ Regla Senior</h2>

                <p>Antes de hacer microfrontends, preg√∫ntate:</p>

                <ul>
                    <li>¬øMi frontend est√° bien modularizado?</li>
                    <li>¬øTengo arquitectura por dominio?</li>
                    <li>¬øTengo design system s√≥lido?</li>
                    <li>¬øTengo CI/CD maduro?</li>
                    <li>¬øTengo BFFs claros?</li>
                </ul>

                <p>Si no puedes responder s√≠ a la mayor√≠a‚Ä¶</p>

                <p><strong>No necesitas microfrontends.<br>
                Necesitas mejor arquitectura interna primero.</strong></p>

                <h2>1Ô∏è‚É£3Ô∏è‚É£ Camino de Evoluci√≥n</h2>

                <pre><code>Monolito backend + frontend
    ‚Üì
Microservicios
    ‚Üì
SPA gigante
    ‚Üì
Microfrontends + microservicios
    ‚Üì
Sistema completamente distribuido</code></pre>

                <p>Es una arquitectura poderosa.<br>
                Pero es un monstruo.</p>

                <p><strong>Solo √∫sala cuando el problema sea organizativo y de escala real.</strong></p>

                <h2>1Ô∏è‚É£4Ô∏è‚É£ C√≥mo Explicarlo en una Entrevista</h2>

                <p><strong>"Microfrontends aplican el principio de microservicios al frontend. Permiten que equipos trabajen de forma independiente en dominios espec√≠ficos con deploy separado. La principal ventaja es organizativa, no t√©cnica. Introducen mucha complejidad en estado compartido, routing, consistencia visual y dependencias, por lo que solo tiene sentido en organizaciones grandes con madurez t√©cnica."</strong></p>

                <h2>üéØ Puntos Clave</h2>

                <ul>
                    <li>‚úî Microfrontends = Herramienta organizacional, no solo t√©cnica</li>
                    <li>‚úî Dividir por dominio de negocio, no por layout de UI</li>
                    <li>‚úî El Shell es la plataforma, no solo un contenedor</li>
                    <li>‚úî Runtime composition es m√°s flexible pero m√°s compleja</li>
                    <li>‚úî Estado compartido debe ser m√≠nimo y bien definido</li>
                    <li>‚úî Consistencia visual requiere design tokens y pol√≠ticas</li>
                    <li>‚úî Testear por contrato, no solo E2E</li>
                    <li>‚úî SSR + microfrontends es avanzado y riesgoso</li>
                    <li>‚úî No uses a menos que tengas 50+ devs frontend</li>
                    <li>‚úî Un monolito bien dise√±ado supera un sistema microfrontend ca√≥tico</li>
                </ul>

                <h2>üìö Recursos</h2>

                <ul>
                    <li><a href="https://chatgpt.com/g/g-p-69925f6597e88191b8bcb93447c5bb78-dragos/c/699886b9-6990-838c-bfef-4a7295dcd8cb" target="_blank">Microfrontends - Dragos</a></li>
                </ul>

                <div class="navigation-buttons">
                    <button class="btn btn-secondary" onclick="window.location.href='../index.html'">‚Üê Volver Atr√°s</button>
                    <button class="btn btn-primary" onclick="window.location.href='../../index.html'">Volver al Inicio ‚Üí</button>
                </div>
            </section>
        </main>
    </div>

    <script src="../../assets/js/app.js"></script>
</body>
</html>
