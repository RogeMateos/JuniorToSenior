<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ORMs - Object Relational Mapper | FullStack</title>
    <link rel="stylesheet" href="../../../assets/css/styles.css">
</head>
<body>
    <div class="container">
        <main class="main-content">
            <section id="section-orms">
                <h1>2.4 ORMs: Object Relational Mapper</h1>
                <p><strong>Un ORM no reemplaza SQL. Un ORM estandariza el acceso a datos y un buen desarrollador sabe cu√°ndo confiar en √©l y cu√°ndo bajar al nivel SQL.</strong></p>

                <h2>0Ô∏è‚É£ El Problema Que Queremos Resolver</h2>

                <p>Imagina que est√°s construyendo una API en Node.js con una base de datos SQL.</p>

                <p><strong>Sin ORM tendr√≠as algo as√≠:</strong></p>

                <pre><code>await db.query(
  "INSERT INTO movies (title, year) VALUES ($1, $2)",
  ["Inception", 2010]
);</code></pre>

                <p>Eso est√° bien‚Ä¶ hasta que:</p>
                <ul>
                    <li>Tienes 30 tablas</li>
                    <li>200 queries</li>
                    <li>Cambias el esquema</li>
                    <li>Necesitas joins complejos</li>
                    <li>Alguien comete un error en una query</li>
                </ul>

                <p><strong>Aqu√≠ es donde entra el ORM.</strong></p>

                <h2>1Ô∏è‚É£ ¬øQu√© es un ORM Realmente?</h2>

                <p><strong>ORM = Object-Relational Mapper</strong></p>

                <p>Es una capa que:</p>
                <ul>
                    <li>Traduce clases y objetos a tablas SQL</li>
                    <li>Traduce m√©todos (find, save, delete) a queries SQL</li>
                    <li>Gestiona el esquema mediante migrations</li>
                </ul>

                <h3>Mapeo Mental Clave</h3>

                <table class="cheat-sheet-table">
                    <thead>
                        <tr>
                            <th>C√≥digo (Objeto)</th>
                            <th>Base de Datos</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>Clase</td>
                            <td>Tabla</td>
                        </tr>
                        <tr>
                            <td>Propiedad</td>
                            <td>Columna</td>
                        </tr>
                        <tr>
                            <td>Instancia</td>
                            <td>Fila</td>
                        </tr>
                    </tbody>
                </table>

                <h2>2Ô∏è‚É£ Ejemplo Real con TypeORM (Data Mapper Pattern)</h2>

                <h3>2.1 Definimos una Entidad</h3>

                <pre><code>import { Entity, PrimaryGeneratedColumn, Column, CreateDateColumn } from "typeorm";

@Entity("movies")
export class Movie {
  @PrimaryGeneratedColumn()
  id!: number;

  @Column({ type: "varchar", length: 200 })
  title!: string;

  @Column({ type: "int", nullable: true })
  year?: number;

  @CreateDateColumn()
  createdAt!: Date;
}</code></pre>

                <p><strong>üëâ Esto generar√° una tabla movies con esas columnas.</strong></p>

                <h3>2.2 CRUD usando Repository</h3>

                <pre><code>import { AppDataSource } from "./data-source";
import { Movie } from "./entities/Movie";

const repo = AppDataSource.getRepository(Movie);

// CREATE
await repo.save({ title: "Inception", year: 2010 });

// READ
const movies = await repo.find({ where: { year: 2010 } });

// UPDATE
await repo.update({ title: "Inception" }, { year: 2011 });

// DELETE
await repo.delete({ title: "Inception" });</code></pre>

                <p><strong>¬øQu√© pasa por debajo?</strong></p>

                <p>El ORM traduce esto a:</p>

                <pre><code>INSERT INTO movies (title, year) VALUES ('Inception', 2010);</code></pre>

                <p><strong>Pero:</strong></p>
                <ul>
                    <li>‚úÖ Parametrizado</li>
                    <li>‚úÖ Seguro contra SQL injection</li>
                    <li>‚úÖ Tipado con TypeScript</li>
                </ul>

                <h2>3Ô∏è‚É£ Migrations ‚Äì Versionando el Esquema</h2>

                <p><strong>En proyectos reales, el esquema cambia.</strong></p>

                <p><strong>Ejemplo:</strong> A√±adimos columna rating</p>

                <p>No modificamos la base de datos manualmente. Generamos una migration.</p>

                <pre><code>typeorm migration:generate -n AddRatingToMovie</code></pre>

                <p>Se genera algo as√≠:</p>

                <pre><code>await queryRunner.addColumn(
  "movies",
  new TableColumn({
    name: "rating",
    type: "int",
    isNullable: true,
  })
);</code></pre>

                <p>Luego ejecutamos:</p>

                <pre><code>typeorm migration:run</code></pre>

                <p><strong>¬øPor qu√© esto es profesional?</strong></p>
                <ul>
                    <li>‚úÖ Version√° cambios</li>
                    <li>‚úÖ Permite rollback</li>
                    <li>‚úÖ Funciona igual en dev, staging y producci√≥n</li>
                    <li>‚úÖ Evita "en mi m√°quina funciona"</li>
                </ul>

                <h2>4Ô∏è‚É£ Active Record vs Data Mapper</h2>

                <p><strong>Hay dos patrones principales en ORM.</strong></p>

                <h3>üîπ Active Record</h3>

                <p>El modelo tiene m√©todos propios.</p>

                <pre><code>const movie = new Movie();
movie.title = "Inception";
await movie.save();</code></pre>

                <p><strong>Pros:</strong></p>
                <ul>
                    <li>‚úÖ Muy simple</li>
                    <li>‚úÖ Ideal para proyectos peque√±os</li>
                </ul>

                <p><strong>Contras:</strong></p>
                <ul>
                    <li>‚ùå Mezcla l√≥gica de negocio y persistencia</li>
                    <li>‚ùå Escala peor en proyectos grandes</li>
                </ul>

                <h3>üîπ Data Mapper (Repository Pattern)</h3>

                <p>Separas entidad y persistencia.</p>

                <pre><code>const repo = dataSource.getRepository(Movie);
await repo.save(movie);</code></pre>

                <p><strong>Pros:</strong></p>
                <ul>
                    <li>‚úÖ Arquitectura m√°s limpia</li>
                    <li>‚úÖ M√°s testable</li>
                    <li>‚úÖ Escala mejor</li>
                </ul>

                <p><strong>Contras:</strong></p>
                <ul>
                    <li>‚ùå Un poco m√°s de boilerplate</li>
                </ul>

                <p><strong>üëâ En aplicaciones profesionales suele preferirse Data Mapper.</strong></p>

                <h2>5Ô∏è‚É£ Relaciones Entre Entidades</h2>

                <p><strong>Ejemplo: Una pel√≠cula tiene muchos comentarios.</strong></p>

                <pre><code>@Entity()
export class Comment {
  @PrimaryGeneratedColumn()
  id!: number;

  @Column()
  text!: string;

  @ManyToOne(() => Movie, movie => movie.comments)
  movie!: Movie;
}

@Entity()
export class Movie {
  @OneToMany(() => Comment, comment => comment.movie)
  comments!: Comment[];
}</code></pre>

                <p>Ahora puedes hacer queries relacionales naturales.</p>

                <h2>6Ô∏è‚É£ Problemas Reales Con ORMs (Esto Te Hace Senior)</h2>

                <p><strong>Aqu√≠ es donde muchos juniors fallan.</strong></p>

                <h3>6.1 El Problema N+1</h3>

                <p><strong>C√≥digo:</strong></p>

                <pre><code>const movies = await repo.find();
for (const movie of movies) {
  console.log(movie.comments);
}</code></pre>

                <p><strong>Esto puede generar:</strong></p>
                <ul>
                    <li>1 query para movies</li>
                    <li>1 query por cada movie para comments</li>
                </ul>

                <p><strong>Resultado: üëâ 1 + N queries (ineficiente)</strong></p>

                <p><strong>Soluci√≥n:</strong></p>

                <pre><code>// Eager loading
const movies = await repo.find({
  relations: ["comments"]
});

// O con Query Builder
const movies = await repo
  .createQueryBuilder("movie")
  .leftJoinAndSelect("movie.comments", "comment")
  .getMany();</code></pre>

                <h3>6.2 Performance</h3>

                <p><strong>Los ORMs pueden generar queries complejas y poco optimizadas.</strong></p>

                <p><strong>Reglas de senior:</strong></p>
                <ul>
                    <li>‚úÖ Activa logging de queries</li>
                    <li>‚úÖ Analiza el plan de ejecuci√≥n</li>
                    <li>‚úÖ Usa √≠ndices</li>
                    <li>‚úÖ Usa SQL manual cuando sea necesario</li>
                </ul>

                <h3>6.3 Transacciones</h3>

                <p><strong>Ejemplo:</strong></p>
                <ul>
                    <li>Crear Order</li>
                    <li>Crear OrderItems</li>
                    <li>Reducir stock</li>
                </ul>

                <p><strong>Todo debe ir dentro de una transacci√≥n:</strong></p>

                <pre><code>await dataSource.transaction(async manager => {
  await manager.save(order);
  await manager.save(orderItems);
  await manager.update(Product, { id: productId }, { stock });
});

// Si algo falla:
// üëâ rollback autom√°tico</code></pre>

                <h2>7Ô∏è‚É£ Ventajas Reales De Usar ORM</h2>

                <ul>
                    <li>‚úÖ Productividad</li>
                    <li>‚úÖ Seguridad (queries parametrizadas)</li>
                    <li>‚úÖ Tipado fuerte con TypeScript</li>
                    <li>‚úÖ Migrations</li>
                    <li>‚úÖ Testing m√°s sencillo</li>
                    <li>‚úÖ Menos errores humanos</li>
                </ul>

                <h2>8Ô∏è‚É£ Desventajas Reales</h2>

                <ul>
                    <li>‚ùå Puede ocultar c√≥mo funciona SQL</li>
                    <li>‚ùå N+1 problem</li>
                    <li>‚ùå Queries sub√≥ptimas</li>
                    <li>‚ùå Curva de aprendizaje</li>
                    <li>‚ùå A veces necesitas raw SQL</li>
                </ul>

                <h2>9Ô∏è‚É£ ¬øCu√°ndo NO Usar ORM?</h2>

                <ul>
                    <li>‚ùå Queries extremadamente optimizadas</li>
                    <li>‚ùå Reporting complejo</li>
                    <li>‚ùå Microservicios muy simples</li>
                    <li>‚ùå Alta carga con queries muy espec√≠ficas</li>
                </ul>

                <p><strong>En esos casos: üëâ Query builder o SQL directo</strong></p>

                <h2>üîü Arquitectura Recomendada En Backend Moderno</h2>

                <p><strong>En un backend profesional:</strong></p>

                <pre><code>Controller ‚Üí Service ‚Üí Repository (ORM) ‚Üí Database</code></pre>

                <ul>
                    <li><strong>Controller:</strong> HTTP</li>
                    <li><strong>Service:</strong> l√≥gica de negocio</li>
                    <li><strong>Repository:</strong> persistencia</li>
                    <li><strong>DB:</strong> almacenamiento</li>
                </ul>

                <p><strong>Nunca mezcles todo en el modelo.</strong></p>

                <h2>1Ô∏è‚É£1Ô∏è‚É£ Preguntas T√≠picas De Entrevista</h2>

                <h3>¬øQu√© es un ORM?</h3>

                <p>Una capa que mapea objetos del lenguaje a tablas SQL y traduce operaciones a queries parametrizadas.</p>

                <h3>Pros y Contras</h3>

                <p>Productividad y seguridad vs p√©rdida de control y posibles problemas de performance.</p>

                <h3>Active Record vs Data Mapper</h3>

                <p>Active Record mezcla datos y persistencia. Data Mapper separa responsabilidades y escala mejor.</p>

                <h3>¬øNecesito Saber SQL?</h3>

                <p><strong>S√≠. Siempre.</strong></p>

                <h2>1Ô∏è‚É£2Ô∏è‚É£ Checklist Senior</h2>

                <ul>
                    <li>‚úÖ Separas entidades (modelos) de repositorios</li>
                    <li>‚úÖ Usas Data Mapper, no Active Record</li>
                    <li>‚úÖ Evitas N+1 queries con eager loading</li>
                    <li>‚úÖ Generas migrations, no cambios manuales</li>
                    <li>‚úÖ Entiendes cu√°ndo NO usar ORM</li>
                    <li>‚úÖ Sabes escribir SQL cuando lo necesitas</li>
                    <li>‚úÖ Monitorizas performance con EXPLAIN ANALYZE</li>
                    <li>‚úÖ Usas transacciones para operaciones cr√≠ticas</li>
                    <li>‚úÖ Testeas repositorios sin base de datos real</li>
                    <li>‚úÖ Documentas relaciones complejas</li>
                </ul>

                <h2>1Ô∏è‚É£3Ô∏è‚É£ Una Frase Para Recordar</h2>

                <p><strong>"Un ORM te ahorra 80% del trabajo. El 20% restante es aprender cu√°ndo NO confiar en √©l y escribir SQL puro."</strong></p>

                <div class="navigation-buttons">
                    <button class="btn btn-secondary" onclick="window.location.href='07-mvc-architecture.html'">‚Üê Anterior</button>
                    <button class="btn btn-primary" onclick="window.location.href='08-1-migrations.html'">Siguiente: Migrations ‚Üí</button>
                </div>
            </section>
        </main>
    </div>

    <script src="../../../assets/js/app.js"></script>
</body>
</html>
