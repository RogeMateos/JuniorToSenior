<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SQL Injection | FullStack</title>
    <link rel="stylesheet" href="../../../assets/css/styles.css">
</head>
<body>
    <div class="container">
        <aside id="sidebar" class="sidebar"></aside>
        <main class="main-content">
            <section id="section-sql-injection">
                <h1>üîì 5.1 Security: SQL Injection (From Zero to Interview Level)</h1>
                <p><strong>C√≥mo Identificar, Prevenir y Defenderse Contra el Ataque M√°s Cl√°sico</strong></p>

                <h2>0Ô∏è‚É£ Contexto: ¬øPor Qu√© Debes Entender Esto?</h2>

                <p>Como fullstack no necesitas ser experto en ciberseguridad, pero s√≠ debes conocer las vulnerabilidades m√°s comunes.</p>

                <p>SQL Injection es una de las m√°s cl√°sicas y sigue apareciendo cuando:</p>

                <ul>
                    <li>Se construyen queries con string interpolation</li>
                    <li>Se usa SQL din√°mico sin cuidado</li>
                    <li>Se escriben raw queries en ORMs</li>
                    <li>Hay c√≥digo legacy</li>
                </ul>

                <p><strong>Est√° dentro del OWASP Top 10 ‚Äì Injection.</strong></p>

                <h2>1Ô∏è‚É£ Qu√© Es SQL Injection (Mental Model)</h2>

                <p>SQL Injection ocurre cuando:</p>

                <p><strong>El input del usuario se convierte en parte del c√≥digo SQL ejecutado.</strong></p>

                <p>Eso pasa cuando hacemos algo as√≠:</p>

                <pre><code>const sql = `SELECT * FROM users WHERE username = '${username}'`;</code></pre>

                <p>Aqu√≠ estamos mezclando c√≥digo SQL + input del usuario.</p>

                <p>Si el usuario mete algo inesperado‚Ä¶ el motor SQL lo interpreta como c√≥digo.</p>

                <h2>2Ô∏è‚É£ Ejemplo Vulnerable Paso a Paso</h2>

                <p><strong>Supongamos este endpoint:</strong></p>

                <pre><code>app.get("/user", async (req, res) => {
  const username = req.query.username;

  const sql = `SELECT id, username FROM users WHERE username = '${username}'`;

  const result = await client.query(sql);
  res.json(result.rows);
});</code></pre>

                <h3>üîé Caso Normal</h3>

                <p>Si llamamos:</p>

                <pre><code>/user?username=bob</code></pre>

                <p>Se ejecuta:</p>

                <pre><code>SELECT id, username FROM users WHERE username = 'bob';</code></pre>

                <p><strong>Todo bien.</strong></p>

                <h2>3Ô∏è‚É£ Ataque 1: Bypass Simple (OR 1=1)</h2>

                <p>Ahora el atacante env√≠a:</p>

                <pre><code>/user?username=bob' OR '1'='1</code></pre>

                <p>La query generada ser√≠a:</p>

                <pre><code>SELECT id, username FROM users
WHERE username = 'bob' OR '1'='1';</code></pre>

                <p><strong>üëâ '1'='1' siempre es verdadero.</strong></p>

                <p><strong>Resultado: devuelve todos los usuarios.</strong></p>

                <h3>‚ö†Ô∏è Impacto:</h3>

                <ul>
                    <li>Exposici√≥n de datos</li>
                    <li>Enumeraci√≥n de usuarios</li>
                </ul>

                <h2>4Ô∏è‚É£ Ataque 2: Destrucci√≥n (DROP TABLE)</h2>

                <p>Si la configuraci√≥n permite m√∫ltiples sentencias:</p>

                <p><strong>Input atacante:</strong></p>

                <pre><code>bob'; DROP TABLE users; --</code></pre>

                <p><strong>Query resultante:</strong></p>

                <pre><code>SELECT id FROM users WHERE username = 'bob';
DROP TABLE users; --';</code></pre>

                <p>Si el usuario DB tiene permisos‚Ä¶ üí• tabla eliminada.</p>

                <h3>‚ö†Ô∏è Impacto:</h3>

                <ul>
                    <li>P√©rdida de datos</li>
                    <li>Servicio ca√≠do</li>
                    <li>Problemas legales</li>
                </ul>

                <h2>5Ô∏è‚É£ ¬øPor Qu√© Ocurre Esto?</h2>

                <p>Porque SQL no sabe qu√© parte es "dato" y qu√© parte es "c√≥digo".</p>

                <p>Cuando concatenas strings:</p>

                <pre><code>`... '${username}'`</code></pre>

                <p>Todo se convierte en un √∫nico string que el parser SQL interpreta.</p>

                <h2>6Ô∏è‚É£ La Soluci√≥n Correcta: Queries Parametrizadas</h2>

                <p><strong>Nunca concatenes input del usuario.</strong></p>

                <p><strong>Haz esto:</strong></p>

                <pre><code>app.get("/user", async (req, res) => {
  const username = req.query.username;

  const sql = `SELECT id, username FROM users WHERE username = $1`;

  const result = await client.query(sql, [username]);

  res.json(result.rows);
});</code></pre>

                <h3>üîé ¬øQu√© Cambia?</h3>

                <ul>
                    <li><code>$1</code> es un placeholder</li>
                    <li><code>[username]</code> se env√≠a como valor separado</li>
                    <li>PostgreSQL trata el input como dato literal, no como c√≥digo</li>
                </ul>

                <p>Aunque el atacante mande:</p>

                <pre><code>bob'; DROP TABLE users; --</code></pre>

                <p>Se interpreta como texto, no como SQL ejecutable.</p>

                <h2>7Ô∏è‚É£ Qu√© Pasa Internamente (Importante Para Entrevista)</h2>

                <p>El motor:</p>

                <ul>
                    <li>Compila el statement</li>
                    <li>Despu√©s inserta los par√°metros como valores</li>
                    <li>No vuelve a parsear como SQL</li>
                </ul>

                <p><strong>üëâ Separaci√≥n estricta entre c√≥digo y datos.</strong></p>

                <h2>8Ô∏è‚É£ Caso Especial Peligroso: ORDER BY Din√°mico</h2>

                <p>Este es un error muy com√∫n incluso en proyectos serios.</p>

                <pre><code>const sort = req.query.sort;
const sql = `SELECT * FROM users ORDER BY ${sort}`;</code></pre>

                <p>Aqu√≠ no puedes usar $1 para columnas.</p>

                <p>Si el usuario manda:</p>

                <pre><code>username; DROP TABLE users;</code></pre>

                <p>üí• Problema.</p>

                <h3>‚úÖ Soluci√≥n: Whitelist</h3>

                <pre><code>const allowedColumns = ["username", "created_at"];

const sort = allowedColumns.includes(req.query.sort)
  ? req.query.sort
  : "created_at";

const sql = `SELECT * FROM users ORDER BY ${sort}`;</code></pre>

                <p><strong>Nunca interpolar columnas sin whitelist.</strong></p>

                <h2>9Ô∏è‚É£ ORM: ¬øMe Protege?</h2>

                <p><strong>S√≠‚Ä¶ pero con matices.</strong></p>

                <p>TypeORM, Prisma, Sequelize parametrizan por defecto.</p>

                <p><strong>‚ö†Ô∏è Pero si haces raw queries as√≠:</strong></p>

                <pre><code>await prisma.$queryRawUnsafe(
  `SELECT * FROM users WHERE username = '${username}'`
);</code></pre>

                <p>Vuelves a ser vulnerable.</p>

                <p><strong>üëâ ORM ayuda, pero no es magia.</strong></p>

                <h2>üîü Defensa En Profundidad (Nivel Senior)</h2>

                <p>Adem√°s de parametrizar:</p>

                <h3>‚úî Principio De M√≠nimo Privilegio</h3>

                <p>El usuario de base de datos:</p>

                <ul>
                    <li>‚ùå No deber√≠a poder hacer DROP</li>
                    <li>‚ùå No deber√≠a ser superuser</li>
                    <li>‚úî Solo SELECT/INSERT/UPDATE necesarios</li>
                </ul>

                <h3>‚úî Validaci√≥n De Input</h3>

                <p>No como defensa principal, pero s√≠ como refuerzo:</p>

                <pre><code>if (!/^[a-zA-Z0-9_]{3,20}$/.test(username)) {
  return res.status(400).send("Invalid username");
}</code></pre>

                <h3>‚úî No Exponer Errores SQL Al Cliente</h3>

                <p><strong>‚ùå Nunca devolver:</strong></p>

                <pre><code>{
  "error": "syntax error near DROP"
}</code></pre>

                <p>Eso ayuda al atacante.</p>

                <h3>‚úî Logging y Monitoring</h3>

                <p>Registrar patrones sospechosos:</p>

                <ul>
                    <li>' OR</li>
                    <li>--</li>
                    <li>;</li>
                    <li>UNION</li>
                </ul>

                <p>No bloquea por s√≠ solo, pero ayuda a detectar ataques.</p>

                <h2>1Ô∏è‚É£1Ô∏è‚É£ Checklist Final Anti-SQL Injection</h2>

                <ul>
                    <li>‚úÖ Nunca usar string concatenation con input</li>
                    <li>‚úÖ Usar par√°metros ($1, ?, etc.)</li>
                    <li>‚úÖ Whitelist en SQL din√°mico</li>
                    <li>‚úÖ DB con permisos m√≠nimos</li>
                    <li>‚úÖ No exponer errores SQL</li>
                    <li>‚úÖ Validar input por reglas de negocio</li>
                    <li>‚úÖ Revisar raw queries en ORMs</li>
                </ul>

                <h2>1Ô∏è‚É£2Ô∏è‚É£ Preguntas T√≠picas De Entrevista (Respuestas Cortas)</h2>

                <h3>‚ùì ¬øQu√© es SQL Injection?</h3>

                <p>Es una vulnerabilidad donde el input del usuario se interpreta como parte del c√≥digo SQL ejecutado.</p>

                <h3>‚ùì ¬øC√≥mo se previene?</h3>

                <p>Con queries parametrizadas/prepared statements.</p>

                <h3>‚ùì ¬øPor qu√© funciona la parametrizaci√≥n?</h3>

                <p>Porque separa c√≥digo SQL de datos, evitando que el input se reinterprete como SQL.</p>

                <h3>‚ùì ¬øUn ORM elimina el riesgo?</h3>

                <p>Reduce el riesgo porque parametriza, pero raw queries inseguras pueden reintroducirlo.</p>

                <h3>‚ùì ¬øQu√© har√≠as adem√°s de parametrizar?</h3>

                <p>Least privilege en la DB, no exponer errores y aplicar validaci√≥n.</p>

                <h2>1Ô∏è‚É£3Ô∏è‚É£ Mental Model Final (Senior)</h2>

                <ul>
                    <li>SQL Injection no es solo "no concatenar strings".</li>
                    <li>Es entender que seguridad no es una funci√≥n, es una arquitectura.</li>
                    <li>Parametrizaci√≥n + permisos m√≠nimos + validaci√≥n + buenas pr√°cticas = aplicaci√≥n robusta.</li>
                    <li>El atacante siempre busca la frontera entre c√≥digo y datos.</li>
                    <li>Tu trabajo es hacer esa frontera impenetrable.</li>
                </ul>

                <h2>1Ô∏è‚É£4Ô∏è‚É£ Una Frase Para Recordar</h2>

                <p><strong>\"SQL Injection ocurre cuando confundes datos con c√≥digo. Parametrizaci√≥n separa ambos. Sin esta separaci√≥n, un atacante puede inyectar comandos destructivos.\"</strong></p>

                <h2>üìö Referencias y Recursos</h2>

                <p><strong>Para profundizar m√°s:</strong></p>

                <ul>
                    <li><a href="https://chatgpt.com/g/g-p-69925f6597e88191b8bcb93447c5bb78-dragos/c/6994ecb0-705c-8395-999d-7fb6a2acdf0e" target="_blank">Dragos - SQL Injection: Defense in Depth Strategies</a></li>
                </ul>

                <div class="navigation-buttons">
                    <button class="btn btn-secondary" onclick="window.location.href='10-authentication-oauth.html'">‚Üê Anterior</button>
                    <button class="btn btn-primary" onclick="window.location.href='12-xss-attacks.html'">Siguiente: XSS Attacks ‚Üí</button>
                </div>
            </section>
        </main>
    </div>

    <script src="../../../assets/js/app.js"></script>
</body>
</html>
