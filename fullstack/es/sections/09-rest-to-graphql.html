<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>De REST a GraphQL | FullStack</title>
    <link rel="stylesheet" href="../../../assets/css/styles.css">
</head>
<body>
    <div class="container">
        <aside id="sidebar" class="sidebar"></aside>
        <main class="main-content">
            <section id="section-graphql">
                <h1>3.0 From REST to GraphQL</h1>
                <p><strong>Entendiendo el porqu√©, no solo el qu√© ‚Äì C√≥mo y cu√°ndo evolucionar tus APIs</strong></p>

                <h2>0Ô∏è‚É£ Contexto: C√≥mo Llegamos Aqu√≠</h2>

                <p>Durante a√±os, REST fue (y sigue siendo) la forma est√°ndar de exponer APIs:</p>

                <pre><code>GET /movies
GET /movies/:id
GET /movies/:id/reviews
POST /movies</code></pre>

                <p><strong>Modelo mental REST:</strong></p>
                <ul>
                    <li>Cada URL representa un recurso</li>
                    <li>El servidor decide la forma de los datos</li>
                    <li>El cliente solo elige qu√© endpoint llamar</li>
                </ul>

                <p><strong>Esto funciona muy bien cuando:</strong></p>
                <ul>
                    <li>El dominio es simple</li>
                    <li>Los datos no est√°n muy anidados</li>
                    <li>Hay pocos tipos de cliente</li>
                </ul>

                <p><strong>Pero cuando empiezan a crecer los clientes (web + m√≥vil + tablet + smartwatch‚Ä¶) aparecen problemas reales.</strong></p>

                <h2>1Ô∏è‚É£ Los Dos Problemas Cl√°sicos De REST</h2>

                <h3>üî¥ 1. Overfetching</h3>

                <p><strong>Recibes m√°s datos de los que necesitas.</strong></p>

                <p><strong>Ejemplo:</strong></p>

                <pre><code>GET /movies</code></pre>

                <p><strong>Respuesta:</strong></p>

                <pre><code>{
  "id": 1,
  "title": "Inception",
  "overview": "...",
  "revenue": 800000000,
  "spokenLanguages": [...],
  "productionCompanies": [...]
}</code></pre>

                <p><strong>Pero en tu vista Home solo quer√≠as:</strong></p>

                <pre><code>{
  "id": 1,
  "title": "Inception"
}</code></pre>

                <p><strong>‚ö†Ô∏è Problemas:</strong></p>
                <ul>
                    <li>M√°s bytes</li>
                    <li>M√°s consumo de red</li>
                    <li>Peor rendimiento en m√≥vil</li>
                    <li>Trabajo innecesario en el cliente</li>
                </ul>

                <h3>üî¥ 2. Underfetching</h3>

                <p><strong>Necesitas m√∫ltiples requests para pintar una sola vista.</strong></p>

                <p><strong>Ejemplo vista detalle:</strong></p>

                <pre><code>GET /movies/1
GET /movies/1/reviews
GET /reviews/10
GET /reviews/11
...</code></pre>

                <p><strong>Ahora tienes:</strong></p>
                <ul>
                    <li>5‚Äì10 requests</li>
                    <li>M√°s latencia</li>
                    <li>M√°s puntos de fallo</li>
                    <li>M√°s complejidad en frontend</li>
                </ul>

                <h2>2Ô∏è‚É£ ¬øPodr√≠a REST Solucionarlo?</h2>

                <p><strong>S√≠, pero con costes.</strong></p>

                <p>Puedes:</p>
                <ul>
                    <li>A√±adir query params (<code>?fields=id,title</code>)</li>
                    <li>A√±adir <code>?include=reviews</code></li>
                    <li>Crear endpoints espec√≠ficos por vista</li>
                    <li>Crear un BFF (Backend for Frontend)</li>
                </ul>

                <p><strong>Pero esto empieza a generar:</strong></p>
                <ul>
                    <li>Endpoints acoplados a vistas</li>
                    <li>Duplicaci√≥n de l√≥gica</li>
                    <li>APIs dif√≠ciles de mantener</li>
                </ul>

                <p><strong>Aqu√≠ es donde nace GraphQL.</strong></p>

                <h2>3Ô∏è‚É£ ¬øQu√© Cambia Con GraphQL?</h2>

                <p><strong>GraphQL cambia la pregunta de:</strong></p>

                <p>"¬øQu√© recurso quieres?"</p>

                <p><strong>a</strong></p>

                <p>"¬øQu√© forma de datos necesitas?"</p>

                <p><strong>En vez de m√∫ltiples endpoints:</strong></p>

                <pre><code>/movies
/movies/:id
/movies/:id/reviews</code></pre>

                <p><strong>Tienes uno solo:</strong></p>

                <pre><code>POST /graphql</code></pre>

                <p><strong>Y el cliente define la forma exacta de la respuesta.</strong></p>

                <h2>4Ô∏è‚É£ Ejemplo Pr√°ctico Comparado</h2>

                <h3>üé¨ Vista Home (solo t√≠tulo)</h3>

                <p><strong>REST:</strong></p>

                <pre><code>GET /movies</code></pre>

                <p>Recibes todo.</p>

                <p><strong>GraphQL:</strong></p>

                <pre><code>query {
  movies {
    id
    title
  }
}</code></pre>

                <p>Recibes exactamente eso:</p>

                <pre><code>{
  "data": {
    "movies": [
      { "id": 1, "title": "Inception" }
    ]
  }
}</code></pre>

                <h3>üé¨ Vista Detalle (datos anidados)</h3>

                <pre><code>query MovieDetail($id: ID!) {
  movie(id: $id) {
    id
    title
    releaseDate
    spokenLanguages {
      id
      iso
    }
    reviews {
      id
      rating
      comment
    }
  }
}</code></pre>

                <p><strong>Todo en una sola request.</strong></p>

                <h2>5Ô∏è‚É£ Modelo Mental Interno De GraphQL</h2>

                <p><strong>Un junior debe entender esto:</strong></p>

                <p>GraphQL tiene:</p>
                <ul>
                    <li>üß± Schema (tipado fuerte)</li>
                    <li>üå≥ Execution tree</li>
                    <li>üîß Resolvers</li>
                </ul>

                <p><strong>Flujo simplificado:</strong></p>

                <pre><code>Cliente env√≠a Query
        ‚Üì
GraphQL la convierte en un √°rbol
        ‚Üì
Cada campo se resuelve con un resolver
        ‚Üì
Se construye un √∫nico JSON final</code></pre>

                <p><strong>Cada campo puede tener su propia funci√≥n para resolver datos.</strong></p>

                <h2>6Ô∏è‚É£ Ventajas Reales De GraphQL</h2>

                <ul>
                    <li>‚úÖ El cliente controla la forma de datos</li>
                    <li>‚úÖ Reduce roundtrips</li>
                    <li>‚úÖ Es tipado (como TypeScript para APIs)</li>
                    <li>‚úÖ Excelente tooling (introspecci√≥n, playground)</li>
                    <li>‚úÖ Ideal para UIs complejas</li>
                </ul>

                <h2>7Ô∏è‚É£ Pero Ahora Viene La Parte Senior ‚ö†Ô∏è</h2>

                <p><strong>GraphQL NO es magia. Tiene trade-offs.</strong></p>

                <h3>‚ö†Ô∏è 1. M√°s Complejidad En Backend</h3>

                <p><strong>En REST:</strong></p>

                <pre><code>Un endpoint ‚Üí una query SQL</code></pre>

                <p><strong>En GraphQL:</strong></p>

                <pre><code>Una query ‚Üí m√∫ltiples resolvers
Posible N+1 problem</code></pre>

                <p><strong>Ejemplo del problema N+1:</strong></p>

                <pre><code>movies {
  id
  reviews {
    id
  }
}</code></pre>

                <p>Si tienes 10 pel√≠culas:</p>
                <ul>
                    <li>1 query para pel√≠culas</li>
                    <li>10 queries para reviews</li>
                </ul>

                <p><strong>Soluci√≥n:</strong></p>
                <ul>
                    <li>DataLoader</li>
                    <li>Batching</li>
                    <li>Optimizaci√≥n de resolvers</li>
                </ul>

                <h3>‚ö†Ô∏è 2. Caching Es M√°s Complejo</h3>

                <p><strong>REST:</strong></p>

                <pre><code>GET /movies/1
‚Üí Cacheable por URL</code></pre>

                <p><strong>GraphQL:</strong></p>

                <pre><code>POST /graphql
‚Üí No cacheable directamente por CDN</code></pre>

                <p><strong>Necesitas:</strong></p>
                <ul>
                    <li>Persisted queries</li>
                    <li>Client-side caching (Apollo)</li>
                    <li>Estrategias personalizadas</li>
                </ul>

                <h3>‚ö†Ô∏è 3. Seguridad</h3>

                <p><strong>El cliente puede pedir:</strong></p>

                <pre><code>movie {
  reviews {
    author {
      posts {
        comments {
          ...
}</code></pre>

                <p><strong>Query profunda ‚Üí costosa</strong></p>

                <p><strong>Necesitas:</strong></p>
                <ul>
                    <li>L√≠mites de profundidad</li>
                    <li>L√≠mites de complejidad</li>
                    <li>Rate limiting</li>
                </ul>

                <h3>‚ö†Ô∏è 4. Curva De Aprendizaje Mayor</h3>

                <ul>
                    <li>Schema design</li>
                    <li>Resolver strategy</li>
                    <li>Performance tuning</li>
                    <li>Testing diferente</li>
                </ul>

                <h2>8Ô∏è‚É£ Cu√°ndo Usar REST vs GraphQL</h2>

                <h3>‚úÖ REST Es Ideal Cuando:</h3>

                <ul>
                    <li>API simple</li>
                    <li>Dominio plano</li>
                    <li>Microservicio interno</li>
                    <li>Buen uso de HTTP caching</li>
                    <li>Integraciones externas</li>
                </ul>

                <h3>‚úÖ GraphQL Es Ideal Cuando:</h3>

                <ul>
                    <li>UI compleja</li>
                    <li>Muchos tipos de cliente</li>
                    <li>Datos muy relacionados</li>
                    <li>Varias vistas reutilizando datos de formas distintas</li>
                    <li>Mobile-first</li>
                </ul>

                <h2>9Ô∏è‚É£ Conceptos Clave Que No Debes Olvidar</h2>

                <table class="cheat-sheet-table">
                    <thead>
                        <tr>
                            <th>Concepto</th>
                            <th>Qu√© Es</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>Overfetching</strong></td>
                            <td>Recibir m√°s datos que necesitas</td>
                        </tr>
                        <tr>
                            <td><strong>Underfetching</strong></td>
                            <td>Necesitar m√∫ltiples requests</td>
                        </tr>
                        <tr>
                            <td><strong>Schema</strong></td>
                            <td>Definici√≥n tipada de tipos en GraphQL</td>
                        </tr>
                        <tr>
                            <td><strong>Resolver</strong></td>
                            <td>Funci√≥n que resuelve un campo</td>
                        </tr>
                        <tr>
                            <td><strong>N+1 Problem</strong></td>
                            <td>1 query + N queries por cada resultado</td>
                        </tr>
                        <tr>
                            <td><strong>Query vs Mutation</strong></td>
                            <td>Query = lectura, Mutation = escritura</td>
                        </tr>
                        <tr>
                            <td><strong>Caching Strategy</strong></td>
                            <td>C√≥mo cachear respuestas GraphQL</td>
                        </tr>
                        <tr>
                            <td><strong>Query Complexity</strong></td>
                            <td>L√≠mite de complejidad para prevenir abuso</td>
                        </tr>
                    </tbody>
                </table>

                <h2>üîü Conclusi√≥n (Visi√≥n Madura)</h2>

                <p><strong>GraphQL no reemplaza REST.</strong></p>

                <p><strong>GraphQL cambia qui√©n controla la forma de los datos.</strong></p>

                <p><strong>REST:</strong></p>

                <p>El servidor dise√±a la respuesta.</p>

                <p><strong>GraphQL:</strong></p>

                <p>El cliente dise√±a la respuesta.</p>

                <p><strong>Ambos son herramientas. La clave est√° en elegir seg√∫n el contexto, no por moda.</strong></p>

                <h2>1Ô∏è‚É£0Ô∏è‚É£ Casos de Uso Real: Cu√°ndo Usar GraphQL</h2>

                <p>Un ejemplo claro de d√≥nde utilizar√≠as GraphQL es en el desarrollo de una <strong>red social de gran escala</strong>, similar a Facebook, donde los retos de ingenier√≠a son masivos debido a los miles de millones de usuarios generando datos constantemente.</p>

                <p><strong>Aqu√≠ te detallo situaciones espec√≠ficas donde GraphQL es la mejor opci√≥n:</strong></p>

                <h3>üéØ Optimizaci√≥n de Aplicaciones M√≥viles</h3>

                <p>Si tienes una pantalla que solo necesita mostrar el nombre y la foto de un usuario, en REST podr√≠as recibir datos innecesarios como el correo, pa√≠s o historial (over-fetching).</p>

                <p><strong>Con GraphQL:</strong></p>

                <p>El cliente pide exactamente lo que necesita, lo que ahorra ancho de banda y hace que la aplicaci√≥n sea m√°s r√°pida.</p>

                <h3>‚ö° Equipos de Desarrollo que Necesitan Rapidez</h3>

                <p>Es ideal cuando quieres acelerar el trabajo entre frontend y backend.</p>

                <p><strong>Con GraphQL:</strong></p>

                <p>El equipo de frontend no tiene que esperar a que el backend cree o actualice "endpoints" espec√≠ficos cada vez que necesitan un dato nuevo; simplemente lo solicitan a trav√©s del esquema ya existente.</p>

                <h3>üîó Aplicaciones con M√∫ltiples Fuentes de Datos</h3>

                <p>Si tu proyecto consume informaci√≥n de:</p>

                <ul>
                    <li>Una base de datos SQL</li>
                    <li>Otra NoSQL</li>
                    <li>Una API REST externa</li>
                </ul>

                <p><strong>Puedes usar GraphQL:</strong></p>

                <p>Como una capa √∫nica que conecte todas estas fuentes a trav√©s de "resolvers" y las exponga al cliente de forma unificada.</p>

                <h3>üîî Funcionalidades en Tiempo Real</h3>

                <p>Gracias a las <strong>Subscriptions</strong>, es perfecto para aplicaciones que requieren eventos en tiempo real, como:</p>

                <ul>
                    <li>Chats</li>
                    <li>Notificaciones</li>
                    <li>Actualizaciones instant√°neas</li>
                </ul>

                <p><strong>Utiliza WebSockets para mantener la informaci√≥n actualizada instant√°neamente.</strong></p>

                <h3>‚úÖ Conclusi√≥n: Cu√°ndo Usar GraphQL</h3>

                <p><strong>Deber√≠as usarlo cuando:</strong></p>

                <ul>
                    <li>Necesites un punto de conexi√≥n √∫nico para toda tu informaci√≥n</li>
                    <li>Quieras que el cliente tenga el control total sobre los datos que recibe</li>
                    <li>Tengas m√∫ltiples dispositivos o clientes con necesidades diferentes</li>
                    <li>Busques optimizar ancho de banda en aplicaciones m√≥viles</li>
                    <li>Necesites iterar r√°pidamente sin cambiar endpoints</li>
                </ul>

                <h2>1Ô∏è‚É£1Ô∏è‚É£ Checklist Senior</h2>

                <ul>
                    <li>‚úÖ Entiendo por qu√© existen ambos paradigmas</li>
                    <li>‚úÖ Reconozco overfetching y underfetching en REST</li>
                    <li>‚úÖ S√© cu√°ndo usar cada uno seg√∫n contexto</li>
                    <li>‚úÖ Conozco el N+1 problem en GraphQL</li>
                    <li>‚úÖ Entiendo las implicaciones de caching</li>
                    <li>‚úÖ Considero seguridad en ambos</li>
                    <li>‚úÖ Puedo explicar resolvers correctamente</li>
                    <li>‚úÖ S√© que no es una competencia sino elecci√≥n</li>
                </ul>

                <h2>1Ô∏è‚É£2Ô∏è‚É£ Una Frase Para Recordar</h2>

                <p><strong>"REST y GraphQL no son enemigos. REST sirve a arquitecturas simples. GraphQL sirve a arquitecturas complejas. Elige seg√∫n tu problema, no seg√∫n la moda."</strong></p>

                <h2>üìö Referencias y Recursos</h2>

                <p><strong>Para profundizar m√°s:</strong></p>

                <ul>
                    <li><a href="https://chatgpt.com/g/g-p-69925f6597e88191b8bcb93447c5bb78-dragos/c/6994e74c-6864-8392-ac17-33b064066cd7" target="_blank">Dragos - From REST to GraphQL: Architecture Decisions</a></li>
                </ul>

                <div class="navigation-buttons">
                    <button class="btn btn-secondary" onclick="window.location.href='08-1-migrations.html'">‚Üê Anterior</button>
                    <button class="btn btn-primary" onclick="window.location.href='09-1-n-plus-one.html'">Siguiente: El Problema N+1 ‚Üí</button>
                </div>
            </section>
        </main>
    </div>

    <script src="../../../assets/js/app.js"></script>
</body>
</html>
