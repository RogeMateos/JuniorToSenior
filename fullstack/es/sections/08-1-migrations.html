<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Database Migrations | FullStack</title>
    <link rel="stylesheet" href="../../../assets/css/styles.css">
</head>
<body>
    <div class="container">
        <main class="main-content">
            <section id="section-migrations">
                <h1>2.1 ORMs: Database Migrations</h1>
                <p><strong>De Junior a Mentalidad Senior â€“ Versionando tu base de datos sin romper nada en producciÃ³n</strong></p>

                <h2>0ï¸âƒ£ El Problema Real</h2>

                <p>Tienes:</p>
                <ul>
                    <li>AplicaciÃ³n</li>
                    <li>Base de datos</li>
                    <li>Entorno local</li>
                    <li>Staging</li>
                    <li>ProducciÃ³n</li>
                </ul>

                <p><strong>Cada vez que cambias un modelo necesitas que:</strong></p>
                <ul>
                    <li>El esquema de la base de datos se actualice</li>
                    <li>No se pierdan datos</li>
                    <li>No se rompa producciÃ³n</li>
                    <li>Sea reproducible dentro de 6 meses</li>
                </ul>

                <p><strong>AquÃ­ entran las migraciones.</strong></p>

                <h2>1ï¸âƒ£ Dos Enfoques: Database-First vs Code-First</h2>

                <h3>ğŸ”¹ Database-First</h3>

                <p>Escribes SQL manual:</p>

                <pre><code>CREATE TABLE movie (
  id SERIAL PRIMARY KEY,
  title VARCHAR(255),
  release_date DATE
);</code></pre>

                <p>Versionas esos scripts. Tu cÃ³digo se adapta a la base de datos.</p>

                <p><strong>Ventajas:</strong></p>
                <ul>
                    <li>âœ… Control absoluto</li>
                    <li>âœ… Ideal para sistemas muy optimizados</li>
                </ul>

                <p><strong>Desventajas:</strong></p>
                <ul>
                    <li>âŒ Muy manual</li>
                    <li>âŒ FÃ¡cil cometer errores</li>
                    <li>âŒ DifÃ­cil mantener consistencia entre entornos</li>
                </ul>

                <h3>ğŸ”¹ Code-First (ORM + Migrations)</h3>

                <p>Defines modelos en cÃ³digo. El ORM genera migraciones automÃ¡ticamente.</p>

                <p>Ejemplo de modelo:</p>

                <pre><code>class Movie {
  id: number
  title: string
  releaseDate: Date
  revenue?: number
}</code></pre>

                <p>El ORM detecta el cambio y genera:</p>

                <pre><code>ALTER TABLE movie ADD COLUMN revenue INTEGER;</code></pre>

                <p><strong>Ventaja clave:</strong> La base de datos evoluciona junto al cÃ³digo, con historial controlado.</p>

                <p><strong>ğŸ‘‰ En la mayorÃ­a de frameworks modernos, este es el estÃ¡ndar.</strong></p>

                <h2>2ï¸âƒ£ Â¿QuÃ© es una MigraciÃ³n?</h2>

                <p><strong>Una migraciÃ³n es un paso incremental versionado que transforma la base de datos.</strong></p>

                <p>Cada migraciÃ³n tiene:</p>

                <pre><code>UP   â†’ aplica cambios
DOWN â†’ revierte cambios</code></pre>

                <p><strong>Ejemplo:</strong></p>

                <pre><code>-- UP
ALTER TABLE movie ADD COLUMN revenue INTEGER;

-- DOWN
ALTER TABLE movie DROP COLUMN revenue;</code></pre>

                <p><strong>Las migraciones se apilan:</strong></p>

                <pre><code>001_create_movie
002_add_reviews
003_add_revenue
004_modify_actor</code></pre>

                <p><strong>Si ejecutas todas desde cero â†’ obtienes el esquema actual.</strong></p>

                <p>Esto permite:</p>
                <ul>
                    <li>âœ… Reproducibilidad</li>
                    <li>âœ… Control de versiones</li>
                    <li>âœ… Rollbacks controlados</li>
                </ul>

                <h2>3ï¸âƒ£ CÃ³mo Funciona Internamente</h2>

                <p><strong>Cuando ejecutas:</strong></p>

                <pre><code>generate migration</code></pre>

                <p>El ORM:</p>
                <ul>
                    <li>Lee el estado actual del modelo</li>
                    <li>Compara con el estado de la base de datos</li>
                    <li>Genera SQL diferencial</li>
                    <li>Crea archivo versionado</li>
                    <li>Lo guarda en el repositorio</li>
                </ul>

                <p><strong>AdemÃ¡s, la base de datos mantiene una tabla interna:</strong></p>

                <pre><code>migrations</code></pre>

                <p>AhÃ­ registra quÃ© migraciones ya fueron ejecutadas. AsÃ­ evita ejecutarlas dos veces.</p>

                <h2>4ï¸âƒ£ Ejemplo Real Profesional (Cambio Seguro)</h2>

                <p><strong>Supongamos que quieres unificar:</strong></p>
                <ul>
                    <li>firstName</li>
                    <li>lastName</li>
                </ul>

                <p><strong>En:</strong></p>
                <ul>
                    <li>name</li>
                </ul>

                <h3>âš ï¸ Junior HarÃ­a:</h3>

                <pre><code>DROP firstName
DROP lastName
ADD name</code></pre>

                <p><strong>ğŸ’¥ Resultado: pÃ©rdida de datos.</strong></p>

                <h3>âœ… Estrategia Senior (Expand â†’ Contract)</h3>

                <p><strong>Fase 1: Expand (seguro)</strong></p>

                <pre><code>ALTER TABLE actor ADD COLUMN name VARCHAR(255);</code></pre>

                <p>No borras nada.</p>

                <p><strong>Fase 2: Data Backfill</strong></p>

                <pre><code>UPDATE actor
SET name = firstName || ' ' || lastName;</code></pre>

                <p>Ahora todos los registros tienen datos.</p>

                <p><strong>Fase 3: Cambiar la aplicaciÃ³n</strong></p>

                <p>El cÃ³digo empieza a usar name. Durante un tiempo puedes mantener compatibilidad.</p>

                <p><strong>Fase 4: Contract</strong></p>

                <p>Cuando estÃ¡s seguro:</p>

                <pre><code>ALTER TABLE actor DROP COLUMN firstName;
ALTER TABLE actor DROP COLUMN lastName;</code></pre>

                <p><strong>ğŸ¯ Sin downtime</strong><br>
                <strong>ğŸ¯ Sin pÃ©rdida de datos</strong><br>
                <strong>ğŸ¯ Sin romper versiones anteriores</strong></p>

                <p><strong>Este patrÃ³n se llama: Expand / Contract Pattern</strong><br>
                <strong>Es estÃ¡ndar en sistemas grandes.</strong></p>

                <h2>5ï¸âƒ£ Diferencia CrÃ­tica: Schema vs Data Migrations</h2>

                <h3>ğŸ”¹ Schema Migration</h3>

                <p>Cambia estructura:</p>
                <ul>
                    <li>ADD COLUMN</li>
                    <li>DROP COLUMN</li>
                    <li>CREATE TABLE</li>
                    <li>ADD INDEX</li>
                </ul>

                <h3>ğŸ”¹ Data Migration</h3>

                <p>Transforma datos:</p>
                <ul>
                    <li>UPDATE</li>
                    <li>Backfill</li>
                    <li>NormalizaciÃ³n</li>
                    <li>CorrecciÃ³n masiva</li>
                </ul>

                <p><strong>En sistemas reales casi siempre necesitas ambos.</strong></p>

                <h2>6ï¸âƒ£ Riesgos Reales En ProducciÃ³n</h2>

                <p>Un desarrollador senior piensa en:</p>

                <h3>ğŸ”´ Locks</h3>

                <p>Algunas operaciones bloquean tablas grandes.</p>

                <h3>ğŸ”´ PÃ©rdida de Datos</h3>

                <p>DROP COLUMN no es reversible realmente.</p>

                <h3>ğŸ”´ Incompatibilidad</h3>

                <p>Si despliegas cÃ³digo antes que migraciones â†’ error en runtime.</p>

                <h3>ğŸ”´ AÃ±adir NOT NULL</h3>

                <p>Si hay datos antiguos â†’ la migraciÃ³n falla.</p>

                <p><strong>SoluciÃ³n profesional:</strong></p>
                <ul>
                    <li>AÃ±adir columna nullable</li>
                    <li>Backfill</li>
                    <li>Luego hacer NOT NULL</li>
                </ul>

                <h2>7ï¸âƒ£ Despliegue En Pipeline (Muy Importante)</h2>

                <p><strong>Caso Seguro (Retrocompatible):</strong></p>
                <ul>
                    <li>Ejecutar migraciones</li>
                    <li>Deploy aplicaciÃ³n</li>
                </ul>

                <p><strong>Caso No Retrocompatible:</strong></p>
                <ul>
                    <li>Expand migration</li>
                    <li>Deploy aplicaciÃ³n</li>
                    <li>Contract migration</li>
                </ul>

                <p><strong>âŒ Nunca despliegues cÃ³digo que espera una columna que aÃºn no existe.</strong></p>

                <h2>8ï¸âƒ£ Buenas PrÃ¡cticas De Equipo</h2>

                <ul>
                    <li>âœ… Migraciones pequeÃ±as</li>
                    <li>âœ… Nombres descriptivos: <code>2026_02_17_add_revenue_to_movie</code></li>
                    <li>âœ… Nunca editar migraciones ya aplicadas</li>
                    <li>âœ… Revisar SQL generado en PR</li>
                    <li>âœ… Probar en staging</li>
                    <li>âœ… Ejecutar desde base limpia</li>
                    <li>âœ… Solo una instancia ejecuta migraciones en producciÃ³n</li>
                </ul>

                <h2>9ï¸âƒ£ CuÃ¡ndo Usar Database-First</h2>

                <p>Solo cuando:</p>
                <ul>
                    <li>âŒ Necesitas SQL extremadamente optimizado</li>
                    <li>âŒ Tienes lÃ³gica compleja en la base</li>
                    <li>âŒ Trabajas en sistema legacy</li>
                    <li>âŒ DBA controla esquema</li>
                </ul>

                <p><strong>En el 90% de productos web modernos â†’ Code-First + Migrations.</strong></p>

                <h2>ğŸ”Ÿ Mentalidad Senior</h2>

                <p><strong>Un junior piensa:</strong></p>

                <p>"Funciona en local."</p>

                <p><strong>Un senior piensa:</strong></p>
                <ul>
                    <li>Â¿Es reproducible?</li>
                    <li>Â¿Es reversible?</li>
                    <li>Â¿Bloquea tablas grandes?</li>
                    <li>Â¿Es retrocompatible?</li>
                    <li>Â¿Puede ejecutarse dentro de 6 meses sin contexto?</li>
                </ul>

                <h2>1ï¸âƒ£1ï¸âƒ£ Checklist Profesional Antes De Merge</h2>

                <ul>
                    <li>âœ… Â¿Es pequeÃ±a y clara?</li>
                    <li>âœ… Â¿Evita DROP inmediato?</li>
                    <li>âœ… Â¿Tiene backfill si es necesario?</li>
                    <li>âœ… Â¿Funciona con datos reales?</li>
                    <li>âœ… Â¿Es retrocompatible?</li>
                    <li>âœ… Â¿EstÃ¡ probada en staging?</li>
                    <li>âœ… Â¿RevisÃ© el SQL generado?</li>
                </ul>

                <h2>1ï¸âƒ£2ï¸âƒ£ Ejercicio PrÃ¡ctico</h2>

                <p><strong>AÃ±ade columna budget NOT NULL a movie.</strong></p>

                <p>Hazlo de forma segura sin romper datos existentes.</p>

                <p>EscrÃ­belo usando el patrÃ³n expand/contract.</p>

                <p><strong>Si puedes resolverlo correctamente, ya estÃ¡s pensando como backend engineer serio.</strong></p>

                <h2>1ï¸âƒ£3ï¸âƒ£ Una Frase Para Recordar</h2>

                <p><strong>"Las migraciones no son solo generar SQL. Son control de versiones de tu base de datos, seguridad en producciÃ³n, estrategia de despliegue y protecciÃ³n contra pÃ©rdida de datos."</strong></p>

                <div class="navigation-buttons">
                    <button class="btn btn-secondary" onclick="window.location.href='08-orms.html'">â† Anterior</button>
                    <button class="btn btn-primary" onclick="window.location.href='../../../index.html'">Volver al Inicio â†’</button>
                </div>
            </section>
        </main>
    </div>

    <script src="../../../assets/js/app.js"></script>
</body>
</html>
