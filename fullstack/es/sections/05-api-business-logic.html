<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The API Business Logic | FullStack</title>
    <link rel="stylesheet" href="../../../assets/css/styles.css">
</head>
<body>
    <div class="container">
        <main class="main-content">
            <section id="section-api-business-logic">
                <h1>1.3 Fundamentals: The API Business Logic</h1>
                <p><strong>Express es una cinta transportadora: los middlewares preparan y filtran; el controller traduce HTTP; el service decide; el repo guarda; y el error handler evita caos.</strong></p>

                <h2>0ï¸âƒ£ Â¿QuÃ© es un Middleware? (ExplicaciÃ³n Real)</h2>

                <p><strong>Un middleware es una funciÃ³n que intercepta el request antes de que llegue al handler.</strong></p>

                <p>Piensa en una fÃ¡brica de autos:</p>
                <ul>
                    <li>EstaciÃ³n 1: Limpiar pieza â†’ Middleware de logging</li>
                    <li>EstaciÃ³n 2: Pintar â†’ Middleware de autenticaciÃ³n</li>
                    <li>EstaciÃ³n 3: Revisar calidad â†’ Middleware de validaciÃ³n</li>
                    <li>EstaciÃ³n 4: Empacar â†’ Handler (tu lÃ³gica)</li>
                </ul>

                <p>En Express:</p>
                <pre><code>app.use((req, res, next) => {
  // Tu cÃ³digo aquÃ­
  next(); // Pasa al siguiente middleware
});</code></pre>

                <p><strong>El parÃ¡metro `next` es la puerta a la siguiente estaciÃ³n.</strong></p>

                <p>Sin `next()` â†’ se detiene el flujo.</p>

                <h2>1ï¸âƒ£ AuthN vs AuthZ (Diferencia CrÃ­tica)</h2>

                <p><strong>Authentication (AuthN): "Â¿QuiÃ©n eres?"</strong><br>
                Valida identidad. Â¿Token vÃ¡lido? Â¿SesiÃ³n activa?</p>

                <p><strong>Authorization (AuthZ): "Â¿Tienes permiso?"</strong><br>
                Valida permisos. Â¿Eres admin? Â¿Es tu recurso?</p>

                <p><strong>Ejemplo real:</strong></p>
                <pre><code>User: { id: 45, role: "user", permissions: ["posts:read", "posts:create"] }

GET /posts â†’ âœ… AuthN ok, AuthZ ok (posts:read)
POST /users â†’ âŒ AuthN ok, pero AuthZ fail (necesita admin)
POST /payments â†’ âŒ AuthN fail (sin token)</code></pre>

                <p>Muchas apps pasan AuthN y fallan en AuthZ.</p>

                <h2>2ï¸âƒ£ HTTP Status Codes Correctos</h2>

                <table class="cheat-sheet-table">
                    <thead>
                        <tr>
                            <th>CÃ³digo</th>
                            <th>Significado</th>
                            <th>CuÃ¡ndo usarlo</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>400</td>
                            <td>Bad Request</td>
                            <td>JSON invÃ¡lido, campo faltante</td>
                        </tr>
                        <tr>
                            <td>401</td>
                            <td>Unauthorized</td>
                            <td>Token ausente/invÃ¡lido (AuthN fail)</td>
                        </tr>
                        <tr>
                            <td>403</td>
                            <td>Forbidden</td>
                            <td>Autenticado pero sin permisos (AuthZ fail)</td>
                        </tr>
                        <tr>
                            <td>404</td>
                            <td>Not Found</td>
                            <td>Ruta o recurso no existe</td>
                        </tr>
                        <tr>
                            <td>409</td>
                            <td>Conflict</td>
                            <td>Email duplicado, estado invÃ¡lido</td>
                        </tr>
                        <tr>
                            <td>422</td>
                            <td>Unprocessable Entity</td>
                            <td>ValidaciÃ³n semÃ¡ntica (datos vÃ¡lidos pero rechazados por negocio)</td>
                        </tr>
                        <tr>
                            <td>429</td>
                            <td>Too Many Requests</td>
                            <td>Rate limit excedido</td>
                        </tr>
                        <tr>
                            <td>500</td>
                            <td>Internal Server Error</td>
                            <td>Bug en el servidor</td>
                        </tr>
                        <tr>
                            <td>503</td>
                            <td>Service Unavailable</td>
                            <td>BD caÃ­da, API externa no responde</td>
                        </tr>
                    </tbody>
                </table>

                <h2>3ï¸âƒ£ Arquitectura: Capas y Responsabilidades</h2>

                <p><strong>La cinta transportadora tiene estaciones claras:</strong></p>

                <pre><code>Request HTTP
     â†“
Route (define path/method)
     â†“
Middleware global (logging, JSON parser)
     â†“
Middleware especÃ­fico (auth, validation)
     â†“
Controller/Handler (HTTP concerns)
     â†“
Service (reglas de negocio)
     â†“
Repository (acceso a datos)
     â†“
Database
     â†“
Response HTTP</code></pre>

                <p><strong>Responsabilidades:</strong></p>
                <ul>
                    <li><strong>Route:</strong> Define GET /payments</li>
                    <li><strong>Middleware:</strong> Parsea JSON, valida token, registra logs</li>
                    <li><strong>Controller:</strong> "Â¿QuÃ© vino en el request? Llamo al service."</li>
                    <li><strong>Service:</strong> "Â¿La lÃ³gica de negocio permite esto? Llamo al repo."</li>
                    <li><strong>Repository:</strong> "OK, guardo en la BD."</li>
                    <li><strong>Error Handler:</strong> "Â¿Algo fallÃ³? Formato JSON consistente."</li>
                </ul>

                <h2>4ï¸âƒ£ Orden de Middlewares (CrÃ­tico)</h2>

                <p><strong>El orden importa. Un junior suele romper cosas por orden.</strong></p>

                <p>Orden recomendado:</p>

                <pre><code>1ï¸âƒ£ requestId / tracing (primero)
2ï¸âƒ£ logger (start)
3ï¸âƒ£ express.json() (parsear body)
4ï¸âƒ£ CORS (si aplica)
5ï¸âƒ£ authenticate (validar token)
6ï¸âƒ£ authorize (validar permisos)
7ï¸âƒ£ validateBody (schema validation)
8ï¸âƒ£ handler (tu lÃ³gica)
9ï¸âƒ£ errorHandler global (Ãºltimo)</code></pre>

                <p>Â¿Por quÃ© este orden?</p>
                <ul>
                    <li>requestId primero â†’ todos los logs lo incluyen</li>
                    <li>express.json() antes de auth â†’ necesitas parsear el token</li>
                    <li>auth antes de handler â†’ no llames al handler sin verificar identidad</li>
                    <li>errorHandler Ãºltimo â†’ catch de cualquier error</li>
                </ul>

                <h2>5ï¸âƒ£ Ejemplo Real: POST /payments</h2>

                <h3>Paso 1: Contrato (Request/Response)</h3>

                <pre><code>Request:
{
  "amount": 100.50,
  "currency": "USD",
  "description": "Compra online"
}

Response 201:
{
  "paymentId": "pay_123abc",
  "status": "CREATED",
  "amount": 100.50,
  "currency": "USD",
  "createdAt": "2024-01-15T10:30:00Z"
}</code></pre>

                <h3>Paso 2: Rutas y Middlewares</h3>

                <pre><code>// routes/payments.routes.ts
import { Router } from "express";
import { z } from "zod";
import { authenticate } from "../middleware/authenticate";
import { authorize } from "../middleware/authorize";
import { validateBody } from "../middleware/validateBody";
import { createPaymentController } from "../controllers/payments.controller";

const router = Router();

const CreatePaymentSchema = z.object({
  amount: z.number().positive("Amount debe ser > 0"),
  currency: z.string().length(3), // "USD", "EUR"
  description: z.string().optional(),
});

router.post(
  "/payments",
  authenticate,                          // âœ… Â¿QuiÃ©n eres?
  authorize("payments:create"),           // âœ… Â¿Tienes permiso?
  validateBody(CreatePaymentSchema),      // âœ… Â¿Datos vÃ¡lidos?
  createPaymentController                 // âœ… Ejecuta lÃ³gica
);

export default router;</code></pre>

                <h3>Paso 3: Middlewares</h3>

                <pre><code>// middleware/authenticate.ts
import type { Request, Response, NextFunction } from "express";
import { verifyToken } from "../shared/jwt";
import { AppError } from "../shared/errors";

export async function authenticate(req: Request, _res: Response, next: NextFunction) {
  const authHeader = req.headers.authorization;

  if (!authHeader?.startsWith("Bearer ")) {
    throw new AppError("NO_AUTH", "Missing or invalid Authorization header", 401);
  }

  const token = authHeader.substring(7); // Remove "Bearer "

  try {
    const decoded = verifyToken(token);
    (req as any).user = decoded; // Adjunta usuario al request
    next();
  } catch (err) {
    throw new AppError("INVALID_TOKEN", "Token invalid or expired", 401);
  }
}

// middleware/authorize.ts
import type { Request, Response, NextFunction } from "express";
import { AppError } from "../shared/errors";

export function authorize(requiredPermission: string) {
  return (req: Request, _res: Response, next: NextFunction) => {
    const user = (req as any).user;

    if (!user || !user.permissions?.includes(requiredPermission)) {
      throw new AppError(
        "NO_PERMISSION",
        `Missing permission: ${requiredPermission}`,
        403
      );
    }

    next();
  };
}

// middleware/validateBody.ts
import { z } from "zod";
import type { Request, Response, NextFunction } from "express";
import { AppError } from "../shared/errors";

export function validateBody(schema: z.ZodSchema) {
  return (req: Request, _res: Response, next: NextFunction) => {
    try {
      const validated = schema.parse(req.body);
      req.body = validated; // Reemplaza con datos normalizados
      next();
    } catch (err) {
      if (err instanceof z.ZodError) {
        const message = err.errors[0].message;
        throw new AppError("VALIDATION_ERROR", message, 422);
      }
      throw err;
    }
  };
}</code></pre>

                <h3>Paso 4: Controller (HTTP Translation)</h3>

                <pre><code>// controllers/payments.controller.ts
import type { Request, Response, NextFunction } from "express";
import { createPayment } from "../services/payments.service";
import { logger } from "../shared/logger";

export async function createPaymentController(
  req: Request,
  res: Response,
  next: NextFunction
) {
  try {
    // Body ya viene validado
    const { amount, currency, description } = req.body;

    // UserId viene del token autenticado
    const userId = (req as any).user.id;

    logger.info("Creating payment", {
      userId,
      amount,
      currency,
      requestId: (req as any).requestId,
    });

    const result = await createPayment({
      userId,
      amount,
      currency,
      description,
    });

    res.status(201).json(result);
  } catch (err) {
    next(err); // Delega al error handler global
  }
}</code></pre>

                <h3>Paso 5: Service (LÃ³gica de Negocio)</h3>

                <pre><code>// services/payments.service.ts
import { PaymentsRepo } from "../repositories/payments.repo";
import { CurrencyClient } from "../clients/currency.client";
import { AppError } from "../shared/errors";
import { logger } from "../shared/logger";

const repo = new PaymentsRepo();
const currencyClient = new CurrencyClient();

export async function createPayment(input: {
  userId: string;
  amount: number;
  currency: string;
  description?: string;
}) {
  // Regla 1: LÃ­mite de monto
  if (input.amount > 10_000) {
    throw new AppError(
      "LIMIT_EXCEEDED",
      "Amount exceeds allowed limit of $10,000",
      409
    );
  }

  // Regla 2: Obtener tasa de cambio
  let fxRate = 1;
  try {
    if (input.currency !== "EUR") {
      fxRate = await currencyClient.getRate(input.currency, "EUR");
    }
  } catch (err) {
    // Si la API de monedas cae, informamos al cliente
    logger.error("Currency API failed", { currency: input.currency });
    throw new AppError(
      "SERVICE_UNAVAILABLE",
      "Cannot process payment right now",
      503
    );
  }

  // Regla 3: Idempotencia (si viene Idempotency-Key, check si ya existe)
  // (aquÃ­ simplificado, en producciÃ³n mÃ¡s cuidado)

  // Persistencia
  const payment = await repo.insertPayment({
    userId: input.userId,
    amount: input.amount,
    currency: input.currency,
    fxRate,
    description: input.description,
  });

  return {
    paymentId: payment.id,
    status: "CREATED",
    amount: payment.amount,
    currency: payment.currency,
    createdAt: payment.createdAt.toISOString(),
  };
}</code></pre>

                <h3>Paso 6: Repository (Acceso a Datos)</h3>

                <pre><code>// repositories/payments.repo.ts
import { db } from "../shared/db";

export class PaymentsRepo {
  async insertPayment(data: {
    userId: string;
    amount: number;
    currency: string;
    fxRate: number;
    description?: string;
  }) {
    return await db.payments.create({
      data: {
        userId: data.userId,
        amount: data.amount,
        currency: data.currency,
        fxRate: data.fxRate,
        description: data.description || null,
        status: "CREATED",
      },
    });
  }

  async getPaymentById(id: string) {
    return await db.payments.findUnique({ where: { id } });
  }
}</code></pre>

                <h3>Paso 7: Error Handler Global</h3>

                <pre><code>// middleware/errorHandler.ts
import type { Request, Response, NextFunction } from "express";
import { AppError } from "../shared/errors";
import { logger } from "../shared/logger";

export function errorHandler(
  err: any,
  req: Request,
  res: Response,
  _next: NextFunction
) {
  const requestId = (req as any).requestId;

  if (err instanceof AppError) {
    logger.warn("AppError", {
      code: err.code,
      message: err.message,
      status: err.status,
      requestId,
    });

    return res.status(err.status).json({
      error: {
        code: err.code,
        message: err.message,
      },
    });
  }

  // Error inesperado (bug)
  logger.error("Unexpected error", {
    message: err.message,
    stack: err.stack,
    requestId,
  });

  return res.status(500).json({
    error: {
      code: "INTERNAL_ERROR",
      message: "Unexpected error occurred",
    },
  });
}</code></pre>

                <h3>Paso 8: Punto de entrada (app.ts)</h3>

                <pre><code>// app.ts
import express from "express";
import { v4 as uuidv4 } from "uuid";
import { errorHandler } from "./middleware/errorHandler";
import { logger } from "./shared/logger";
import paymentsRoutes from "./routes/payments.routes";

const app = express();

// Middlewares globales (orden importa)
app.use((req, _res, next) => {
  (req as any).requestId = uuidv4();
  logger.info("Request started", {
    method: req.method,
    path: req.path,
    requestId: (req as any).requestId,
  });
  next();
});

app.use(express.json());

// Rutas
app.use("/api", paymentsRoutes);

// Error handler (debe ir Ãºltimo)
app.use(errorHandler);

export default app;</code></pre>

                <h2>6ï¸âƒ£ Sequence Diagram (Happy Path + Error)</h2>

                <pre><code>Client â†’ API: POST /payments {amount, currency}
  â†“
API â†’ Auth Middleware: Validate token
  â”œâ”€ âœ… Token ok â†’ continue
  â””â”€ âŒ Token invalid â†’ return 401

API â†’ Authorize Middleware: Check permission
  â”œâ”€ âœ… Has permission â†’ continue
  â””â”€ âŒ No permission â†’ return 403

API â†’ Validate Middleware: Schema validation
  â”œâ”€ âœ… Valid â†’ continue
  â””â”€ âŒ Invalid â†’ return 422

API â†’ Controller: Extract data from request
  â†“
Controller â†’ Service: createPayment(userId, amount, currency)
  â†“
Service â†’ Currency API: getRate(currency)
  â”œâ”€ âœ… Rate ok â†’ continue
  â””â”€ âŒ API down â†’ return 503

Service â†’ Repository: insertPayment(...)
  â”œâ”€ âœ… Inserted â†’ return paymentId
  â””â”€ âŒ DB error â†’ return 500

Service â†’ Controller: Return {paymentId, status, ...}
  â†“
Controller â†’ Client: 201 Created {paymentId, ...}</code></pre>

                <h2>7ï¸âƒ£ Checklist Senior</h2>

                <ul>
                    <li>âœ… AuthN y AuthZ separados</li>
                    <li>âœ… HTTP Status codes correctos (400 vs 401 vs 403)</li>
                    <li>âœ… Middlewares en orden</li>
                    <li>âœ… Controller â†’ Service â†’ Repo separados</li>
                    <li>âœ… ValidaciÃ³n con schema (Zod, Joi, Yup)</li>
                    <li>âœ… Error handler global con formato consistente</li>
                    <li>âœ… Logging con requestId</li>
                    <li>âœ… Manejo de dependencias externas (currency API, BD)</li>
                    <li>âœ… Idempotencia para operaciones sensibles (pagos)</li>
                    <li>âœ… Rate limiting en endpoints crÃ­ticos</li>
                </ul>

                <h2>8ï¸âƒ£ Una Frase para Recordar</h2>

                <p><strong>"Express es una cinta transportadora: los middlewares preparan y filtran; el controller traduce HTTP; el service decide; el repo guarda; y el error handler evita caos."</strong></p>

                <h2>ğŸ“š Referencias y Recursos</h2>

                <p><strong>Para profundizar mÃ¡s:</strong></p>

                <ul>
                    <li><a href="https://chatgpt.com/g/g-p-69925f6597e88191b8bcb93447c5bb78-dragos/c/6994d21b-6744-838e-b412-d996e1e01672" target="_blank">Dragos - API Business Logic & Architecture Patterns</a></li>
                </ul>

                <div class="navigation-buttons">
                    <button class="btn btn-secondary" onclick="window.location.href='04-rest-apis.html'">â† Anterior</button>
                    <button class="btn btn-primary" onclick="window.location.href='06-databases.html'">Siguiente: Databases â†’</button>
                </div>
            </section>
        </main>
    </div>

    <script src="../../../assets/js/app.js"></script>
</body>
</html>