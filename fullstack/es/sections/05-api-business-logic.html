<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The API Business Logic | FullStack</title>
    <link rel="stylesheet" href="../../../assets/css/styles.css">
</head>
<body>
    <div class="container">
        <main class="main-content">
            <section id="section-api-business-logic">
                <h1>1.3 Fundamentals: The API Business Logic</h1>
                <p><strong>Express es una cinta transportadora: los middlewares preparan y filtran; el controller traduce HTTP; el service decide; el repo guarda; y el error handler evita caos.</strong></p>

                <h2>0️⃣ ¿Qué es un Middleware? (Explicación Real)</h2>

                <p><strong>Un middleware es una función que intercepta el request antes de que llegue al handler.</strong></p>

                <p>Piensa en una fábrica de autos:</p>
                <ul>
                    <li>Estación 1: Limpiar pieza → Middleware de logging</li>
                    <li>Estación 2: Pintar → Middleware de autenticación</li>
                    <li>Estación 3: Revisar calidad → Middleware de validación</li>
                    <li>Estación 4: Empacar → Handler (tu lógica)</li>
                </ul>

                <p>En Express:</p>
                <pre><code>app.use((req, res, next) => {
  // Tu código aquí
  next(); // Pasa al siguiente middleware
});</code></pre>

                <p><strong>El parámetro `next` es la puerta a la siguiente estación.</strong></p>

                <p>Sin `next()` → se detiene el flujo.</p>

                <h2>1️⃣ AuthN vs AuthZ (Diferencia Crítica)</h2>

                <p><strong>Authentication (AuthN): "¿Quién eres?"</strong><br>
                Valida identidad. ¿Token válido? ¿Sesión activa?</p>

                <p><strong>Authorization (AuthZ): "¿Tienes permiso?"</strong><br>
                Valida permisos. ¿Eres admin? ¿Es tu recurso?</p>

                <p><strong>Ejemplo real:</strong></p>
                <pre><code>User: { id: 45, role: "user", permissions: ["posts:read", "posts:create"] }

GET /posts → ✅ AuthN ok, AuthZ ok (posts:read)
POST /users → ❌ AuthN ok, pero AuthZ fail (necesita admin)
POST /payments → ❌ AuthN fail (sin token)</code></pre>

                <p>Muchas apps pasan AuthN y fallan en AuthZ.</p>

                <h2>2️⃣ HTTP Status Codes Correctos</h2>

                <table class="cheat-sheet-table">
                    <thead>
                        <tr>
                            <th>Código</th>
                            <th>Significado</th>
                            <th>Cuándo usarlo</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>400</td>
                            <td>Bad Request</td>
                            <td>JSON inválido, campo faltante</td>
                        </tr>
                        <tr>
                            <td>401</td>
                            <td>Unauthorized</td>
                            <td>Token ausente/inválido (AuthN fail)</td>
                        </tr>
                        <tr>
                            <td>403</td>
                            <td>Forbidden</td>
                            <td>Autenticado pero sin permisos (AuthZ fail)</td>
                        </tr>
                        <tr>
                            <td>404</td>
                            <td>Not Found</td>
                            <td>Ruta o recurso no existe</td>
                        </tr>
                        <tr>
                            <td>409</td>
                            <td>Conflict</td>
                            <td>Email duplicado, estado inválido</td>
                        </tr>
                        <tr>
                            <td>422</td>
                            <td>Unprocessable Entity</td>
                            <td>Validación semántica (datos válidos pero rechazados por negocio)</td>
                        </tr>
                        <tr>
                            <td>429</td>
                            <td>Too Many Requests</td>
                            <td>Rate limit excedido</td>
                        </tr>
                        <tr>
                            <td>500</td>
                            <td>Internal Server Error</td>
                            <td>Bug en el servidor</td>
                        </tr>
                        <tr>
                            <td>503</td>
                            <td>Service Unavailable</td>
                            <td>BD caída, API externa no responde</td>
                        </tr>
                    </tbody>
                </table>

                <h2>3️⃣ Arquitectura: Capas y Responsabilidades</h2>

                <p><strong>La cinta transportadora tiene estaciones claras:</strong></p>

                <pre><code>Request HTTP
     ↓
Route (define path/method)
     ↓
Middleware global (logging, JSON parser)
     ↓
Middleware específico (auth, validation)
     ↓
Controller/Handler (HTTP concerns)
     ↓
Service (reglas de negocio)
     ↓
Repository (acceso a datos)
     ↓
Database
     ↓
Response HTTP</code></pre>

                <p><strong>Responsabilidades:</strong></p>
                <ul>
                    <li><strong>Route:</strong> Define GET /payments</li>
                    <li><strong>Middleware:</strong> Parsea JSON, valida token, registra logs</li>
                    <li><strong>Controller:</strong> "¿Qué vino en el request? Llamo al service."</li>
                    <li><strong>Service:</strong> "¿La lógica de negocio permite esto? Llamo al repo."</li>
                    <li><strong>Repository:</strong> "OK, guardo en la BD."</li>
                    <li><strong>Error Handler:</strong> "¿Algo falló? Formato JSON consistente."</li>
                </ul>

                <h2>4️⃣ Orden de Middlewares (Crítico)</h2>

                <p><strong>El orden importa. Un junior suele romper cosas por orden.</strong></p>

                <p>Orden recomendado:</p>

                <pre><code>1️⃣ requestId / tracing (primero)
2️⃣ logger (start)
3️⃣ express.json() (parsear body)
4️⃣ CORS (si aplica)
5️⃣ authenticate (validar token)
6️⃣ authorize (validar permisos)
7️⃣ validateBody (schema validation)
8️⃣ handler (tu lógica)
9️⃣ errorHandler global (último)</code></pre>

                <p>¿Por qué este orden?</p>
                <ul>
                    <li>requestId primero → todos los logs lo incluyen</li>
                    <li>express.json() antes de auth → necesitas parsear el token</li>
                    <li>auth antes de handler → no llames al handler sin verificar identidad</li>
                    <li>errorHandler último → catch de cualquier error</li>
                </ul>

                <h2>5️⃣ Ejemplo Real: POST /payments</h2>

                <h3>Paso 1: Contrato (Request/Response)</h3>

                <pre><code>Request:
{
  "amount": 100.50,
  "currency": "USD",
  "description": "Compra online"
}

Response 201:
{
  "paymentId": "pay_123abc",
  "status": "CREATED",
  "amount": 100.50,
  "currency": "USD",
  "createdAt": "2024-01-15T10:30:00Z"
}</code></pre>

                <h3>Paso 2: Rutas y Middlewares</h3>

                <pre><code>// routes/payments.routes.ts
import { Router } from "express";
import { z } from "zod";
import { authenticate } from "../middleware/authenticate";
import { authorize } from "../middleware/authorize";
import { validateBody } from "../middleware/validateBody";
import { createPaymentController } from "../controllers/payments.controller";

const router = Router();

const CreatePaymentSchema = z.object({
  amount: z.number().positive("Amount debe ser > 0"),
  currency: z.string().length(3), // "USD", "EUR"
  description: z.string().optional(),
});

router.post(
  "/payments",
  authenticate,                          // ✅ ¿Quién eres?
  authorize("payments:create"),           // ✅ ¿Tienes permiso?
  validateBody(CreatePaymentSchema),      // ✅ ¿Datos válidos?
  createPaymentController                 // ✅ Ejecuta lógica
);

export default router;</code></pre>

                <h3>Paso 3: Middlewares</h3>

                <pre><code>// middleware/authenticate.ts
import type { Request, Response, NextFunction } from "express";
import { verifyToken } from "../shared/jwt";
import { AppError } from "../shared/errors";

export async function authenticate(req: Request, _res: Response, next: NextFunction) {
  const authHeader = req.headers.authorization;

  if (!authHeader?.startsWith("Bearer ")) {
    throw new AppError("NO_AUTH", "Missing or invalid Authorization header", 401);
  }

  const token = authHeader.substring(7); // Remove "Bearer "

  try {
    const decoded = verifyToken(token);
    (req as any).user = decoded; // Adjunta usuario al request
    next();
  } catch (err) {
    throw new AppError("INVALID_TOKEN", "Token invalid or expired", 401);
  }
}

// middleware/authorize.ts
import type { Request, Response, NextFunction } from "express";
import { AppError } from "../shared/errors";

export function authorize(requiredPermission: string) {
  return (req: Request, _res: Response, next: NextFunction) => {
    const user = (req as any).user;

    if (!user || !user.permissions?.includes(requiredPermission)) {
      throw new AppError(
        "NO_PERMISSION",
        `Missing permission: ${requiredPermission}`,
        403
      );
    }

    next();
  };
}

// middleware/validateBody.ts
import { z } from "zod";
import type { Request, Response, NextFunction } from "express";
import { AppError } from "../shared/errors";

export function validateBody(schema: z.ZodSchema) {
  return (req: Request, _res: Response, next: NextFunction) => {
    try {
      const validated = schema.parse(req.body);
      req.body = validated; // Reemplaza con datos normalizados
      next();
    } catch (err) {
      if (err instanceof z.ZodError) {
        const message = err.errors[0].message;
        throw new AppError("VALIDATION_ERROR", message, 422);
      }
      throw err;
    }
  };
}</code></pre>

                <h3>Paso 4: Controller (HTTP Translation)</h3>

                <pre><code>// controllers/payments.controller.ts
import type { Request, Response, NextFunction } from "express";
import { createPayment } from "../services/payments.service";
import { logger } from "../shared/logger";

export async function createPaymentController(
  req: Request,
  res: Response,
  next: NextFunction
) {
  try {
    // Body ya viene validado
    const { amount, currency, description } = req.body;

    // UserId viene del token autenticado
    const userId = (req as any).user.id;

    logger.info("Creating payment", {
      userId,
      amount,
      currency,
      requestId: (req as any).requestId,
    });

    const result = await createPayment({
      userId,
      amount,
      currency,
      description,
    });

    res.status(201).json(result);
  } catch (err) {
    next(err); // Delega al error handler global
  }
}</code></pre>

                <h3>Paso 5: Service (Lógica de Negocio)</h3>

                <pre><code>// services/payments.service.ts
import { PaymentsRepo } from "../repositories/payments.repo";
import { CurrencyClient } from "../clients/currency.client";
import { AppError } from "../shared/errors";
import { logger } from "../shared/logger";

const repo = new PaymentsRepo();
const currencyClient = new CurrencyClient();

export async function createPayment(input: {
  userId: string;
  amount: number;
  currency: string;
  description?: string;
}) {
  // Regla 1: Límite de monto
  if (input.amount > 10_000) {
    throw new AppError(
      "LIMIT_EXCEEDED",
      "Amount exceeds allowed limit of $10,000",
      409
    );
  }

  // Regla 2: Obtener tasa de cambio
  let fxRate = 1;
  try {
    if (input.currency !== "EUR") {
      fxRate = await currencyClient.getRate(input.currency, "EUR");
    }
  } catch (err) {
    // Si la API de monedas cae, informamos al cliente
    logger.error("Currency API failed", { currency: input.currency });
    throw new AppError(
      "SERVICE_UNAVAILABLE",
      "Cannot process payment right now",
      503
    );
  }

  // Regla 3: Idempotencia (si viene Idempotency-Key, check si ya existe)
  // (aquí simplificado, en producción más cuidado)

  // Persistencia
  const payment = await repo.insertPayment({
    userId: input.userId,
    amount: input.amount,
    currency: input.currency,
    fxRate,
    description: input.description,
  });

  return {
    paymentId: payment.id,
    status: "CREATED",
    amount: payment.amount,
    currency: payment.currency,
    createdAt: payment.createdAt.toISOString(),
  };
}</code></pre>

                <h3>Paso 6: Repository (Acceso a Datos)</h3>

                <pre><code>// repositories/payments.repo.ts
import { db } from "../shared/db";

export class PaymentsRepo {
  async insertPayment(data: {
    userId: string;
    amount: number;
    currency: string;
    fxRate: number;
    description?: string;
  }) {
    return await db.payments.create({
      data: {
        userId: data.userId,
        amount: data.amount,
        currency: data.currency,
        fxRate: data.fxRate,
        description: data.description || null,
        status: "CREATED",
      },
    });
  }

  async getPaymentById(id: string) {
    return await db.payments.findUnique({ where: { id } });
  }
}</code></pre>

                <h3>Paso 7: Error Handler Global</h3>

                <pre><code>// middleware/errorHandler.ts
import type { Request, Response, NextFunction } from "express";
import { AppError } from "../shared/errors";
import { logger } from "../shared/logger";

export function errorHandler(
  err: any,
  req: Request,
  res: Response,
  _next: NextFunction
) {
  const requestId = (req as any).requestId;

  if (err instanceof AppError) {
    logger.warn("AppError", {
      code: err.code,
      message: err.message,
      status: err.status,
      requestId,
    });

    return res.status(err.status).json({
      error: {
        code: err.code,
        message: err.message,
      },
    });
  }

  // Error inesperado (bug)
  logger.error("Unexpected error", {
    message: err.message,
    stack: err.stack,
    requestId,
  });

  return res.status(500).json({
    error: {
      code: "INTERNAL_ERROR",
      message: "Unexpected error occurred",
    },
  });
}</code></pre>

                <h3>Paso 8: Punto de entrada (app.ts)</h3>

                <pre><code>// app.ts
import express from "express";
import { v4 as uuidv4 } from "uuid";
import { errorHandler } from "./middleware/errorHandler";
import { logger } from "./shared/logger";
import paymentsRoutes from "./routes/payments.routes";

const app = express();

// Middlewares globales (orden importa)
app.use((req, _res, next) => {
  (req as any).requestId = uuidv4();
  logger.info("Request started", {
    method: req.method,
    path: req.path,
    requestId: (req as any).requestId,
  });
  next();
});

app.use(express.json());

// Rutas
app.use("/api", paymentsRoutes);

// Error handler (debe ir último)
app.use(errorHandler);

export default app;</code></pre>

                <h2>6️⃣ Sequence Diagram (Happy Path + Error)</h2>

                <pre><code>Client → API: POST /payments {amount, currency}
  ↓
API → Auth Middleware: Validate token
  ├─ ✅ Token ok → continue
  └─ ❌ Token invalid → return 401

API → Authorize Middleware: Check permission
  ├─ ✅ Has permission → continue
  └─ ❌ No permission → return 403

API → Validate Middleware: Schema validation
  ├─ ✅ Valid → continue
  └─ ❌ Invalid → return 422

API → Controller: Extract data from request
  ↓
Controller → Service: createPayment(userId, amount, currency)
  ↓
Service → Currency API: getRate(currency)
  ├─ ✅ Rate ok → continue
  └─ ❌ API down → return 503

Service → Repository: insertPayment(...)
  ├─ ✅ Inserted → return paymentId
  └─ ❌ DB error → return 500

Service → Controller: Return {paymentId, status, ...}
  ↓
Controller → Client: 201 Created {paymentId, ...}</code></pre>

                <h2>7️⃣ Checklist Senior</h2>

                <ul>
                    <li>✅ AuthN y AuthZ separados</li>
                    <li>✅ HTTP Status codes correctos (400 vs 401 vs 403)</li>
                    <li>✅ Middlewares en orden</li>
                    <li>✅ Controller → Service → Repo separados</li>
                    <li>✅ Validación con schema (Zod, Joi, Yup)</li>
                    <li>✅ Error handler global con formato consistente</li>
                    <li>✅ Logging con requestId</li>
                    <li>✅ Manejo de dependencias externas (currency API, BD)</li>
                    <li>✅ Idempotencia para operaciones sensibles (pagos)</li>
                    <li>✅ Rate limiting en endpoints críticos</li>
                </ul>

                <h2>8️⃣ Una Frase para Recordar</h2>

                <p><strong>"Express es una cinta transportadora: los middlewares preparan y filtran; el controller traduce HTTP; el service decide; el repo guarda; y el error handler evita caos."</strong></p>

                <div class="navigation-buttons">
                    <button class="btn btn-secondary" onclick="window.location.href='04-rest-apis.html'">← Anterior</button>
                    <button class="btn btn-primary" onclick="window.location.href='../../../index.html'">Volver al Inicio →</button>
                </div>
            </section>
        </main>
    </div>

    <script src="../../../assets/js/app.js"></script>
</body>
</html>