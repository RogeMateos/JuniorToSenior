<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Autenticaci√≥n con OAuth 2.0 | FullStack</title>
    <link rel="stylesheet" href="../../../assets/css/styles.css">
</head>
<body>
    <div class="container">
        <aside id="sidebar" class="sidebar"></aside>
        <main class="main-content">
            <section id="section-oauth">
                <h1>üîê 4.0 Authentication: Modern OAuth 2.0 + OpenID Connect (OIDC)</h1>
                <p><strong>Modelo Mental Correcto para SPA (React) + Microservicios</strong></p>

                <h2>0Ô∏è‚É£ Contexto: ¬øPor Qu√© Necesitamos M√°s Que Basic Auth?</h2>

                <p><strong>Antes:</strong></p>

                <pre><code>Usuario ‚Üí manda email/password en cada request
Servidor valida
Fin.</code></pre>

                <p><strong>Problemas cuando el sistema crece:</strong></p>

                <ul>
                    <li>‚ùå No quieres loguearte 10 veces (login federado)</li>
                    <li>‚ùå Microservicios ‚Üí muchos servicios necesitan saber qui√©n eres</li>
                    <li>‚ùå Seguridad (no quieres mandar credenciales constantemente)</li>
                    <li>‚ùå Necesitas permisos granulares (roles, scopes)</li>
                    <li>‚ùå Integraciones externas (Google, Facebook, etc.)</li>
                </ul>

                <p><strong>Soluci√≥n moderna:</strong></p>

                <ul>
                    <li>üëâ Delegar autenticaci√≥n y autorizaci√≥n a un Identity Provider (IdP)</li>
                    <li>üëâ Usar OAuth 2.0 + OpenID Connect</li>
                </ul>

                <h2>1Ô∏è‚É£ Conceptos Fundamentales (Claves Para No Confundirse)</h2>

                <h3>üîπ OAuth 2.0 ‚â† Autenticaci√≥n</h3>

                <p>OAuth 2.0 es un est√°ndar de autorizaci√≥n delegada.</p>

                <p>Sirve para decir:</p>

                <p><strong>"Permito que esta aplicaci√≥n acceda a mis recursos".</strong></p>

                <p>Para login (identidad), usamos:</p>

                <h3>üîπ OpenID Connect (OIDC)</h3>

                <p>Es una capa encima de OAuth2 que a√±ade:</p>

                <ul>
                    <li>ID Token</li>
                    <li>Claims de usuario</li>
                    <li>Est√°ndar para login</li>
                </ul>

                <p><strong>En la pr√°ctica:</strong></p>

                <p>Cuando haces "Login with Google" ‚Üí est√°s usando OIDC.</p>

                <h2>2Ô∏è‚É£ Actores En Arquitectura Moderna</h2>

                <p><strong>En una arquitectura SPA + microservicios tenemos:</strong></p>

                <ul>
                    <li>üë§ User (Resource Owner)</li>
                    <li>üñ• SPA (React App)</li>
                    <li>üîê Identity Server (Auth0, Okta, Azure AD...)</li>
                    <li>üîß Resource Servers (APIs / Microservicios)</li>
                </ul>

                <p><strong>Flujo general:</strong></p>

                <pre><code>User ‚Üí SPA ‚Üí Identity Server ‚Üí SPA ‚Üí APIs</code></pre>

                <h2>3Ô∏è‚É£ Autenticaci√≥n vs Autorizaci√≥n (Muy Importante)</h2>

                <h3>üîê Autenticaci√≥n</h3>

                <p><strong>¬øQui√©n eres?</strong></p>

                <p><strong>Ejemplo:</strong></p>

                <ul>
                    <li>Email + Password</li>
                    <li>MFA</li>
                    <li>Login con Google</li>
                </ul>

                <p><strong>Resultado: ‚úî Usuario verificado</strong></p>

                <h3>üõÇ Autorizaci√≥n</h3>

                <p><strong>¬øQu√© puedes hacer?</strong></p>

                <p><strong>Ejemplo:</strong></p>

                <ul>
                    <li>Puede leer p√≥lizas</li>
                    <li>No puede borrarlas</li>
                </ul>

                <p><strong>Resultado: ‚úî Tiene permiso o ‚ùå No tiene permiso</strong></p>

                <h2>4Ô∏è‚É£ Tokens: Qu√© Son y Para Qu√© Sirven</h2>

                <p><strong>Cuando el usuario se autentica, recibe tokens.</strong></p>

                <h3>üîπ Access Token</h3>

                <ul>
                    <li>Se env√≠a a APIs</li>
                    <li>Representa permisos</li>
                    <li>Normalmente es JWT</li>
                </ul>

                <h3>üîπ ID Token (OIDC)</h3>

                <ul>
                    <li>Contiene identidad del usuario</li>
                    <li>Se usa en el cliente</li>
                    <li>No debe usarse en APIs</li>
                </ul>

                <h3>üîπ Refresh Token</h3>

                <ul>
                    <li>Sirve para obtener nuevos access tokens</li>
                    <li>No se env√≠a a APIs</li>
                </ul>

                <h2>5Ô∏è‚É£ El Flujo Correcto Para SPA (Authorization Code + PKCE)</h2>

                <p><strong>Este es el flujo moderno y seguro para React.</strong></p>

                <h3>Paso 1 ‚Äì Usuario pulsa "Login"</h3>

                <p>La SPA genera:</p>

                <ul>
                    <li><code>code_verifier</code> (secreto)</li>
                    <li><code>code_challenge</code> (hash del verifier)</li>
                </ul>

                <p>Redirige al Identity Server:</p>

                <pre><code>/authorize
?client_id=...
&code_challenge=...
&scope=openid profile read:policies</code></pre>

                <h3>Paso 2 ‚Äì Login en Identity Server</h3>

                <p>El usuario:</p>

                <ul>
                    <li>Introduce credenciales</li>
                    <li>Hace MFA si es necesario</li>
                </ul>

                <p><strong>Muy importante:</strong></p>

                <ul>
                    <li>üëâ El login ocurre en el dominio del IdP.</li>
                    <li>üëâ No en tu aplicaci√≥n.</li>
                </ul>

                <p>Esto reduce riesgo de phishing.</p>

                <h3>Paso 3 ‚Äì El IdP Devuelve Authorization Code</h3>

                <p>El usuario es redirigido:</p>

                <pre><code>https://tuapp.com/callback?code=abc123</code></pre>

                <h3>Paso 4 ‚Äì Intercambio Code ‚Üí Tokens</h3>

                <p>La SPA llama:</p>

                <pre><code>POST /token
code=abc123
code_verifier=original_secret</code></pre>

                <p>El servidor valida que el verifier coincida.</p>

                <p>Si todo es correcto:</p>

                <p><strong>‚úî Devuelve:</strong></p>

                <ul>
                    <li>Access Token</li>
                    <li>ID Token</li>
                    <li>(Refresh Token opcional)</li>
                </ul>

                <h3>¬øPor Qu√© Existe PKCE?</h3>

                <p>Porque una SPA no puede guardar un client secret.</p>

                <p>PKCE protege el authorization code.</p>

                <p><strong>Analog√≠a senior:</strong></p>

                <p>El code es el ticket.<br>
                El verifier es la contrase√±a del ticket.<br>
                Sin la contrase√±a, no puedes canjearlo.</p>

                <h2>6Ô∏è‚É£ C√≥mo La SPA Llama a la API</h2>

                <p><strong>Ejemplo de request:</strong></p>

                <pre><code>GET /policies
Authorization: Bearer eyJhbGciOi...</code></pre>

                <p>La API recibe el token.</p>

                <h2>7Ô∏è‚É£ Qu√© Hace El Backend (Muy Importante)</h2>

                <p>El backend NO solo comprueba que exista token.</p>

                <p>Debe validar:</p>

                <ul>
                    <li>‚úî Firma (JWKS)</li>
                    <li>‚úî iss (issuer)</li>
                    <li>‚úî aud (audience)</li>
                    <li>‚úî exp (no expirado)</li>
                    <li>‚úî scopes/roles</li>
                </ul>

                <p><strong>Ejemplo middleware (Node):</strong></p>

                <pre><code>app.use((req, res, next) => {
  const token = getBearerToken(req);
  if (!token) return res.sendStatus(401);

  const payload = verifyJwt(token);

  if (!payload.scopes.includes("read:policies")) {
    return res.sendStatus(403);
  }

  req.user = payload;
  next();
});</code></pre>

                <h2>8Ô∏è‚É£ 401 vs 403 (Cl√°sica Pregunta De Entrevista)</h2>

                <table class="cheat-sheet-table">
                    <thead>
                        <tr>
                            <th>C√≥digo</th>
                            <th>Significado</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>401</strong></td>
                            <td>No autenticado (token inv√°lido o ausente)</td>
                        </tr>
                        <tr>
                            <td><strong>403</strong></td>
                            <td>Autenticado pero sin permisos</td>
                        </tr>
                    </tbody>
                </table>

                <h2>9Ô∏è‚É£ D√≥nde Guardar El Token (Decisi√≥n Arquitect√≥nica)</h2>

                <h3>‚ùå localStorage</h3>

                <p>Riesgo: XSS puede robar tokens.</p>

                <h3>‚ö† Cookies</h3>

                <p>Necesitas:</p>

                <ul>
                    <li>HttpOnly</li>
                    <li>SameSite</li>
                    <li>CSRF protection</li>
                </ul>

                <h3>‚úÖ Mejor Pr√°ctica Moderna: BFF Pattern</h3>

                <ul>
                    <li>Browser solo tiene cookie de sesi√≥n</li>
                    <li>Backend gestiona tokens</li>
                </ul>

                <h2>üîü Microservicios: Comunicaci√≥n Entre APIs</h2>

                <p><strong>Para comunicaci√≥n service-to-service:</strong></p>

                <ul>
                    <li>üëâ Se usa normalmente Client Credentials Flow</li>
                    <li>No hay usuario</li>
                    <li>Es m√°quina a m√°quina</li>
                </ul>

                <h2>1Ô∏è‚É£1Ô∏è‚É£ C√≥mo Debuggear (Muy Pr√°ctico)</h2>

                <p><strong>En DevTools ‚Üí Network:</strong></p>

                <p>Busca:</p>

                <ul>
                    <li>/authorize</li>
                    <li>/token</li>
                    <li>Header Authorization</li>
                    <li>Redirecciones 302</li>
                    <li>Cookies</li>
                </ul>

                <p><strong>Decodifica el JWT en:</strong></p>

                <p><code>https://jwt.io</code></p>

                <p>Verifica:</p>

                <ul>
                    <li>sub</li>
                    <li>scope</li>
                    <li>aud</li>
                    <li>exp</li>
                </ul>

                <h2>1Ô∏è‚É£2Ô∏è‚É£ Seguridad Real (Lo Que Un Senior Siempre Piensa)</h2>

                <p>OAuth no te salva si:</p>

                <ul>
                    <li>Tienes XSS</li>
                    <li>Tienes CSP mal configurado</li>
                    <li>No validas tokens correctamente</li>
                    <li>Conf√≠as en el ID token para APIs</li>
                </ul>

                <h2>1Ô∏è‚É£3Ô∏è‚É£ Checklist Final</h2>

                <ul>
                    <li>‚úÖ Uso Authorization Code + PKCE</li>
                    <li>‚úÖ Diferencio OAuth2 vs OIDC</li>
                    <li>‚úÖ Entiendo ID vs Access Token</li>
                    <li>‚úÖ Backend valida firma y claims</li>
                    <li>‚úÖ Uso 401 vs 403 correctamente</li>
                    <li>‚úÖ S√© explicar PKCE</li>
                    <li>‚úÖ S√© debuggear el flujo</li>
                </ul>

                <h2>1Ô∏è‚É£4Ô∏è‚É£ Preguntas T√≠picas De Entrevista</h2>

                <h3>1) ¬øOAuth2 es autenticaci√≥n?</h3>

                <p>No. Es autorizaci√≥n. Para login usamos OIDC.</p>

                <h3>2) ¬øPor qu√© PKCE?</h3>

                <p>Porque las SPA no pueden guardar secretos. PKCE protege el code.</p>

                <h3>3) ¬øC√≥mo valida una API un JWT?</h3>

                <p>Verifica firma con JWKS y claims (iss, aud, exp).</p>

                <h3>4) ¬øDiferencia entre ID Token y Access Token?</h3>

                <p>ID Token = identidad del usuario.<br>
                Access Token = permisos para APIs.</p>

                <h3>5) ¬øD√≥nde guardar tokens?</h3>

                <p>Depende del threat model. Mejor pr√°ctica: BFF o memoria + protecci√≥n XSS.</p>

                <h2>1Ô∏è‚É£5Ô∏è‚É£ Mental Model Final</h2>

                <ul>
                    <li>El usuario nunca da su password a tu app.</li>
                    <li>Tu app nunca valida credenciales.</li>
                    <li>El Identity Server es el √∫nico que autentica.</li>
                    <li>Las APIs solo conf√≠an en tokens firmados.</li>
                    <li>Autenticaci√≥n y autorizaci√≥n son cosas distintas.</li>
                </ul>

                <h2>1Ô∏è‚É£6Ô∏è‚É£ Una Frase Para Recordar</h2>

                <p><strong>\"OAuth no es autenticaci√≥n, es autorizaci√≥n. Para login, usa OIDC. Las SPA nunca deben guardar credenciales, solo tokens. El Identity Server es el √∫nico juez de identidad.\"</strong></p>

                <h2>1Ô∏è‚É£7Ô∏è‚É£ Referencias y Recursos</h2>

                <p><strong>Para profundizar m√°s:</strong></p>

                <ul>
                    <li><a href="https://chatgpt.com/g/g-p-69925f6597e88191b8bcb93447c5bb78-dragos/c/6994eae7-3040-8393-85bb-3d3e5f4a9d1d" target="_blank">Dragos - Advanced OAuth 2.0 & Security Patterns</a></li>
                </ul>

                <div class="navigation-buttons">
                    <button class="btn btn-secondary" onclick="window.location.href='09-1-n-plus-one.html'">‚Üê Anterior</button>
                    <button class="btn btn-primary" onclick="window.location.href='11-sql-injection.html'">Siguiente: SQL Injection ‚Üí</button>
                </div>
            </section>
        </main>
    </div>

    <script src="../../../assets/js/app.js"></script>
</body>
</html>
