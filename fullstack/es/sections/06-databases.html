<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dise√±o de Bases de Datos | FullStack</title>
    <link rel="stylesheet" href="../../../assets/css/styles.css">
</head>
<body>
    <div class="container">
        <main class="main-content">
            <section id="section-database-design">
                <h1>1.4 Fundamentals: Database Design</h1>
                <p><strong>Una BD bien dise√±ada previene bugs, performance issues y dolor de cabeza a los 2 a√±os. Una mal dise√±ada causa deuda t√©cnica que nunca repagas.</strong></p>

                <h2>0Ô∏è‚É£ ¬øQu√© es una Base de Datos?</h2>

                <p><strong>Es donde tu aplicaci√≥n guarda estado permanente.</strong></p>

                <p>Sin BD:</p>
                <ul>
                    <li>Cada request crea nuevos datos</li>
                    <li>Mueres al reiniciar el servidor</li>
                    <li>No hay historia</li>
                </ul>

                <p>Con BD (SQL):</p>
                <ul>
                    <li>Datos persisten en tablas</li>
                    <li>Relaciones entre entidades</li>
                    <li>Queries complejas</li>
                    <li>ACID transactions</li>
                </ul>

                <h2>1Ô∏è‚É£ SQL vs NoSQL (Conceptos B√°sicos)</h2>

                <table class="cheat-sheet-table">
                    <thead>
                        <tr>
                            <th>Aspecto</th>
                            <th>SQL (PostgreSQL, MySQL)</th>
                            <th>NoSQL (MongoDB, DynamoDB)</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>Estructura</strong></td>
                            <td>Tablas con esquema fijo</td>
                            <td>Documentos, sin esquema r√≠gido</td>
                        </tr>
                        <tr>
                            <td><strong>Relaciones</strong></td>
                            <td>Foreign keys expl√≠citas</td>
                            <td>Anidadas (embedding) o referencias</td>
                        </tr>
                        <tr>
                            <td><strong>Escalabilidad</strong></td>
                            <td>Vertical (m√°s poder en 1 servidor)</td>
                            <td>Horizontal (muchos servidores)</td>
                        </tr>
                        <tr>
                            <td><strong>ACID</strong></td>
                            <td>S√≠, garantizado</td>
                            <td>Depende (NoSQL = m√°s d√©bil)</td>
                        </tr>
                        <tr>
                            <td><strong>Queries</strong></td>
                            <td>SQL potente</td>
                            <td>APIs espec√≠ficas (ej: find() en Mongo)</td>
                        </tr>
                        <tr>
                            <td><strong>Caso de uso</strong></td>
                            <td>Apps tradicionales, finanzas</td>
                            <td>APIs de alto volumen, real-time</td>
                        </tr>
                    </tbody>
                </table>

                <p><strong>En 2024, SQL es a√∫n el est√°ndar para aplicaciones serias.</strong> NoSQL brilla en casos muy espec√≠ficos.</p>

                <h2>2Ô∏è‚É£ Dise√±o de Tablas (Normalizaci√≥n)</h2>

                <p><strong>Una tabla mal dise√±ada cuesta caro despu√©s.</strong></p>

                <p>Ejemplo BAD:</p>
                <pre><code>CREATE TABLE users (
  id INT PRIMARY KEY,
  name VARCHAR(255),
  email VARCHAR(255),
  phone VARCHAR(255),
  addresses TEXT, -- ‚ùå M√∫ltiples direcciones en un string
  orders TEXT,    -- ‚ùå M√∫ltiples √≥rdenes en un string
  tags VARCHAR(255) -- ‚ùå M√∫ltiples tags separados por comas
);</code></pre>

                <p><strong>Problemas:</strong></p>
                <ul>
                    <li>¬øC√≥mo buscas "usuarios en NY"? (addresses es string)</li>
                    <li>¬øC√≥mo cuentas √≥rdenes? (orders es string)</li>
                    <li>¬øC√≥mo actualizas una direcci√≥n? (hay que parsear, actualizar, guardar)</li>
                    <li>Datos duplicados, no normalizados</li>
                </ul>

                <p>Ejemplo GOOD:</p>
                <pre><code>CREATE TABLE users (
  id INT PRIMARY KEY,
  name VARCHAR(255),
  email VARCHAR(255) UNIQUE,
  phone VARCHAR(255),
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE addresses (
  id INT PRIMARY KEY,
  user_id INT NOT NULL,
  street VARCHAR(255),
  city VARCHAR(255),
  country VARCHAR(255),
  is_primary BOOLEAN DEFAULT FALSE,
  FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
);

CREATE TABLE orders (
  id INT PRIMARY KEY,
  user_id INT NOT NULL,
  status VARCHAR(50), -- "pending", "shipped", "delivered"
  total_amount DECIMAL(10, 2),
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  FOREIGN KEY (user_id) REFERENCES users(id)
);

CREATE TABLE user_tags (
  user_id INT NOT NULL,
  tag_id INT NOT NULL,
  PRIMARY KEY (user_id, tag_id),
  FOREIGN KEY (user_id) REFERENCES users(id),
  FOREIGN KEY (tag_id) REFERENCES tags(id)
);</code></pre>

                <p><strong>Ventajas:</strong></p>
                <ul>
                    <li>Cada dato en su lugar</li>
                    <li>Queries claras: SELECT * FROM addresses WHERE city = "New York"</li>
                    <li>Actualizaciones simples</li>
                    <li>Sin duplicaci√≥n</li>
                </ul>

                <h2>3Ô∏è‚É£ Claves y Relaciones</h2>

                <p><strong>Tipos de claves:</strong></p>

                <p><strong>Primary Key (PK):</strong> Identifica √∫nicament una fila</p>
                <pre><code>id INT PRIMARY KEY -- o UUID para escala</code></pre>

                <p><strong>Foreign Key (FK):</strong> Referencia a otra tabla</p>
                <pre><code>user_id INT NOT NULL,
FOREIGN KEY (user_id) REFERENCES users(id)</code></pre>

                <p><strong>Unique Key:</strong> Garantiza unicidad</p>
                <pre><code>email VARCHAR(255) UNIQUE -- no duplicados</code></pre>

                <h3>Tipos de Relaciones</h3>

                <p><strong>One-to-Many (1:N):</strong> 1 usuario, muchas direcciones</p>
                <pre><code>users (1) ----< addresses (N)</code></pre>

                <p><strong>Many-to-Many (N:N):</strong> Muchos usuarios, muchos tags</p>
                <pre><code>users (N) ----< user_tags >---- tags (N)
(tabla de uni√≥n/junction table)</code></pre>

                <p><strong>One-to-One (1:1):</strong> 1 usuario, 1 perfil</p>
                <pre><code>users (1) ---- profiles (1)</code></pre>

                <h2>4Ô∏è‚É£ √çndices (Speed Up Queries)</h2>

                <p><strong>Sin √≠ndices, cada query escanea toda la tabla (table scan).</strong></p>
                <p><strong>Con √≠ndices, la BD salta directo al dato (index lookup).</strong></p>

                <p>Ejemplo:</p>
                <pre><code>-- Sin √≠ndice: SELECT * FROM users WHERE email = 'roge@example.com'
-- Escanea 1M usuarios ‚Üí lento

-- Con √≠ndice:
CREATE INDEX idx_users_email ON users(email);
-- Ahora: busca en √°rbol B-tree ‚Üí muy r√°pido</code></pre>

                <p><strong>Cu√°ndo crear √≠ndices:</strong></p>
                <ul>
                    <li>Columnas en WHERE (b√∫squedas frecuentes)</li>
                    <li>Columnas en JOIN (relaciones)</li>
                    <li>Columnas en ORDER BY (si es frecuente)</li>
                    <li><strong>NO</strong> en todas partes (ralentiza writes)</li>
                </ul>

                <p>√çndices comunes:</p>
                <pre><code>-- PK autom√°ticamente indexado
CREATE INDEX idx_orders_user_id ON orders(user_id);
CREATE INDEX idx_orders_status ON orders(status);
CREATE UNIQUE INDEX idx_users_email ON users(email);</code></pre>

                <h2>5Ô∏è‚É£ Constraints (Garant√≠as)</h2>

                <p><strong>Prevents bugs antes de que ocurran.</strong></p>

                <pre><code>CREATE TABLE users (
  id INT PRIMARY KEY,
  email VARCHAR(255) UNIQUE NOT NULL, -- ‚ùå No nulos, sin duplicados
  age INT CHECK (age >= 18), -- ‚ùå Solo mayores de 18
  status VARCHAR(50) DEFAULT 'active', -- por defecto
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE orders (
  id INT PRIMARY KEY,
  user_id INT NOT NULL,
  amount DECIMAL(10, 2) CHECK (amount > 0), -- ‚ùå Siempre positivo
  status VARCHAR(50) IN ('pending', 'shipped', 'delivered'),
  FOREIGN KEY (user_id) REFERENCES users(id)
    ON DELETE CASCADE -- ‚ùå Si borro usuario, borro sus √≥rdenes
    ON UPDATE CASCADE -- ‚ùå Si cambio user_id, actualizo √≥rdenes
);</code></pre>

                <p><strong>Tipos de constraints:</strong></p>
                <ul>
                    <li>NOT NULL: Obligatorio</li>
                    <li>UNIQUE: Sin duplicados</li>
                    <li>PRIMARY KEY: Identifica fila</li>
                    <li>FOREIGN KEY: Referencia a otra tabla</li>
                    <li>CHECK: Validaci√≥n (age > 0)</li>
                    <li>DEFAULT: Valor por defecto</li>
                </ul>

                <h2>6Ô∏è‚É£ Transacciones ACID</h2>

                <p><strong>ACID = Atomicity, Consistency, Isolation, Durability</strong></p>

                <p>Caso real: Transferencia bancaria de $100</p>
                <pre><code>BEGIN TRANSACTION;
  UPDATE accounts SET balance = balance - 100 WHERE id = 1; -- Roge pierde $100
  UPDATE accounts SET balance = balance + 100 WHERE id = 2; -- Paco gana $100
COMMIT;</code></pre>

                <p><strong>Atomicity (Todo o Nada):</strong> Ambas queries ocurren o ninguna</p>
                <p><strong>Consistency (V√°lido):</strong> BD nunca queda en estado inv√°lido</p>
                <p><strong>Isolation (Sin interferencia):</strong> Transacciones no se interrumpen</p>
                <p><strong>Durability (Permanente):</strong> Una vez COMMIT, est√° guardado (incluso si hay apag√≥n)</p>

                <p>Si algo falla entre UPDATE 1 y UPDATE 2 (crash del server), SQL revierte TODO.</p>

                <h2>7Ô∏è‚É£ Migrations (Schema Versioning)</h2>

                <p><strong>Nunca alters tabla a mano en producci√≥n.</strong></p>

                <p>Usa migrations (ej: Prisma, Alembic):</p>

                <pre><code>// migration: 001_create_users.sql
CREATE TABLE users (
  id INT PRIMARY KEY,
  email VARCHAR(255) UNIQUE NOT NULL,
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

// migration: 002_add_phone_to_users.sql
ALTER TABLE users ADD COLUMN phone VARCHAR(255);

// migration: 003_add_address_table.sql
CREATE TABLE addresses (
  id INT PRIMARY KEY,
  user_id INT NOT NULL,
  street VARCHAR(255),
  FOREIGN KEY (user_id) REFERENCES users(id)
);</code></pre>

                <p><strong>Ventajas:</strong></p>
                <ul>
                    <li>Historial completo de cambios</li>
                    <li>Reproducible (dev = staging = prod)</li>
                    <li>Rollback f√°cil si algo quebr√≥</li>
                    <li>Control de versiones (git)</li>
                </ul>

                <h2>8Ô∏è‚É£ ORM: Prisma, TypeORM, Sequelize</h2>

                <p><strong>ORMs abstraen SQL y hacen queries m√°s seguras.</strong></p>

                <p>Sin ORM (crudo SQL):</p>
                <pre><code>// ‚ùå Riesgo SQL injection
const userId = req.body.id;
db.query(`SELECT * FROM users WHERE id = ${userId}`);
// Si userId = "1 OR 1=1", se filtra TODA la tabla</code></pre>

                <p>Con ORM (Prisma):</p>
                <pre><code>// ‚úÖ Parametrizado (safe)
const user = await prisma.user.findUnique({
  where: { id: parseInt(req.body.id) },
});
// Prisma escapa valores autom√°ticamente</code></pre>

                <p><strong>Otros beneficios de ORMs:</strong></p>
                <ul>
                    <li>Type-safe (TypeScript)</li>
                    <li>Migrations autom√°ticas</li>
                    <li>Relations f√°ciles</li>
                    <li>Queries intuitivas (no raw SQL)</li>
                </ul>

                <h2>9Ô∏è‚É£ Query Performance</h2>

                <p><strong>Queries lentas rompen UX.</strong></p>

                <p>Antipatr√≥n: N+1 Queries</p>
                <pre><code>// ‚ùå Lento: 1 query por usuario
const users = await db.query("SELECT * FROM users");
for (const user of users) {
  const orders = await db.query(`SELECT * FROM orders WHERE user_id = ${user.id}`);
  // Si hay 1000 usuarios, 1000 queries!!!
}</code></pre>

                <p>Soluci√≥n: JOIN o eager loading</p>
                <pre><code>// ‚úÖ R√°pido: 1 sola query
const users = await prisma.user.findMany({
  include: { orders: true }, // Carga √≥rdenes de una vez
});</code></pre>

                <p><strong>Analiza queries:</strong></p>
                <pre><code>EXPLAIN ANALYZE SELECT * FROM orders WHERE user_id = 45;</code></pre>
                <p>Te muestra si usa √≠ndices, cu√°ntas filas escanea, tiempo estimado.</p>

                <h2>üîü Schema Design: Ejemplo Real (Blog)</h2>

                <pre><code>CREATE TABLE users (
  id INT PRIMARY KEY AUTO_INCREMENT,
  username VARCHAR(255) UNIQUE NOT NULL,
  email VARCHAR(255) UNIQUE NOT NULL,
  password_hash VARCHAR(255) NOT NULL,
  bio TEXT,
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE posts (
  id INT PRIMARY KEY AUTO_INCREMENT,
  user_id INT NOT NULL,
  title VARCHAR(255) NOT NULL,
  content TEXT NOT NULL,
  published_at TIMESTAMP,
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
);

CREATE TABLE comments (
  id INT PRIMARY KEY AUTO_INCREMENT,
  post_id INT NOT NULL,
  user_id INT NOT NULL,
  content TEXT NOT NULL,
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  FOREIGN KEY (post_id) REFERENCES posts(id) ON DELETE CASCADE,
  FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
);

CREATE TABLE tags (
  id INT PRIMARY KEY AUTO_INCREMENT,
  name VARCHAR(255) UNIQUE NOT NULL
);

CREATE TABLE post_tags (
  post_id INT NOT NULL,
  tag_id INT NOT NULL,
  PRIMARY KEY (post_id, tag_id),
  FOREIGN KEY (post_id) REFERENCES posts(id) ON DELETE CASCADE,
  FOREIGN KEY (tag_id) REFERENCES tags(id) ON DELETE CASCADE
);

-- √çndices para queries r√°pidas
CREATE INDEX idx_posts_user_id ON posts(user_id);
CREATE INDEX idx_posts_published_at ON posts(published_at);
CREATE INDEX idx_comments_post_id ON comments(post_id);
CREATE INDEX idx_comments_user_id ON comments(user_id);</code></pre>

                <h2>1Ô∏è‚É£1Ô∏è‚É£ Checklist Senior</h2>

                <ul>
                    <li>‚úÖ Esquema normalizado (sin denormalizaci√≥n prematura)</li>
                    <li>‚úÖ Primary keys en todas partes</li>
                    <li>‚úÖ Foreign keys con ON DELETE CASCADE/SET NULL</li>
                    <li>‚úÖ √çndices en WHERE, JOIN, ORDER BY</li>
                    <li>‚úÖ Constraints (NOT NULL, UNIQUE, CHECK)</li>
                    <li>‚úÖ Migrations en git, versionadas</li>
                    <li>‚úÖ ORM para seguridad y type-safety</li>
                    <li>‚úÖ Transacciones para operaciones cr√≠ticas</li>
                    <li>‚úÖ EXPLAIN ANALYZE antes de lanzar</li>
                    <li>‚úÖ Backup strategy (diario, con test de restore)</li>
                </ul>

                <h2>1Ô∏è‚É£2Ô∏è‚É£ Una Frase para Recordar</h2>

                <p><strong>"Una BD bien dise√±ada es invisible; una mal dise√±ada, infernal. Invierte tiempo ahora o paga deuda t√©cnica por siempre."</strong></p>

                <div class="navigation-buttons">
                    <button class="btn btn-secondary" onclick="window.location.href='05-api-business-logic.html'">‚Üê Anterior</button>
                    <button class="btn btn-primary" onclick="window.location.href='07-mvc-architecture.html'">Siguiente: MVC Architecture ‚Üí</button>
                </div>
            </section>
        </main>
    </div>

    <script src="../../../assets/js/app.js"></script>
</body>
</html>
