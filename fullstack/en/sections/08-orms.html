<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ORMs - Object Relational Mapper | FullStack</title>
    <link rel="stylesheet" href="../../../assets/css/styles.css">
</head>
<body>
    <div class="container">
        <main class="main-content">
            <section id="section-orms">
                <h1>2.4 ORMs: Object Relational Mapper</h1>
                <p><strong>An ORM doesn't replace SQL. An ORM standardizes data access and a good developer knows when to trust it and when to go down to SQL level.</strong></p>

                <h2>0Ô∏è‚É£ The Problem We Want to Solve</h2>

                <p>Imagine you're building an API in Node.js with a SQL database.</p>

                <p><strong>Without ORM you'd have something like this:</strong></p>

                <pre><code>await db.query(
  "INSERT INTO movies (title, year) VALUES ($1, $2)",
  ["Inception", 2010]
);</code></pre>

                <p>That's fine‚Ä¶ until:</p>
                <ul>
                    <li>You have 30 tables</li>
                    <li>200 queries</li>
                    <li>You change the schema</li>
                    <li>You need complex joins</li>
                    <li>Someone makes a mistake in a query</li>
                </ul>

                <p><strong>This is where ORM comes in.</strong></p>

                <h2>1Ô∏è‚É£ What is an ORM Really?</h2>

                <p><strong>ORM = Object-Relational Mapper</strong></p>

                <p>It's a layer that:</p>
                <ul>
                    <li>Translates classes and objects to SQL tables</li>
                    <li>Translates methods (find, save, delete) to SQL queries</li>
                    <li>Manages schema through migrations</li>
                </ul>

                <h3>Key Mental Mapping</h3>

                <table class="cheat-sheet-table">
                    <thead>
                        <tr>
                            <th>Code (Object)</th>
                            <th>Database</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>Class</td>
                            <td>Table</td>
                        </tr>
                        <tr>
                            <td>Property</td>
                            <td>Column</td>
                        </tr>
                        <tr>
                            <td>Instance</td>
                            <td>Row</td>
                        </tr>
                    </tbody>
                </table>

                <h2>2Ô∏è‚É£ Real Example with TypeORM (Data Mapper Pattern)</h2>

                <h3>2.1 Define an Entity</h3>

                <pre><code>import { Entity, PrimaryGeneratedColumn, Column, CreateDateColumn } from "typeorm";

@Entity("movies")
export class Movie {
  @PrimaryGeneratedColumn()
  id!: number;

  @Column({ type: "varchar", length: 200 })
  title!: string;

  @Column({ type: "int", nullable: true })
  year?: number;

  @CreateDateColumn()
  createdAt!: Date;
}</code></pre>

                <p><strong>üëâ This will generate a movies table with those columns.</strong></p>

                <h3>2.2 CRUD Using Repository</h3>

                <pre><code>import { AppDataSource } from "./data-source";
import { Movie } from "./entities/Movie";

const repo = AppDataSource.getRepository(Movie);

// CREATE
await repo.save({ title: "Inception", year: 2010 });

// READ
const movies = await repo.find({ where: { year: 2010 } });

// UPDATE
await repo.update({ title: "Inception" }, { year: 2011 });

// DELETE
await repo.delete({ title: "Inception" });</code></pre>

                <p><strong>What happens underneath?</strong></p>

                <p>The ORM translates this to:</p>

                <pre><code>INSERT INTO movies (title, year) VALUES ('Inception', 2010);</code></pre>

                <p><strong>But:</strong></p>
                <ul>
                    <li>‚úÖ Parameterized</li>
                    <li>‚úÖ Safe against SQL injection</li>
                    <li>‚úÖ Typed with TypeScript</li>
                </ul>

                <h2>3Ô∏è‚É£ Migrations ‚Äì Versioning the Schema</h2>

                <p><strong>In real projects, the schema changes.</strong></p>

                <p><strong>Example:</strong> We add a rating column</p>

                <p>We don't modify the database manually. We generate a migration.</p>

                <pre><code>typeorm migration:generate -n AddRatingToMovie</code></pre>

                <p>Something like this gets generated:</p>

                <pre><code>await queryRunner.addColumn(
  "movies",
  new TableColumn({
    name: "rating",
    type: "int",
    isNullable: true,
  })
);</code></pre>

                <p>Then we run:</p>

                <pre><code>typeorm migration:run</code></pre>

                <p><strong>Why is this professional?</strong></p>
                <ul>
                    <li>‚úÖ Versions changes</li>
                    <li>‚úÖ Allows rollback</li>
                    <li>‚úÖ Works the same in dev, staging, and production</li>
                    <li>‚úÖ Avoids "it works on my machine"</li>
                </ul>

                <h2>4Ô∏è‚É£ Active Record vs Data Mapper</h2>

                <p><strong>There are two main patterns in ORM.</strong></p>

                <h3>üîπ Active Record</h3>

                <p>The model has its own methods.</p>

                <pre><code>const movie = new Movie();
movie.title = "Inception";
await movie.save();</code></pre>

                <p><strong>Pros:</strong></p>
                <ul>
                    <li>‚úÖ Very simple</li>
                    <li>‚úÖ Good for small projects</li>
                </ul>

                <p><strong>Cons:</strong></p>
                <ul>
                    <li>‚ùå Mixes business logic and persistence</li>
                    <li>‚ùå Scales poorly in large projects</li>
                </ul>

                <h3>üîπ Data Mapper (Repository Pattern)</h3>

                <p>You separate entity and persistence.</p>

                <pre><code>const repo = dataSource.getRepository(Movie);
await repo.save(movie);</code></pre>

                <p><strong>Pros:</strong></p>
                <ul>
                    <li>‚úÖ Cleaner architecture</li>
                    <li>‚úÖ More testable</li>
                    <li>‚úÖ Scales better</li>
                </ul>

                <p><strong>Cons:</strong></p>
                <ul>
                    <li>‚ùå A bit more boilerplate</li>
                </ul>

                <p><strong>üëâ In professional applications, Data Mapper is usually preferred.</strong></p>

                <h2>5Ô∏è‚É£ Relationships Between Entities</h2>

                <p><strong>Example: A movie has many comments.</strong></p>

                <pre><code>@Entity()
export class Comment {
  @PrimaryGeneratedColumn()
  id!: number;

  @Column()
  text!: string;

  @ManyToOne(() => Movie, movie => movie.comments)
  movie!: Movie;
}

@Entity()
export class Movie {
  @OneToMany(() => Comment, comment => comment.movie)
  comments!: Comment[];
}</code></pre>

                <p>Now you can make relational queries naturally.</p>

                <h2>6Ô∏è‚É£ Real Problems with ORMs (This Makes You Senior)</h2>

                <p><strong>This is where many juniors fail.</strong></p>

                <h3>6.1 The N+1 Problem</h3>

                <p><strong>Code:</strong></p>

                <pre><code>const movies = await repo.find();
for (const movie of movies) {
  console.log(movie.comments);
}</code></pre>

                <p><strong>This can generate:</strong></p>
                <ul>
                    <li>1 query for movies</li>
                    <li>1 query per movie for comments</li>
                </ul>

                <p><strong>Result: üëâ 1 + N queries (inefficient)</strong></p>

                <p><strong>Solution:</strong></p>

                <pre><code>// Eager loading
const movies = await repo.find({
  relations: ["comments"]
});

// Or with Query Builder
const movies = await repo
  .createQueryBuilder("movie")
  .leftJoinAndSelect("movie.comments", "comment")
  .getMany();</code></pre>

                <h3>6.2 Performance</h3>

                <p><strong>ORMs can generate complex and poorly optimized queries.</strong></p>

                <p><strong>Senior rules:</strong></p>
                <ul>
                    <li>‚úÖ Enable query logging</li>
                    <li>‚úÖ Analyze execution plan</li>
                    <li>‚úÖ Use indexes</li>
                    <li>‚úÖ Use manual SQL when necessary</li>
                </ul>

                <h3>6.3 Transactions</h3>

                <p><strong>Example:</strong></p>
                <ul>
                    <li>Create Order</li>
                    <li>Create OrderItems</li>
                    <li>Reduce stock</li>
                </ul>

                <p><strong>Everything must go inside a transaction:</strong></p>

                <pre><code>await dataSource.transaction(async manager => {
  await manager.save(order);
  await manager.save(orderItems);
  await manager.update(Product, { id: productId }, { stock });
});

// If something fails:
// üëâ automatic rollback</code></pre>

                <h2>7Ô∏è‚É£ Real Advantages of Using ORM</h2>

                <ul>
                    <li>‚úÖ Productivity</li>
                    <li>‚úÖ Security (parameterized queries)</li>
                    <li>‚úÖ Strong typing with TypeScript</li>
                    <li>‚úÖ Migrations</li>
                    <li>‚úÖ Easier testing</li>
                    <li>‚úÖ Fewer human errors</li>
                </ul>

                <h2>8Ô∏è‚É£ Real Disadvantages</h2>

                <ul>
                    <li>‚ùå Can hide how SQL works</li>
                    <li>‚ùå N+1 problem</li>
                    <li>‚ùå Suboptimal queries</li>
                    <li>‚ùå Learning curve</li>
                    <li>‚ùå Sometimes you need raw SQL</li>
                </ul>

                <h2>9Ô∏è‚É£ When NOT to Use ORM?</h2>

                <ul>
                    <li>‚ùå Extremely optimized queries</li>
                    <li>‚ùå Complex reporting</li>
                    <li>‚ùå Very simple microservices</li>
                    <li>‚ùå High load with very specific queries</li>
                </ul>

                <p><strong>In those cases: üëâ Query builder or raw SQL</strong></p>

                <h2>üîü Recommended Architecture in Modern Backend</h2>

                <p><strong>In a professional backend:</strong></p>

                <pre><code>Controller ‚Üí Service ‚Üí Repository (ORM) ‚Üí Database</code></pre>

                <ul>
                    <li><strong>Controller:</strong> HTTP</li>
                    <li><strong>Service:</strong> business logic</li>
                    <li><strong>Repository:</strong> persistence</li>
                    <li><strong>DB:</strong> storage</li>
                </ul>

                <p><strong>Never mix everything in the model.</strong></p>

                <h2>1Ô∏è‚É£1Ô∏è‚É£ Typical Interview Questions</h2>

                <h3>What is an ORM?</h3>

                <p>A layer that maps objects from the language to SQL tables and translates operations to parameterized queries.</p>

                <h3>Pros and Cons</h3>

                <p>Productivity and security vs loss of control and possible performance problems.</p>

                <h3>Active Record vs Data Mapper</h3>

                <p>Active Record mixes data and persistence. Data Mapper separates concerns and scales better.</p>

                <h3>Do I Need to Know SQL?</h3>

                <p><strong>Yes. Always.</strong></p>

                <h2>1Ô∏è‚É£2Ô∏è‚É£ Senior Checklist</h2>

                <ul>
                    <li>‚úÖ Separate entities (models) from repositories</li>
                    <li>‚úÖ Use Data Mapper, not Active Record</li>
                    <li>‚úÖ Avoid N+1 queries with eager loading</li>
                    <li>‚úÖ Generate migrations, not manual changes</li>
                    <li>‚úÖ Understand when NOT to use ORM</li>
                    <li>‚úÖ Know how to write SQL when you need it</li>
                    <li>‚úÖ Monitor performance with EXPLAIN ANALYZE</li>
                    <li>‚úÖ Use transactions for critical operations</li>
                    <li>‚úÖ Test repositories without real database</li>
                    <li>‚úÖ Document complex relationships</li>
                </ul>

                <h2>1Ô∏è‚É£3Ô∏è‚É£ One Phrase to Remember</h2>

                <p><strong>"An ORM saves you 80% of the work. The remaining 20% is learning when NOT to trust it and write pure SQL."</strong></p>

                <h2>üìö References and Resources</h2>

                <p><strong>To learn more:</strong></p>

                <ul>
                    <li><a href="https://chatgpt.com/g/g-p-69925f6597e88191b8bcb93447c5bb78-dragos/c/6994d9ab-d640-838e-8944-3a54f76c16c2" target="_blank">Dragos - ORMs & Object Relational Mapping Patterns</a></li>
                </ul>

                <div class="navigation-buttons">
                    <button class="btn btn-secondary" onclick="window.location.href='07-mvc-architecture.html'">‚Üê Previous</button>
                    <button class="btn btn-primary" onclick="window.location.href='08-1-migrations.html'">Next: Migrations ‚Üí</button>
                </div>
            </section>
        </main>
    </div>

    <script src="../../../assets/js/app.js"></script>
</body>
</html>
