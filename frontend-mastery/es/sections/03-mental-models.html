<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>2. Modelos Mentales - Frontend Mastery</title>
    <link rel="stylesheet" href="../../../assets/css/styles.css">
</head>
<body>
    <div class="container">
        <main class="main-content">
            <section id="section-mental-models">
                <h1>2. Evoluci√≥n a Modelos Mentales Modernos</h1>

                <div class="problem-block" data-title="La Era Pre-Framework: Manipulaci√≥n Manual del DOM">
                    <p>El desarrollo tradicional con JavaScript puro (o jQuery) requer√≠a manipular directamente el DOM. Este enfoque presentaba desaf√≠os cr√≠ticos:</p>
                    <ul>
                        <li><strong>Complejidad a Escala:</strong> El c√≥digo para mantener la UI sincronizada con los datos se volv√≠a inmanejable.</li>
                        <li><strong>Conflictos y Errores:</strong> El scope global compartido generaba conflictos y comportamientos impredecibles.</li>
                        <li><strong>Nula Reutilizaci√≥n:</strong> El c√≥digo estaba fuertemente acoplado a la estructura del HTML, haciendo dif√≠cil su reutilizaci√≥n.</li>
                    </ul>
                </div>

                <div class="solution-block" data-title="La Revoluci√≥n de los Componentes: Aplicando Principios OOP">
                    <p>Los frameworks modernos aplicaron conceptos clave de la Programaci√≥n Orientada a Objetos para resolver estos problemas. El cambio fundamental es pensar en la UI como un conjunto de 'piezas de Lego' (componentes) en lugar de una gran p√°gina.</p>
                    <ul>
                        <li><strong>Aislamiento:</strong> Un componente de formulario no interfiere con un componente de navegaci√≥n.</li>
                        <li><strong>Encapsulaci√≥n:</strong> Cada componente maneja su propia l√≥gica, estado y estilos.</li>
                        <li><strong>Reutilizaci√≥n:</strong> Un componente 'Bot√≥n' se puede usar en toda la aplicaci√≥n con diferentes textos y acciones.</li>
                    </ul>
                </div>

                <h2>Cambios Clave de Paradigma</h2>

                <div class="concept-block">
                    <h4>Programaci√≥n Declarativa con JSX</h4>
                    <p>En lugar de escribir instrucciones paso a paso (imperativo), ahora simplemente declaramos c√≥mo deber√≠a verse la UI en funci√≥n del estado actual. El framework se encarga del 'c√≥mo'.</p>
                    <div class="code-block">
<pre><code class="language-jsx">// Enfoque Declarativo con React
const UserList = ({ users, isLoading }) => {
  if (isLoading) return &lt;div&gt;Cargando...&lt;/div&gt;;
  return (
    &lt;ul&gt;
      {users.map(user => (
        &lt;li key={user.id}&gt;{user.name}&lt;/li&gt;
      ))}
    &lt;/ul&gt;
  );
};</code></pre>
                    </div>
                </div>

                <div class="concept-block">
                    <h4>Data Binding Unidireccional</h4>
                    <p>React introduce un flujo unidireccional de datos: Props descienden del padre al hijo, eventos ascienden del hijo al padre. Esto predecible facilita el debugging.</p>
                    <div class="code-block">
<pre><code class="language-jsx">// Componente Padre
const App = () => {
  const [count, setCount] = React.useState(0);

  return &lt;Counter value={count} onChange={setCount} /&gt;;
};

// Componente Hijo
const Counter = ({ value, onChange }) => (
  &lt;button onClick={() => onChange(value + 1)}&gt;
    Count: {value}
  &lt;/button&gt;
);</code></pre>
                    </div>
                </div>

                <div class="analogy-block" data-title="üí° Analog√≠a: Del Tablero de Ajedrez a las Piezas">
                    <p>Si jQuery es like un tablero de ajedrez donde debes mover cada pieza manualmente (imperativo), React es como decir: "Tengo 16 piezas en posici√≥n inicial" y React se encarga de colocarlas (declarativo). Cambias el estado de las piezas, y React actualiza el tablero autom√°ticamente.</p>
                </div>

                <div class="warning-block" data-title="‚ö†Ô∏è Consejo Senior">
                    <p>Muchos desarrolladores entienden React pero no entienden <strong>por qu√©</strong> es mejor que jQuery. La raz√≥n: predecibilidad. Con React, dado el mismo estado, siempre obtienes la misma UI. Con jQuery, todo depende del orden de las acciones, los efectos secundarios y los conflictos globales.</p>
                </div>

                <div class="nav-buttons">
                    <button class="btn btn-primary" onclick="window.location.href='02-frameworks.html'">‚Üê Anterior</button>
                    <button class="btn btn-primary" onclick="window.location.href='04-state-machine.html'">Siguiente ‚Üí</button>
                </div>
            </section>
        </main>
    </div>

    <script src="../../../assets/js/app.js"></script>
</body>
</html>
