<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Framework Optimizations | Frontend Mastery</title>
    <link rel="stylesheet" href="../../../assets/css/styles.css">
</head>
<body>
    <div class="container">
        <aside id="sidebar" class="sidebar"></aside>
        <main class="main-content">
            <section class="content-section">
                <h1>‚öõÔ∏è Framework Optimizations</h1>
                <p class="section-description">C√≥mo eliminar renders innecesarios y hacer tu app m√°s r√°pida</p>

                <!-- PROBLEMA REAL -->
                <div class="problem-block" data-title="1Ô∏è‚É£ El Problema Real">
                    <p>En React moderno, el mayor problema de rendimiento no suele ser el DOM.</p>
                    <p>Es esto:</p>
                    <ul>
                        <li>üî• Demasiados renders innecesarios</li>
                        <li>üî• Renders demasiado costosos</li>
                        <li>üî• Actualizaciones que afectan a m√°s componentes de los necesarios</li>
                    </ul>
                    <p><strong>Cuando escribes en un input y se iluminan 20 componentes en DevTools‚Ä¶ algo est√° mal.</strong></p>
                </div>

                <!-- MENTALIDAD SENIOR -->
                <h2>2Ô∏è‚É£ Mentalidad Senior: Siempre Diagn√≥stico Primero</h2>

                <div class="analogy-block" data-title="Antes de optimizar, mide">
                    <p>Antes de usar memo, useMemo o useCallback, haz esto:</p>
                </div>

                <h3>Paso 1 ‚Äî Activa Highlight Updates</h3>
                <div class="solution-block">
                    <ol>
                        <li>React DevTools ‚Üí Settings</li>
                        <li>Highlight updates when components render</li>
                        <li>Escribe en un input</li>
                        <li>¬øSe iluminan cosas que no deber√≠an?</li>
                    </ol>
                    <p>üëâ Si s√≠, hay renders innecesarios.</p>
                </div>

                <h3>Paso 2 ‚Äî Usa el Profiler</h3>
                <div class="solution-block">
                    <ol>
                        <li>React DevTools ‚Üí Profiler ‚Üí Record</li>
                        <li>Haz una interacci√≥n (escribir, cambiar tema, etc.)</li>
                        <li>Mira:
                            <ul>
                                <li>Qu√© componente tarda m√°s</li>
                                <li>Qu√© componente se renderiza m√°s veces</li>
                                <li>Qu√© dispar√≥ el render (state, props, context)</li>
                            </ul>
                        </li>
                    </ol>
                    <p><strong>üéØ Nunca optimices sin profiler.</strong></p>
                </div>

                <!-- POR QU√â SE RENDERIZA -->
                <h2>3Ô∏è‚É£ ¬øPor qu√© se renderiza un componente?</h2>

                <div class="concept-block">
                    <p>Un componente se renderiza cuando:</p>
                    <ul>
                        <li>Cambia su state</li>
                        <li>Cambian sus props</li>
                        <li>Cambia su contexto</li>
                        <li>Cambia alg√∫n hook que depende de algo nuevo</li>
                    </ul>
                    <p><strong>Si un padre renderiza, sus hijos tambi√©n renderizan.</strong></p>
                    <p><strong>Ese es el origen del problema.</strong></p>
                </div>

                <!-- ESTRATEGIA 1 -->
                <h2>4Ô∏è‚É£ Estrategia #1 ‚Äî Reducir Renders (Lo M√°s Importante)</h2>

                <div class="warning-block" data-title="Antes de memoizar nada">
                    <p>Haz esto primero.</p>
                </div>

                <h3>üîπ Regla de Oro: Baja el State lo M√°ximo Posible</h3>

                <div class="problem-block" data-title="‚ùå Incorrecto">
                    <pre><code>function Page() {
  const [query, setQuery] = useState("");

  return (
    &lt;&gt;
      &lt;Header /&gt;
      &lt;Search value={query} onChange={setQuery} /&gt;
      &lt;BigList query={query} /&gt;
      &lt;Sidebar /&gt;
    &lt;/&gt;
  );
}</code></pre>
                    <p><strong>Cada vez que escribes:</strong></p>
                    <ul>
                        <li>Page renderiza</li>
                        <li>Header renderiza</li>
                        <li>Sidebar renderiza</li>
                        <li>BigList renderiza</li>
                    </ul>
                    <p>¬øTiene sentido que Sidebar cambie al escribir? No.</p>
                </div>

                <div class="solution-block" data-title="‚úÖ Mejor">
                    <pre><code>function Page() {
  return (
    &lt;&gt;
      &lt;Header /&gt;
      &lt;Sidebar /&gt;
      &lt;SearchSection /&gt;
    &lt;/&gt;
  );
}

function SearchSection() {
  const [query, setQuery] = useState("");

  return (
    &lt;&gt;
      &lt;Search value={query} onChange={setQuery} /&gt;
      &lt;BigList query={query} /&gt;
    &lt;/&gt;
  );
}</code></pre>
                    <p><strong>üéØ Ahora solo el sub√°rbol necesario renderiza.</strong></p>
                </div>

                <!-- ESTRATEGIA 2 -->
                <h2>5Ô∏è‚É£ Estrategia #2 ‚Äî React.memo (Eliminar renders innecesarios)</h2>

                <div class="concept-block">
                    <p>React.memo evita que un componente renderice si sus props no cambian.</p>
                </div>

                <h3>Ejemplo</h3>
                <div class="solution-block">
                    <pre><code>const Card = React.memo(function Card({ title }) {
  console.log("Card render");
  return &lt;h2&gt;{title}&lt;/h2&gt;;
});


// Si el padre renderiza pero title no cambia:
// üëâ Card NO renderiza.</code></pre>
                </div>

                <h3>‚ö†Ô∏è Problema Cl√°sico</h3>
                <div class="problem-block">
                    <p>Esto rompe memo:</p>
                    <pre><code>&lt;Card title="Hola" style={{ marginTop: 10 }} /&gt;</code></pre>
                    <p><strong>Por qu√©:</strong></p>
                    <ul>
                        <li>Cada render crea un nuevo objeto style</li>
                        <li>React.memo compara props por referencia</li>
                        <li>Nuevo objeto = nueva referencia = render</li>
                    </ul>
                </div>

                <!-- ESTRATEGIA 3 -->
                <h2>6Ô∏è‚É£ Estrategia #3 ‚Äî useCallback (Memorizar Funciones)</h2>

                <div class="concept-block">
                    <p>Las funciones inline cambian de referencia en cada render.</p>
                </div>

                <h3>‚ùå Problema</h3>
                <div class="problem-block">
                    <pre><code>&lt;Item onClick={() => setSelected(id)} /&gt;


// Nueva funci√≥n en cada render ‚Üí hijo renderiza.</code></pre>
                </div>

                <h3>‚úÖ Soluci√≥n</h3>
                <div class="solution-block">
                    <pre><code>const handleClick = useCallback((id) => {
  setSelected(id);
}, []);

&lt;Item onClick={handleClick} /&gt;


// Ahora la funci√≥n es estable.</code></pre>
                </div>

                <h3>‚ö†Ô∏è Dependencias</h3>
                <div class="warning-block">
                    <p>Si usas variables externas:</p>
                    <pre><code>const handleClick = useCallback(() => {
  doSomething(value);
}, [value]);


// Siempre incluye dependencias correctas.</code></pre>
                </div>

                <!-- ESTRATEGIA 4 -->
                <h2>7Ô∏è‚É£ Estrategia #4 ‚Äî useMemo (Memorizar Valores)</h2>

                <div class="concept-block">
                    <p>Sirve para:</p>
                    <ul>
                        <li>Evitar c√°lculos costosos repetidos</li>
                        <li>Mantener referencias estables</li>
                    </ul>
                </div>

                <h3>Caso Real: Filtrar lista grande</h3>
                <div class="solution-block">
                    <pre><code>const filtered = useMemo(() => {
  return items.filter(item =>
    item.name.includes(query)
  );
}, [items, query]);


// Sin useMemo:
// Se recalcula en cada render.

// Con useMemo:
// Solo cuando cambian items o query.</code></pre>
                </div>

                <h3>‚ö†Ô∏è Regla Importante</h3>
                <div class="warning-block">
                    <p>No uses useMemo para todo.</p>
                    <p><strong>Si el c√°lculo es barato, no lo uses.</strong></p>
                </div>

                <!-- CONTEXT -->
                <h2>8Ô∏è‚É£ Context: El Gran Disparador de Renders</h2>

                <div class="problem-block" data-title="Cuando cambia el value de un Provider">
                    <p>üëâ TODOS los consumidores se renderizan.</p>
                </div>

                <h3>‚ùå Anti-pattern</h3>
                <div class="problem-block">
                    <pre><code>&lt;AppContext.Provider value={{ theme, user, cart }}&gt;
  ...
&lt;/AppContext.Provider&gt;


// Cambiar cart ‚Üí todos los componentes que usan theme
// renderizan tambi√©n.</code></pre>
                </div>

                <h3>‚úÖ Mejor</h3>
                <div class="solution-block">
                    <p>Separar contextos:</p>
                    <ul>
                        <li>ThemeContext</li>
                        <li>UserContext</li>
                        <li>CartContext</li>
                    </ul>
                    <p><strong>Reduce explosi√≥n de renders.</strong></p>
                </div>

                <!-- DIFERENCIA CLAVE -->
                <h2>9Ô∏è‚É£ Diferencia Clave: Evitar Render vs Hacerlo M√°s R√°pido</h2>

                <div class="concept-block">
                    <p>Hay dos tipos de optimizaci√≥n:</p>
                    <h3>1Ô∏è‚É£ Evitar renders</h3>
                    <ul>
                        <li>Bajar state</li>
                        <li>Dividir √°rbol</li>
                        <li>React.memo</li>
                    </ul>
                    <p>üëâ <strong>Esto suele tener m√°s impacto.</strong></p>

                    <h3>2Ô∏è‚É£ Hacer renders m√°s r√°pidos</h3>
                    <ul>
                        <li>useMemo</li>
                        <li>useCallback</li>
                    </ul>
                    <p>üëâ <strong>Menos impacto, m√°s complejidad.</strong></p>
                    <p>Por eso es el √∫ltimo paso.</p>
                </div>

                <!-- CASO PR√ÅCTICO -->
                <h2>üîü Caso Pr√°ctico Completo</h2>

                <h3>‚ùå Antes</h3>
                <div class="problem-block">
                    <pre><code>function Page({ items }) {
  const [query, setQuery] = useState("");

  return (
    &lt;div&gt;
      &lt;input
        value={query}
        onChange={(e) => setQuery(e.target.value)}
      /&gt;
      &lt;BigList items={items} /&gt;
    &lt;/div&gt;
  );
}


// BigList renderiza cada vez que escribes.</code></pre>
                </div>

                <h3>‚úÖ Despu√©s</h3>
                <div class="solution-block">
                    <pre><code>const BigList = React.memo(function BigList({ items }) {
  return items.map(item => (
    &lt;Row key={item.id} item={item} /&gt;
  ));
});

function Page({ items }) {
  const [query, setQuery] = useState("");

  const filtered = useMemo(() => {
    return items.filter(item =>
      item.name.includes(query)
    );
  }, [items, query]);

  const handleChange = useCallback((e) => {
    setQuery(e.target.value);
  }, []);

  return (
    &lt;div&gt;
      &lt;input value={query} onChange={handleChange} /&gt;
      &lt;BigList items={filtered} /&gt;
    &lt;/div&gt;
  );
}</code></pre>
                </div>

                <!-- √ÅRBOL DE DECISI√ìN -->
                <h2>üß† √Årbol de Decisi√≥n Senior</h2>

                <div class="concept-block">
                    <p><strong>Cuando algo va lento:</strong></p>
                    <ol>
                        <li><strong>¬øQu√© dice el profiler?</strong></li>
                        <li>¬øHay renders innecesarios?
                            <ul>
                                <li>‚Üí Baja state</li>
                                <li>‚Üí Divide √°rbol</li>
                            </ul>
                        </li>
                        <li>¬øSigue renderizando sin necesidad?
                            <ul>
                                <li>‚Üí React.memo</li>
                            </ul>
                        </li>
                        <li>¬øProps cambian por referencia?
                            <ul>
                                <li>‚Üí useCallback / useMemo</li>
                            </ul>
                        </li>
                        <li>¬øLista enorme?
                            <ul>
                                <li>‚Üí Virtualizaci√≥n</li>
                            </ul>
                        </li>
                    </ol>
                </div>

                <!-- ERRORES COMUNES -->
                <h2>‚ö†Ô∏è Errores Comunes</h2>

                <div class="warning-block">
                    <ul>
                        <li>‚ùå Usar useMemo para todo</li>
                        <li>‚ùå Usar useCallback en cada funci√≥n</li>
                        <li>‚ùå Meter todo en un solo Context</li>
                        <li>‚ùå Optimizar sin medir</li>
                        <li>‚ùå Romper deps del hook</li>
                    </ul>
                </div>

                <!-- CU√ÅNDO TIENE SENTIDO -->
                <h2>üéØ Cu√°ndo Tiene Mucho Sentido Optimizar</h2>

                <div class="solution-block">
                    <ul>
                        <li>Drag & Drop tipo Google Sheets</li>
                        <li>Dashboard con muchas tablas</li>
                        <li>Gr√°ficos pesados</li>
                        <li>Listas enormes</li>
                        <li>Apps tipo Figma, Notion, Trello</li>
                    </ul>
                    <p><strong>En una app t√≠pica CRUD peque√±a, no hace falta tanto.</strong></p>
                </div>

                <!-- ENTREVISTA -->
                <div class="interview-block">
                    <div class="interview-title">
                        <span>üìå Frase de Entrevista Senior</span>
                        <span class="toggle-arrow">‚ñ∂</span>
                    </div>
                    <div class="interview-content">
                        <blockquote>
                            <p>"Primero mido con el profiler. Despu√©s reduzco el radio de renders moviendo el state y dividiendo context. Luego uso React.memo y estabilizo props con useCallback/useMemo solo si el profiler demuestra que es necesario."</p>
                        </blockquote>
                    </div>
                </div>

                <!-- EJERCICIOS -->
                <h2>üß™ Ejercicios Pr√°cticos</h2>

                <div class="interview-block">
                    <div class="interview-title">
                        <span>üí™ Ejercicio 1</span>
                        <span class="toggle-arrow">‚ñ∂</span>
                    </div>
                    <div class="interview-content">
                        <p><strong>Crea un input que renderice 20 cards.</strong></p>
                        <p>Optimiza hasta que solo rendericen cuando cambien sus props.</p>
                        <p>Usa: bajar state, React.memo, y stabilizar props.</p>
                    </div>
                </div>

                <div class="interview-block">
                    <div class="interview-title">
                        <span>üí™ Ejercicio 2</span>
                        <span class="toggle-arrow">‚ñ∂</span>
                    </div>
                    <div class="interview-content">
                        <p><strong>Crea un context con theme y cart.</strong></p>
                        <p>Divide el contexto en dos.</p>
                        <p>Mide la diferencia con React DevTools Profiler.</p>
                    </div>
                </div>

                <!-- RESUMEN -->
                <div class="concept-block">
                    <h2>üìö Resumen de Estrategias</h2>
                    <table style="width: 100%; border-collapse: collapse; margin-top: 15px;">
                        <tr style="border-bottom: 1px solid #ddd;">
                            <th style="padding: 10px; text-align: left;"><strong>Estrategia</strong></th>
                            <th style="padding: 10px; text-align: left;"><strong>Cu√°ndo</strong></th>
                            <th style="padding: 10px; text-align: left;"><strong>Impacto</strong></th>
                        </tr>
                        <tr style="border-bottom: 1px solid #ddd;">
                            <td style="padding: 10px;">Bajar state</td>
                            <td style="padding: 10px;">State no usado por todos</td>
                            <td style="padding: 10px;">üî• Alto</td>
                        </tr>
                        <tr style="border-bottom: 1px solid #ddd;">
                            <td style="padding: 10px;">Dividir √°rbol</td>
                            <td style="padding: 10px;">Subtree cambia frecuentemente</td>
                            <td style="padding: 10px;">üî• Alto</td>
                        </tr>
                        <tr style="border-bottom: 1px solid #ddd;">
                            <td style="padding: 10px;">React.memo</td>
                            <td style="padding: 10px;">Props no cambian frecuentemente</td>
                            <td style="padding: 10px;">‚ö° Medio</td>
                        </tr>
                        <tr style="border-bottom: 1px solid #ddd;">
                            <td style="padding: 10px;">useCallback</td>
                            <td style="padding: 10px;">Funciones se pasan a memo components</td>
                            <td style="padding: 10px;">‚ö° Medio</td>
                        </tr>
                        <tr style="border-bottom: 1px solid #ddd;">
                            <td style="padding: 10px;">useMemo</td>
                            <td style="padding: 10px;">C√°lculo costoso que se repite</td>
                            <td style="padding: 10px;">‚ö° Medio</td>
                        </tr>
                        <tr>
                            <td style="padding: 10px;">Separar contextos</td>
                            <td style="padding: 10px;">Context usado por pocos</td>
                            <td style="padding: 10px;">üî• Alto</td>
                        </tr>
                    </table>
                </div>

                <!-- REFERENCIAS -->
                <div class="solution-block">
                    <h3>üìö Referencias y Recursos</h3>
                    <ul>
                        <li><a href="https://chatgpt.com/g/g-p-69925f6597e88191b8bcb93447c5bb78-dragos/c/6993bd0b-b1d4-838d-b850-34c4d9771170" target="_blank">ChatGPT Dragos - React Performance Expert</a></li>
                    </ul>
                </div>

                <!-- NAVIGATION BUTTONS -->
                <div class="navigation-buttons">
                    <button class="btn btn-secondary" onclick="window.location.href='20-optimising-javascript-bundle.html'">‚Üê Anterior</button>
                    <button class="btn btn-primary" onclick="window.location.href='../../../index.html'">Volver al Inicio ‚Üí</button>
                </div>
            </section>
        </main>
    </div>

    <script src="../../../assets/js/app.js"></script>
</body>
</html>
