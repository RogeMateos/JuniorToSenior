<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Optimising the JavaScript Bundle | Frontend Mastery</title>
    <link rel="stylesheet" href="../../../assets/css/styles.css">
</head>
<body>
    <div class="container">
        <main class="main-content">
            <section class="content-section">
                <h1>üì¶ Optimising the JavaScript Bundle</h1>
                <p class="section-description">C√≥mo reducir JS y mejorar performance en SPAs reales</p>

                <!-- MENTAL MODEL -->
                <div class="analogy-block" data-title="Mental Model: El JavaScript pesa dos veces">
                    <p><strong>No es solo descargar.</strong></p>
                    <p>El JavaScript tiene dos costes:</p>
                    <ul>
                        <li><strong>üåê Network cost:</strong> KB/MB (comprimido) que se descarga</li>
                        <li><strong>‚öôÔ∏è CPU cost:</strong> parse ‚Üí compile ‚Üí execute en el main thread</li>
                    </ul>
                    <p>En SPAs, muchas veces la <strong>CPU (no la red) es el killer en m√≥viles.</strong></p>
                </div>

                <!-- OBJETIVO -->
                <div class="concept-block">
                    <h2>üéØ Objetivo del m√≥dulo</h2>
                    <p>Entender c√≥mo optimizar bundles reales y medir el impacto en:</p>
                    <ul>
                        <li>‚ö° JS inicial ‚â§ 300‚Äì500KB gzip (depende del producto)</li>
                        <li>üö´ Evitar long tasks (&gt;50ms) durante el primer render</li>
                        <li>üìä Mejorar LCP e INP</li>
                    </ul>
                </div>

                <!-- PASO 0 - DEFINE OBJETIVO -->
                <h2>üß™ Paso 0 ‚Äî Define el objetivo con m√©tricas (antes de tocar c√≥digo)</h2>

                <h3>Objetivo t√≠pico realista en SPA</h3>
                <div class="solution-block">
                    <ul>
                        <li><strong>JS inicial ‚â§ 300‚Äì500KB gzip</strong> (depende del producto)</li>
                        <li><strong>Evitar long tasks (&gt;50ms)</strong> durante el primer render</li>
                        <li><strong>Mejorar LCP e INP</strong></li>
                    </ul>
                </div>

                <h3>C√≥mo medir</h3>
                <div class="solution-block">
                    <ul>
                        <li><strong>Lighthouse</strong> (lab)</li>
                        <li><strong>DevTools ‚Üí Network</strong> (Disable cache) y Performance</li>
                        <li><strong>Web Vitals reales</strong> en producci√≥n (si puedes)</li>
                    </ul>
                    <p><strong>‚ö†Ô∏è Por qu√©:</strong> si no mides, optimizas "a ciegas" y puedes empeorar UX.</p>
                </div>

                <!-- PASO 1 - QU√â PESA -->
                <h2>üîç Paso 1 ‚Äî Encuentra "qu√© pesa" (no adivines)</h2>

                <h3>A) Bundle Analyzer</h3>
                <div class="solution-block">
                    <p>Herramientas seg√∫n tu stack:</p>
                    <ul>
                        <li><strong>Webpack:</strong> webpack-bundle-analyzer</li>
                        <li><strong>Vite/Rollup:</strong> rollup-plugin-visualizer</li>
                        <li><strong>Create React App:</strong> source-map-explorer</li>
                    </ul>
                    <p>Qu√© buscas:</p>
                    <ul>
                        <li>Librer√≠as enormes (moment, chart libs, editors, maps)</li>
                        <li>Duplicados (dos date libs, dos lodash-like)</li>
                        <li>Polyfills innecesarios</li>
                    </ul>
                    <p><strong>Realidad:</strong> el 80% del tama√±o suele venir de 20% de dependencias.</p>
                </div>

                <h3>B) DevTools ‚Üí Coverage</h3>
                <div class="solution-block">
                    <p>Te dice cu√°nto JS no se usa en la carga inicial.</p>
                    <ol>
                        <li>Abre DevTools</li>
                        <li>More Tools ‚Üí Coverage</li>
                        <li>Click Reload</li>
                        <li>Observa qu√© est√° en rojo</li>
                    </ol>
                    <p><strong>Rojo = no usado en la carga inicial</strong></p>
                    <p>Esto es oro para encontrar oportunidades de code splitting.</p>
                </div>

                <!-- PASO 2 - BUNDLE CLEANUP -->
                <h2>üßπ Paso 2 ‚Äî "Bundle Cleanup" (reduce lo que no aporta)</h2>

                <h3>Acciones t√≠picas</h3>
                <div class="solution-block">
                    <ul>
                        <li>Desinstala dependencias no usadas</li>
                        <li>Sustituye por alternativas m√°s ligeras</li>
                        <li>Cambia imports para que tree-shaking funcione</li>
                    </ul>
                </div>

                <h3>Ejemplo 1: Lodash (el cl√°sico error)</h3>
                <div class="problem-block" data-title="‚ùå Importa la librer√≠a entera">
                    <pre><code>import _ from "lodash";
const debounced = _.debounce(myFn, 300);</code></pre>
                    <p><strong>Problema:</strong> Te traes TODA la librer√≠a (~70KB).</p>
                </div>

                <div class="solution-block" data-title="‚úÖ Importa solo lo que necesitas">
                    <pre><code>import debounce from "lodash/debounce";
const debounced = debounce(myFn, 300);</code></pre>
                    <p><strong>Resultado:</strong> Solo ~10KB.</p>
                </div>

                <div class="concept-block">
                    <p><strong>O mejor a√∫n:</strong> si es simple, implementa t√∫ mismo.</p>
                    <pre><code>const debounce = (fn, ms) => {
  let timeout;
  return (...args) => {
    clearTimeout(timeout);
    timeout = setTimeout(() => fn(...args), ms);
  };
};</code></pre>
                    <p>0KB de dependencia.</p>
                </div>

                <h3>Ejemplo 2: Fechas (el otro error com√∫n)</h3>
                <div class="problem-block">
                    <p>Si solo necesitas formatear 1 fecha:</p>
                    <pre><code>// ‚ùå moment.js = 70KB
import moment from 'moment';
moment(date).format('DD/MM/YYYY');</code></pre>
                </div>

                <div class="solution-block">
                    <p>‚úÖ Alternativas m√°s ligeras o nativas:</p>
                    <pre><code>// Opci√≥n 1: Librer√≠a m√°s ligera (date-fns: ~15KB)
import { format } from 'date-fns';
format(date, 'dd/MM/yyyy');

// Opci√≥n 2: API nativa (si tu target lo permite)
new Intl.DateTimeFormat('es-ES').format(date);</code></pre>
                </div>

                <div class="warning-block" data-title="Por qu√© cada dependencia cuesta">
                    <ul>
                        <li><strong>Bytes:</strong> la librer√≠a ocupa KB</li>
                        <li><strong>Parse/execute:</strong> el navegador debe procesar ese c√≥digo</li>
                        <li><strong>Mantenimiento:</strong> riesgo de updates, breaking changes</li>
                        <li><strong>Build time:</strong> m√°s lento</li>
                    </ul>
                </div>

                <!-- PASO 3 - TREE SHAKING -->
                <h2>üå≥ Paso 3 ‚Äî Asegura Tree-Shaking + Build Production</h2>

                <div class="concept-block">
                    <h3>¬øQu√© es Tree-Shaking?</h3>
                    <p>El bundler elimina c√≥digo "muerto" (no importado).</p>
                    <p><strong>Funciona bien cuando:</strong></p>
                    <ul>
                        <li>Usas <strong>ESM imports</strong> (import { x } from 'lib')</li>
                        <li>El paquete est√° preparado (sideEffects: false)</li>
                        <li>El build es "production"</li>
                    </ul>
                </div>

                <h3>Checklist para habilitar Tree-Shaking</h3>
                <div class="solution-block">
                    <ul>
                        <li>‚òê Compilar en modo <strong>production</strong></li>
                        <li>‚òê Preferir librer√≠as <strong>ESM</strong></li>
                        <li>‚òê Evitar imports "barrel" que rompen tree-shaking</li>
                        <li>‚òê En paquetes propios: marcar <strong>"sideEffects": false</strong> cuando sea correcto</li>
                    </ul>
                </div>

                <h3>Ejemplo: Barrel imports (cuidado)</h3>
                <div class="problem-block">
                    <pre><code>// ‚ùå Puede traer todo aunque solo uses uno
import { Button } from './components';</code></pre>
                    <p>Depende de c√≥mo est√© escrito el archivo barrel.</p>
                </div>

                <div class="solution-block">
                    <pre><code>// ‚úÖ M√°s expl√≠cito (y seguro para tree-shaking)
import Button from './components/Button';</code></pre>
                </div>

                <!-- PASO 4 - CODE SPLITTING -->
                <h2>üéØ Paso 4 ‚Äî Code Splitting (el gran impacto)</h2>

                <div class="analogy-block" data-title="Mental Model: No cargues lo que no necesitas">
                    <p>Si el usuario est√° en /home, ¬øpor qu√© descargas el JS de /checkout?</p>
                    <p>Code splitting te permite cargar cada ruta como un archivo separado.</p>
                </div>

                <h3>4.1 Split por rutas (React)</h3>
                <div class="solution-block">
                    <pre><code>import { lazy, Suspense } from "react";
import { Routes, Route } from "react-router-dom";

const Home = lazy(() => import("./pages/Home"));
const Checkout = lazy(() => import("./pages/Checkout"));
const Dashboard = lazy(() => import("./pages/Dashboard"));

export function AppRoutes() {
  return (
    &lt;Suspense fallback={&lt;LoadingSpinner /&gt;}&gt;
      &lt;Routes&gt;
        &lt;Route path="/" element={&lt;Home /&gt;} /&gt;
        &lt;Route path="/checkout" element={&lt;Checkout /&gt;} /&gt;
        &lt;Route path="/dashboard" element={&lt;Dashboard /&gt;} /&gt;
      &lt;/Routes&gt;
    &lt;/Suspense&gt;
  );
}</code></pre>
                    <p><strong>Qu√© consigues:</strong> En / no descargas el JS de /checkout ni /dashboard.</p>
                    <p><strong>C√≥mo funciona:</strong> import() crea un chunk separado (Webpack/Rollup/Vite lo parten autom√°ticamente).</p>
                </div>

                <h3>4.2 Split por "feature pesada"</h3>
                <div class="solution-block">
                    <p>Ejemplos: editor, gr√°ficos, mapa, pdf viewer, etc.</p>
                    <pre><code>import { lazy, Suspense, useState } from "react";

const ChartPanel = lazy(() => import("./ChartPanel"));

function Dashboard() {
  const [showCharts, setShowCharts] = useState(false);

  return (
    &lt;&gt;
      &lt;button onClick={() => setShowCharts(true)}&gt;
        Ver gr√°ficos
      &lt;/button&gt;
      {showCharts && (
        &lt;Suspense fallback={&lt;div&gt;Cargando gr√°ficos...&lt;/div&gt;}&gt;
          &lt;ChartPanel /&gt;
        &lt;/Suspense&gt;
      )}
    &lt;/&gt;
  );
}</code></pre>
                    <p><strong>Ventaja:</strong> Si el usuario no abre esa feature, no pagas el coste.</p>
                </div>

                <h3>4.3 Prefetch / Preload inteligente</h3>
                <div class="concept-block">
                    <p>Una vez que splits, introduces un "mini delay" al navegar.</p>
                    <p><strong>Soluci√≥n:</strong> Prefetch inteligente.</p>
                    <ul>
                        <li>Prefetch cuando el enlace entra en viewport</li>
                        <li>Prefetch al hacer hover</li>
                        <li>Prefetch cuando el usuario muestra intenci√≥n</li>
                    </ul>
                    <p><strong>Resultado:</strong> Better UX sin volver a meter todo en el bundle inicial.</p>
                </div>

                <!-- PASO 5 - MINIFICACI√ìN -->
                <h2>üî® Paso 5 ‚Äî Minificaci√≥n/Uglificaci√≥n (bien, pero no la vendas como "lo m√°s grande")</h2>

                <div class="concept-block">
                    <p>Minify: renombrar variables, quitar whitespace/comentarios.</p>
                    <p><strong>Hoy en d√≠a:</strong> Viene "de serie" en builds de producci√≥n (Terser/esbuild).</p>
                </div>

                <h3>Lo importante que el junior entienda</h3>
                <div class="warning-block">
                    <ul>
                        <li>‚úÖ Minify reduce bytes</li>
                        <li>‚ùå Pero no elimina dependencias</li>
                        <li>‚ùå Y no reduce mucho CPU comparado con "menos c√≥digo real"</li>
                    </ul>
                    <p><strong>Moraleja:</strong> Minify es lo √∫ltimo. Primero, reduce c√≥digo real (cleanup + splitting).</p>
                </div>

                <!-- PASO 6 - 3RD PARTY -->
                <h2>‚ö†Ô∏è Paso 6 ‚Äî Evita "Chaining Critical Requests" (especialmente 3rd-party)</h2>

                <div class="problem-block" data-title="El problema cl√°sico">
                    <p>GTM, trackers, analytics, ads, etc.</p>
                    <p>Cargan en paralelo, se inyectan entre s√≠, y bloquean el main thread.</p>
                    <p><strong>Resultado:</strong> Una cadena de scripts destruye LCP/INP aunque tu bundle sea peque√±o.</p>
                </div>

                <h3>Reglas pr√°cticas</h3>
                <div class="solution-block">
                    <ul>
                        <li>Todo lo que no sea necesario para pintar UI ‚Üí <strong>async/defer</strong></li>
                        <li>Mejor a√∫n: cargarlo <strong>despu√©s del primer render</strong></li>
                        <li>Cuidado con tags que <strong>inyectan m√°s scripts</strong> (cadenas)</li>
                        <li>Si algo bloquea el main thread ‚Üí mu√©velo a <strong>"idle"</strong> (cuando sea posible)</li>
                    </ul>
                </div>

                <h3>Ejemplo: Diferencia entre async y defer</h3>
                <div class="solution-block">
                    <pre><code>// ‚ùå Sin async ni defer: bloquea el parser
&lt;script src="analytics.js"&gt;&lt;/script&gt;

// ‚úÖ async: descargar en paralelo, ejecutar cuando llega
// Usa para scripts que NO dependen de orden (analytics, ads)
&lt;script async src="analytics.js"&gt;&lt;/script&gt;

// ‚úÖ defer: descargar en paralelo, ejecutar cuando HTML termina
// Usa para tu app / chunks principales
&lt;script defer src="app.js"&gt;&lt;/script&gt;</code></pre>
                </div>

                <div class="warning-block" data-title="Criterio claro">
                    <ul>
                        <li><strong>Tu app / chunks principales ‚Üí defer</strong> (ejecuta en orden despu√©s del HTML)</li>
                        <li><strong>Analytics ‚Üí async</strong> (ejecuta cuando est√° listo, no bloquea nada)</li>
                    </ul>
                </div>

                <!-- PASO 7 - CACHING -->
                <h2>üíæ Paso 7 ‚Äî Caching (la guinda que convierte optimizaci√≥n en "persistente")</h2>

                <div class="analogy-block" data-title="Mental Model: La 2¬™ visita debe ser mucho m√°s r√°pida">
                    <p>No solo reducir el bundle inicial.</p>
                    <p>Sino asegurar que no se vuelve a descargar lo que no cambi√≥.</p>
                </div>

                <h3>Estrategia: Hash + Cache largo</h3>
                <div class="solution-block">
                    <pre><code>// ‚ùå Mal: el navegador siempre repregunta
&lt;script src="app.js"&gt;&lt;/script&gt;

// ‚úÖ Bien: hash en el nombre = cache seguro
&lt;script src="app.8f3a1.js"&gt;&lt;/script&gt;</code></pre>
                    <p><strong>Workflow:</strong></p>
                    <ol>
                        <li>Tu bundler genera hashes basados en contenido</li>
                        <li>app.8f3a1.js ‚Üí cache durante 1 a√±o</li>
                        <li>Solo cuando el c√≥digo cambia ‚Üí nuevo hash ‚Üí nuevo archivo descargado</li>
                    </ol>
                </div>

                <h3>Ejemplo con Webpack</h3>
                <div class="solution-block">
                    <pre><code>// webpack.config.js
module.exports = {
  output: {
    filename: '[name].[contenthash:8].js',
    chunkFilename: '[name].[contenthash:8].chunk.js',
  },
};</code></pre>
                </div>

                <div class="concept-block">
                    <p><strong>Resultado:</strong></p>
                    <ul>
                        <li>1¬™ visita: descarga todo (pero cacheable despu√©s)</li>
                        <li>2¬™ visita: solo carga lo que cambi√≥</li>
                        <li>Navegaci√≥n interna: mucho m√°s r√°pida</li>
                    </ul>
                </div>

                <!-- CHECKLIST FINAL -->
                <h2>üìã Mini Checklist Final</h2>

                <div class="solution-block">
                    <ul>
                        <li>‚òê <strong>Mido:</strong> Lighthouse + Network (disable cache) + Performance</li>
                        <li>‚òê <strong>Veo "qu√© pesa":</strong> Bundle analyzer</li>
                        <li>‚òê <strong>Veo "qu√© no uso":</strong> Coverage</li>
                        <li>‚òê <strong>Limpio dependencias + imports:</strong> Tree-shaking real</li>
                        <li>‚òê <strong>Code splitting por rutas:</strong> Lazy routes</li>
                        <li>‚òê <strong>Code splitting por features pesadas:</strong> Lazy components</li>
                        <li>‚òê <strong>Prefetch inteligente:</strong> Para rutas probables</li>
                        <li>‚òê <strong>3rd-party scripts:</strong> async/defer + evitar cadenas</li>
                        <li>‚òê <strong>Hash + caching largo:</strong> En est√°ticos</li>
                    </ul>
                </div>

                <!-- EJERCICIO PR√ÅCTICO -->
                <h2>üß™ Ejercicio Pr√°ctico Paso a Paso</h2>

                <div class="interview-block">
                    <div class="interview-title">
                        <span>üéØ Aplica esto a tu proyecto HOY</span>
                        <span class="toggle-arrow">‚ñ∂</span>
                    </div>
                    <div class="interview-content">
                        <ol>
                            <li><strong>Corre Lighthouse en tu SPA</strong>
                                <ul>
                                    <li>Anota JS inicial (sin cache)</li>
                                </ul>
                            </li>
                            <li><strong>Abre bundle analyzer</strong>
                                <ul>
                                    <li>Identifica top 3 dependencias m√°s grandes</li>
                                </ul>
                            </li>
                            <li><strong>Abre DevTools ‚Üí Coverage</strong>
                                <ul>
                                    <li>Observa % rojo en la carga inicial</li>
                                </ul>
                            </li>
                            <li><strong>Elige UNA acci√≥n:</strong>
                                <ul>
                                    <li>Opci√≥n A: Sustituye una dependencia por alternativa m√°s ligera</li>
                                    <li>Opci√≥n B: A√±ade 1 lazy route</li>
                                    <li>Opci√≥n C: A√±ade hash a los bundles</li>
                                </ul>
                            </li>
                            <li><strong>Vuelve a medir</strong>
                                <ul>
                                    <li>Lighthouse</li>
                                    <li>Bundle size</li>
                                    <li>Compara antes y despu√©s</li>
                                </ul>
                            </li>
                            <li><strong>Repite 2-3 veces</strong></li>
                        </ol>
                    </div>
                </div>

                <!-- ENTREVISTA -->
                <div class="interview-block">
                    <div class="interview-title">
                        <span>üß† Resumen para Entrevista</span>
                        <span class="toggle-arrow">‚ñ∂</span>
                    </div>
                    <div class="interview-content">
                        <p><strong>Si ma√±ana te preguntan: "¬øC√≥mo optimizas el bundle en una SPA?"</strong></p>
                        <p><strong>Respuesta senior:</strong></p>
                        <blockquote>
                            <p>"Hay dos costes: network y CPU.</p>
                            <p>Primero mido: Lighthouse + Coverage + Bundle analyzer.</p>
                            <p>Limpio dependencias (tree-shaking bien hecho).</p>
                            <p>Hago code splitting por rutas y features pesadas.</p>
                            <p>Async/defer para 3rd-party.</p>
                            <p>Hash + caching largo para est√°ticos.</p>
                            <p>Si sigue lento, miro CPU (Performance panel), no solo red."</p>
                        </blockquote>
                    </div>
                </div>

                <!-- REFLEXI√ìN SENIOR -->
                <div class="interview-block">
                    <div class="interview-title">
                        <span>üí° Lo que diferencia a un senior</span>
                        <span class="toggle-arrow">‚ñ∂</span>
                    </div>
                    <div class="interview-content">
                        <p>Un junior: "Tengo que usar React.memo y useMemo."</p>
                        <p>Un senior: "Mi bundle es 200KB. El resto es memoization de 20KB."</p>
                        <p><strong>La diferencia:</strong> Medir primero, reducir dependencias, luego optimizar React.</p>
                        <p><strong>Eso es lo que diferencia un proyecto que "funciona" de uno que "vuela".</strong></p>
                    </div>
                </div>

                <!-- REFERENCIAS -->
                <div class="solution-block">
                    <h3>üìö Referencias y Recursos</h3>
                    <ul>
                        <li><a href="https://chatgpt.com/g/g-p-69925f6597e88191b8bcb93447c5bb78-dragos/c/6993bb8e-62b4-8392-929e-2351d1b96787" target="_blank">ChatGPT Dragos - Performance Expert</a></li>
                    </ul>
                </div>

                <!-- NAVIGATION BUTTONS -->
                <div class="navigation-buttons">
                    <button class="btn btn-secondary" onclick="window.location.href='19-static-assets.html'">‚Üê Anterior</button>
                    <button class="btn btn-primary" onclick="window.location.href='../../../index.html'">Volver al Inicio ‚Üí</button>
                </div>
            </section>
        </main>
    </div>

    <script src="../../../assets/js/app.js"></script>
</body>
</html>
