<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>2.3 Patr√≥n State Machine - Frontend Mastery</title>
    <link rel="stylesheet" href="../../../assets/css/styles.css">
</head>
<body>
    <div class="container">
        <aside id="sidebar" class="sidebar"></aside>
        <main class="main-content">
            <section id="section-state-machine">
                <h1>2.3 Patr√≥n State Machine</h1>

                <p>Una de las formas m√°s poderosas para manejar estado complejo es el patr√≥n State Machine. Este patr√≥n garantiza que solo ciertos estados son v√°lidos y que las transiciones entre estados sigan reglas predecibles.</p>

                <div class="problem-block" data-title="El Problema: Estados Inconsistentes">
                    <p>Sin un patr√≥n claro, es f√°cil terminar en estados inv√°lidos:</p>
                    <div class="code-block">
<pre><code class="language-jsx">// ‚ùå C√≥digo sin estructura
const [isLoading, setIsLoading] = useState(false);
const [isError, setIsError] = useState(false);
const [data, setData] = useState(null);

// ¬øQu√© pasa si isLoading y isError son ambos true?
// ¬øQu√© pasa si data existe pero isLoading es true?
// Estos estados contradictorios son confusos.</code></pre>
                    </div>
                </div>

                <div class="solution-block" data-title="Soluci√≥n: State Machine Expl√≠cita">
                    <p>Un state machine con estados mutuamente excluyentes previene inconsistencias:</p>
                    <div class="code-block">
<pre><code class="language-jsx">// ‚úÖ State Machine con estados v√°lidos
const [state, setState] = useState('idle');
// Estados v√°lidos: 'idle', 'loading', 'success', 'error'

const fetchData = async () => {
  setState('loading');
  try {
    const result = await api.getData();
    setState('success');
  } catch (err) {
    setState('error');
  }
};

// Ahora es imposible tener estados contradictorios</code></pre>
                    </div>
                </div>

                <h2>Implementaci√≥n con useReducer</h2>

                <div class="concept-block">
                    <h4>M√°quina de Estados Implementada</h4>
                    <div class="code-block">
<pre><code class="language-jsx">const initialState = {
  status: 'idle', // idle | loading | success | error
  data: null,
  error: null
};

const reducer = (state, action) => {
  switch (action.type) {
    case 'FETCH_START':
      return { ...state, status: 'loading', error: null };

    case 'FETCH_SUCCESS':
      return { ...state, status: 'success', data: action.payload };

    case 'FETCH_ERROR':
      return { ...state, status: 'error', error: action.payload };

    case 'RESET':
      return initialState;

    default:
      return state;
  }
};

const Component = () => {
  const [state, dispatch] = useReducer(reducer, initialState);

  const fetchData = async () => {
    dispatch({ type: 'FETCH_START' });
    try {
      const data = await api.get('/data');
      dispatch({ type: 'FETCH_SUCCESS', payload: data });
    } catch (err) {
      dispatch({ type: 'FETCH_ERROR', payload: err });
    }
  };

  return (
    &lt;div&gt;
      {state.status === 'idle' && &lt;button onClick={fetchData}&gt;Load&lt;/button&gt;}
      {state.status === 'loading' && &lt;div&gt;Loading...&lt;/div&gt;}
      {state.status === 'success' && &lt;div&gt;{state.data}&lt;/div&gt;}
      {state.status === 'error' && &lt;div&gt;Error: {state.error}&lt;/div&gt;}
    &lt;/div&gt;
  );
};</code></pre>
                    </div>
                </div>

                <div class="analogy-block" data-title="üí° Analog√≠a: Sem√°foro">
                    <p>Un sem√°foro es una m√°quina de estados: rojo ‚Üí amarillo ‚Üí verde ‚Üí rojo. Cada color es un estado v√°lido, y las transiciones siguen reglas. Nunca tienes rojo y verde simult√°neamente. El sistema es predecible.</p>
                </div>

                <div class="warning-block" data-title="‚ö†Ô∏è Consejo Senior">
                    <p>El patr√≥n State Machine es especialmente importante en operaciones asincr√≥nicas. Muchos bugs de React vienen de no manejar correctamente los estados intermedios (loading, error). Un state machine expl√≠cito previene estos problemas.</p>
                </div>

                <div class="nav-buttons">
                    <button class="btn btn-primary" onclick="window.location.href='03-mental-models.html'">‚Üê Anterior</button>
                    <button class="btn btn-primary" onclick="window.location.href='05-essential-derived.html'">Siguiente ‚Üí</button>
                </div>
            </section>
        </main>
    </div>

    <script src="../../../assets/js/app.js"></script>
</body>
</html>
