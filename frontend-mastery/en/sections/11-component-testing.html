<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>2.10 Component Testing - Frontend Mastery</title>
    <link rel="stylesheet" href="../../../assets/css/styles.css">
</head>
<body>
    <div class="container">
        <aside id="sidebar" class="sidebar"></aside>
        <main class="main-content">
            <section id="section-component-testing">
                <h1>2.10 Component Testing</h1>

                <p>A component without tests is a component that will break. Testing is a fundamental part of professional development. It's not optional and it's not "for later".</p>

                <h2>Testing Pyramid</h2>

                <div class="concept-block">
                    <h4>1. Unit Tests (Base - 70%)</h4>
                    <p>Test individual functions in isolation:</p>
                    <div class="code-block">
<pre><code class="language-jsx">// Pure function
const calculateTotal = (items) => {
  return items.reduce((sum, item) => sum + item.price, 0);
};

// Test
test('calculateTotal sums prices correctly', () => {
  const items = [
    { price: 10 },
    { price: 20 },
    { price: 5 }
  ];
  expect(calculateTotal(items)).toBe(35);
});</code></pre>
                    </div>
                </div>

                <div class="concept-block">
                    <h4>2. Integration Tests (Middle - 20%)</h4>
                    <p>Test multiple units working together:</p>
                    <div class="code-block">
<pre><code class="language-jsx">// Component with multiple functions
test('UserForm validates and submits data', () => {
  render(&lt;UserForm /&gt;);

  const emailInput = screen.getByLabelText('Email');
  fireEvent.change(emailInput, { target: { value: 'test@example.com' } });

  const submitButton = screen.getByRole('button', { name: /submit/i });
  fireEvent.click(submitButton);

  expect(mockSubmit).toHaveBeenCalledWith({
    email: 'test@example.com'
  });
});</code></pre>
                    </div>
                </div>

                <div class="concept-block">
                    <h4>3. E2E Tests (Top - 10%)</h4>
                    <p>Test complete user flows:</p>
                    <div class="code-block">
<pre><code class="language-jsx">// With Cypress
describe('User Registration Flow', () => {
  it('User can register completely', () => {
    cy.visit('http://localhost:3000');

    cy.contains('Sign Up').click();
    cy.get('input[name="email"]').type('user@example.com');
    cy.get('input[name="password"]').type('secure123');
    cy.contains('Create Account').click();

    cy.url().should('include', '/dashboard');
    cy.contains('Welcome').should('be.visible');
  });
});</code></pre>
                    </div>
                </div>

                <h2>Testing React Components</h2>

                <div class="code-block">
<pre><code class="language-jsx">import { render, screen, fireEvent } from '@testing-library/react';
import Counter from './Counter';

describe('Counter Component', () => {

  test('Renders with initial counter at 0', () => {
    render(&lt;Counter initialValue={0} /&gt;);
    expect(screen.getByText('0')).toBeInTheDocument();
  });

  test('Increments when button is clicked', () => {
    render(&lt;Counter initialValue={0} /&gt;);

    const incrementButton = screen.getByRole('button', { name: /increment/i });
    fireEvent.click(incrementButton);

    expect(screen.getByText('1')).toBeInTheDocument();
  });

  test('Calls callback when changes', () => {
    const onChange = jest.fn();
    render(&lt;Counter initialValue={0} onChange={onChange} /&gt;);

    const incrementButton = screen.getByRole('button', { name: /increment/i });
    fireEvent.click(incrementButton);

    expect(onChange).toHaveBeenCalledWith(1);
  });

  test('Does not increment if disabled', () => {
    render(&lt;Counter initialValue={0} disabled /&gt;);

    const incrementButton = screen.getByRole('button');
    expect(incrementButton).toBeDisabled();
  });
});</code></pre>
                </div>

                <h2>Testing Best Practices</h2>

                <div class="concept-block">
                    <h4>1. Test Behavior, Not Implementation</h4>
                    <div class="code-block">
<pre><code class="language-jsx">// ❌ Bad: Tests implementation details
test('useState is called', () => {
  // This is impossible to test without accessing internals
});

// ✅ Good: Tests visible behavior
test('User sees results when searching', () => {
  render(&lt;SearchComponent /&gt;);
  const input = screen.getByRole('textbox');
  fireEvent.change(input, { target: { value: 'react' } });
  expect(screen.getByText('Results for react')).toBeInTheDocument();
});</code></pre>
                    </div>
                </div>

                <div class="concept-block">
                    <h4>2. Test Accessibility</h4>
                    <div class="code-block">
<pre><code class="language-jsx">// ✅ Use accessible queries
const button = screen.getByRole('button', { name: /submit/i }); // ✅
const input = screen.getByLabelText('Email'); // ✅

// Avoid
const button = screen.getByTestId('submit-btn'); // ❌
const input = screen.getByClassName('email-input'); // ❌</code></pre>
                    </div>
                </div>

                <div class="warning-block" data-title="⚠️ Senior Advice">
                    <p>Don't aim for 100% coverage. Instead, aim for 80% coverage focused on critical logic. Tests that verify trivial things are maintenance without value. Focus on tests that prevent real bugs.</p>
                </div>

                <div class="nav-buttons">
                    <button class="btn btn-primary" onclick="window.location.href='10-web-accessibility.html'">← Previous</button>
                    <button class="btn btn-primary" onclick="window.location.href='12-summary.html'">Next →</button>
                </div>
            </section>
        </main>
    </div>

    <script src="../../../assets/js/app.js"></script>
</body>
</html>
