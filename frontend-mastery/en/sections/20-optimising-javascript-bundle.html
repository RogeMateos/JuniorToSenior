<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Optimising the JavaScript Bundle | Frontend Mastery</title>
    <link rel="stylesheet" href="../../../assets/css/styles.css">
</head>
<body>
    <div class="container">
        <aside id="sidebar" class="sidebar"></aside>
        <main class="main-content">
            <section class="content-section">
                <h1>üì¶ Optimising the JavaScript Bundle</h1>
                <p class="section-description">How to Reduce JS and Improve Performance in Real SPAs</p>

                <!-- MENTAL MODEL -->
                <div class="analogy-block" data-title="Mental Model: JavaScript Weighs Twice">
                    <p><strong>It's not just downloading.</strong></p>
                    <p>JavaScript has two costs:</p>
                    <ul>
                        <li><strong>üåê Network cost:</strong> KB/MB (compressed) that get downloaded</li>
                        <li><strong>‚öôÔ∏è CPU cost:</strong> parse ‚Üí compile ‚Üí execute on main thread</li>
                    </ul>
                    <p>In SPAs, often the <strong>CPU (not the network) is the killer on mobile.</strong></p>
                </div>

                <!-- OBJECTIVE -->
                <div class="concept-block">
                    <h2>üéØ Module Objective</h2>
                    <p>Understand how to optimize real bundles and measure impact on:</p>
                    <ul>
                        <li>‚ö° Initial JS ‚â§ 300‚Äì500KB gzip (depends on product)</li>
                        <li>üö´ Avoid long tasks (&gt;50ms) during first render</li>
                        <li>üìä Improve LCP and INP</li>
                    </ul>
                </div>

                <!-- STEP 0 - DEFINE OBJECTIVE -->
                <h2>üß™ Step 0 ‚Äî Define Objective with Metrics (before touching code)</h2>

                <h3>Typical Realistic Goal in SPA</h3>
                <div class="solution-block">
                    <ul>
                        <li><strong>Initial JS ‚â§ 300‚Äì500KB gzip</strong> (depends on product)</li>
                        <li><strong>Avoid long tasks (&gt;50ms)</strong> during first render</li>
                        <li><strong>Improve LCP and INP</strong></li>
                    </ul>
                </div>

                <h3>How to Measure</h3>
                <div class="solution-block">
                    <ul>
                        <li><strong>Lighthouse</strong> (lab)</li>
                        <li><strong>DevTools ‚Üí Network</strong> (Disable cache) and Performance</li>
                        <li><strong>Real Web Vitals</strong> in production (if possible)</li>
                    </ul>
                    <p><strong>‚ö†Ô∏è Why:</strong> if you don't measure, you optimize "blindly" and can worsen UX.</p>
                </div>

                <!-- STEP 1 - WHAT WEIGHS -->
                <h2>üîç Step 1 ‚Äî Find "What Weighs" (don't guess)</h2>

                <h3>A) Bundle Analyzer</h3>
                <div class="solution-block">
                    <p>Tools depending on your stack:</p>
                    <ul>
                        <li><strong>Webpack:</strong> webpack-bundle-analyzer</li>
                        <li><strong>Vite/Rollup:</strong> rollup-plugin-visualizer</li>
                        <li><strong>Create React App:</strong> source-map-explorer</li>
                    </ul>
                    <p>What to look for:</p>
                    <ul>
                        <li>Huge libraries (moment, chart libs, editors, maps)</li>
                        <li>Duplicates (two date libs, two lodash-like)</li>
                        <li>Unnecessary polyfills</li>
                    </ul>
                    <p><strong>Reality:</strong> 80% of size usually comes from 20% of dependencies.</p>
                </div>

                <h3>B) DevTools ‚Üí Coverage</h3>
                <div class="solution-block">
                    <p>Shows how much JS is unused on initial load.</p>
                    <ol>
                        <li>Open DevTools</li>
                        <li>More Tools ‚Üí Coverage</li>
                        <li>Click Reload</li>
                        <li>Observe what's in red</li>
                    </ol>
                    <p><strong>Red = unused on initial load</strong></p>
                    <p>This is gold for finding code splitting opportunities.</p>
                </div>

                <!-- STEP 2 - BUNDLE CLEANUP -->
                <h2>üßπ Step 2 ‚Äî "Bundle Cleanup" (reduce what doesn't help)</h2>

                <h3>Typical Actions</h3>
                <div class="solution-block">
                    <ul>
                        <li>Uninstall unused dependencies</li>
                        <li>Replace with lighter alternatives</li>
                        <li>Change imports so tree-shaking works</li>
                    </ul>
                </div>

                <h3>Example 1: Lodash (the classic mistake)</h3>
                <div class="problem-block" data-title="‚ùå Imports entire library">
                    <pre><code>import _ from "lodash";
const debounced = _.debounce(myFn, 300);</code></pre>
                    <p><strong>Problem:</strong> You get the ENTIRE library (~70KB).</p>
                </div>

                <div class="solution-block" data-title="‚úÖ Import only what you need">
                    <pre><code>import debounce from "lodash/debounce";
const debounced = debounce(myFn, 300);</code></pre>
                    <p><strong>Result:</strong> Only ~10KB.</p>
                </div>

                <div class="concept-block">
                    <p><strong>Or even better:</strong> implement it yourself if it's simple.</p>
                    <pre><code>const debounce = (fn, ms) => {
  let timeout;
  return (...args) => {
    clearTimeout(timeout);
    timeout = setTimeout(() => fn(...args), ms);
  };
};</code></pre>
                    <p>0KB of dependency.</p>
                </div>

                <h3>Example 2: Dates (the other common mistake)</h3>
                <div class="problem-block">
                    <p>If you only need to format 1 date:</p>
                    <pre><code>// ‚ùå moment.js = 70KB
import moment from 'moment';
moment(date).format('DD/MM/YYYY');</code></pre>
                </div>

                <div class="solution-block">
                    <p>‚úÖ Lighter alternatives or native:</p>
                    <pre><code>// Option 1: Lighter library (date-fns: ~15KB)
import { format } from 'date-fns';
format(date, 'dd/MM/yyyy');

// Option 2: Native API (if your target allows)
new Intl.DateTimeFormat('en-US').format(date);</code></pre>
                </div>

                <div class="warning-block" data-title="Why each dependency costs">
                    <ul>
                        <li><strong>Bytes:</strong> the library occupies KB</li>
                        <li><strong>Parse/execute:</strong> browser must process that code</li>
                        <li><strong>Maintenance:</strong> risk of updates, breaking changes</li>
                        <li><strong>Build time:</strong> slower</li>
                    </ul>
                </div>

                <!-- STEP 3 - TREE SHAKING -->
                <h2>üå≥ Step 3 ‚Äî Ensure Tree-Shaking + Production Build</h2>

                <div class="concept-block">
                    <h3>What is Tree-Shaking?</h3>
                    <p>The bundler removes "dead" code (not imported).</p>
                    <p><strong>Works well when:</strong></p>
                    <ul>
                        <li>You use <strong>ESM imports</strong> (import { x } from 'lib')</li>
                        <li>The package is prepared (sideEffects: false)</li>
                        <li>Build is "production"</li>
                    </ul>
                </div>

                <h3>Checklist to Enable Tree-Shaking</h3>
                <div class="solution-block">
                    <ul>
                        <li>‚òê Compile in <strong>production</strong> mode</li>
                        <li>‚òê Prefer <strong>ESM</strong> libraries</li>
                        <li>‚òê Avoid "barrel" imports that break tree-shaking</li>
                        <li>‚òê In own packages: mark <strong>"sideEffects": false</strong> when correct</li>
                    </ul>
                </div>

                <h3>Example: Barrel imports (be careful)</h3>
                <div class="problem-block">
                    <pre><code>// ‚ùå Might bring everything even if you use one
import { Button } from './components';</code></pre>
                    <p>Depends on how the barrel file is written.</p>
                </div>

                <div class="solution-block">
                    <pre><code>// ‚úÖ More explicit (and safer for tree-shaking)
import Button from './components/Button';</code></pre>
                </div>

                <!-- STEP 4 - CODE SPLITTING -->
                <h2>üéØ Step 4 ‚Äî Code Splitting (the big impact)</h2>

                <div class="analogy-block" data-title="Mental Model: Don't load what you don't need">
                    <p>If the user is on /home, why download the JS for /checkout?</p>
                    <p>Code splitting lets you load each route as a separate file.</p>
                </div>

                <h3>4.1 Split by Routes (React)</h3>
                <div class="solution-block">
                    <pre><code>import { lazy, Suspense } from "react";
import { Routes, Route } from "react-router-dom";

const Home = lazy(() => import("./pages/Home"));
const Checkout = lazy(() => import("./pages/Checkout"));
const Dashboard = lazy(() => import("./pages/Dashboard"));

export function AppRoutes() {
  return (
    &lt;Suspense fallback={&lt;LoadingSpinner /&gt;}&gt;
      &lt;Routes&gt;
        &lt;Route path="/" element={&lt;Home /&gt;} /&gt;
        &lt;Route path="/checkout" element={&lt;Checkout /&gt;} /&gt;
        &lt;Route path="/dashboard" element={&lt;Dashboard /&gt;} /&gt;
      &lt;/Routes&gt;
    &lt;/Suspense&gt;
  );
}</code></pre>
                    <p><strong>What you get:</strong> On / you don't download the JS for /checkout or /dashboard.</p>
                    <p><strong>How it works:</strong> import() creates a separate chunk (Webpack/Rollup/Vite split it automatically).</p>
                </div>

                <h3>4.2 Split by "Heavy Feature"</h3>
                <div class="solution-block">
                    <p>Examples: editor, charts, maps, pdf viewer, etc.</p>
                    <pre><code>import { lazy, Suspense, useState } from "react";

const ChartPanel = lazy(() => import("./ChartPanel"));

function Dashboard() {
  const [showCharts, setShowCharts] = useState(false);

  return (
    &lt;&gt;
      &lt;button onClick={() => setShowCharts(true)}&gt;
        Show Charts
      &lt;/button&gt;
      {showCharts && (
        &lt;Suspense fallback={&lt;div&gt;Loading charts...&lt;/div&gt;}&gt;
          &lt;ChartPanel /&gt;
        &lt;/Suspense&gt;
      )}
    &lt;/&gt;
  );
}</code></pre>
                    <p><strong>Advantage:</strong> If the user doesn't open that feature, you don't pay the cost.</p>
                </div>

                <h3>4.3 Smart Prefetch / Preload</h3>
                <div class="concept-block">
                    <p>Once you split, you introduce a "mini delay" when navigating.</p>
                    <p><strong>Solution:</strong> Smart prefetch.</p>
                    <ul>
                        <li>Prefetch when link enters viewport</li>
                        <li>Prefetch on hover</li>
                        <li>Prefetch when user shows intent</li>
                    </ul>
                    <p><strong>Result:</strong> Better UX without putting everything back in initial bundle.</p>
                </div>

                <!-- STEP 5 - MINIFICATION -->
                <h2>üî® Step 5 ‚Äî Minification/Uglification (good, but don't oversell it)</h2>

                <div class="concept-block">
                    <p>Minify: rename variables, remove whitespace/comments.</p>
                    <p><strong>Today:</strong> Comes "out of the box" in production builds (Terser/esbuild).</p>
                </div>

                <h3>What's Important for Junior to Understand</h3>
                <div class="warning-block">
                    <ul>
                        <li>‚úÖ Minify reduces bytes</li>
                        <li>‚ùå But doesn't eliminate dependencies</li>
                        <li>‚ùå And doesn't reduce CPU much compared to "less actual code"</li>
                    </ul>
                    <p><strong>Takeaway:</strong> Minify is last. First, reduce actual code (cleanup + splitting).</p>
                </div>

                <!-- STEP 6 - 3RD PARTY -->
                <h2>‚ö†Ô∏è Step 6 ‚Äî Avoid "Critical Request Chains" (especially 3rd-party)</h2>

                <div class="problem-block" data-title="The Classic Problem">
                    <p>GTM, trackers, analytics, ads, etc.</p>
                    <p>Load in parallel, inject each other, and block main thread.</p>
                    <p><strong>Result:</strong> A chain of scripts destroys LCP/INP even if your bundle is small.</p>
                </div>

                <h3>Practical Rules</h3>
                <div class="solution-block">
                    <ul>
                        <li>Anything not needed to paint UI ‚Üí <strong>async/defer</strong></li>
                        <li>Even better: load it <strong>after first render</strong></li>
                        <li>Watch out for tags that <strong>inject more scripts</strong> (chains)</li>
                        <li>If something blocks main thread ‚Üí move it to <strong>"idle"</strong> (when possible)</li>
                    </ul>
                </div>

                <h3>Example: Difference between async and defer</h3>
                <div class="solution-block">
                    <pre><code>// ‚ùå Without async or defer: blocks parser
&lt;script src="analytics.js"&gt;&lt;/script&gt;

// ‚úÖ async: download in parallel, execute when ready
// Use for scripts that DON'T depend on order (analytics, ads)
&lt;script async src="analytics.js"&gt;&lt;/script&gt;

// ‚úÖ defer: download in parallel, execute when HTML finishes
// Use for your app / main chunks
&lt;script defer src="app.js"&gt;&lt;/script&gt;</code></pre>
                </div>

                <div class="warning-block" data-title="Clear Criteria">
                    <ul>
                        <li><strong>Your app / main chunks ‚Üí defer</strong> (execute in order after HTML)</li>
                        <li><strong>Analytics ‚Üí async</strong> (execute when ready, block nothing)</li>
                    </ul>
                </div>

                <!-- STEP 7 - CACHING -->
                <h2>üíæ Step 7 ‚Äî Caching (the cherry on top that makes optimization "persistent")</h2>

                <div class="analogy-block" data-title="Mental Model: 2nd visit must be much faster">
                    <p>Not just reduce initial bundle.</p>
                    <p>But ensure what didn't change isn't re-downloaded.</p>
                </div>

                <h3>Strategy: Hash + Long Cache</h3>
                <div class="solution-block">
                    <pre><code>// ‚ùå Bad: browser always re-asks
&lt;script src="app.js"&gt;&lt;/script&gt;

// ‚úÖ Good: hash in name = safe cache
&lt;script src="app.8f3a1.js"&gt;&lt;/script&gt;</code></pre>
                    <p><strong>Workflow:</strong></p>
                    <ol>
                        <li>Your bundler generates hashes based on content</li>
                        <li>app.8f3a1.js ‚Üí cache for 1 year</li>
                        <li>Only when code changes ‚Üí new hash ‚Üí new file downloaded</li>
                    </ol>
                </div>

                <h3>Example with Webpack</h3>
                <div class="solution-block">
                    <pre><code>// webpack.config.js
module.exports = {
  output: {
    filename: '[name].[contenthash:8].js',
    chunkFilename: '[name].[contenthash:8].chunk.js',
  },
};</code></pre>
                </div>

                <div class="concept-block">
                    <p><strong>Result:</strong></p>
                    <ul>
                        <li>1st visit: download everything (but cacheable after)</li>
                        <li>2nd visit: only load what changed</li>
                        <li>Internal navigation: much faster</li>
                    </ul>
                </div>

                <!-- FINAL CHECKLIST -->
                <h2>üìã Mini Final Checklist</h2>

                <div class="solution-block">
                    <ul>
                        <li>‚òê <strong>Measure:</strong> Lighthouse + Network (disable cache) + Performance</li>
                        <li>‚òê <strong>See "what weighs":</strong> Bundle analyzer</li>
                        <li>‚òê <strong>See "what's unused":</strong> Coverage</li>
                        <li>‚òê <strong>Clean dependencies + imports:</strong> Real tree-shaking</li>
                        <li>‚òê <strong>Code split by routes:</strong> Lazy routes</li>
                        <li>‚òê <strong>Code split by heavy features:</strong> Lazy components</li>
                        <li>‚òê <strong>Smart prefetch:</strong> For likely routes</li>
                        <li>‚òê <strong>3rd-party scripts:</strong> async/defer + avoid chains</li>
                        <li>‚òê <strong>Hash + long cache:</strong> On statics</li>
                    </ul>
                </div>

                <!-- PRACTICAL EXERCISE -->
                <h2>üß™ Practical Exercise Step by Step</h2>

                <div class="interview-block">
                    <div class="interview-title">
                        <span>üéØ Apply this to your project TODAY</span>
                        <span class="toggle-arrow">‚ñ∂</span>
                    </div>
                    <div class="interview-content">
                        <ol>
                            <li><strong>Run Lighthouse on your SPA</strong>
                                <ul>
                                    <li>Note initial JS (no cache)</li>
                                </ul>
                            </li>
                            <li><strong>Open bundle analyzer</strong>
                                <ul>
                                    <li>Identify top 3 largest dependencies</li>
                                </ul>
                            </li>
                            <li><strong>Open DevTools ‚Üí Coverage</strong>
                                <ul>
                                    <li>Observe % red on initial load</li>
                                </ul>
                            </li>
                            <li><strong>Pick ONE action:</strong>
                                <ul>
                                    <li>Option A: Replace dependency with lighter alternative</li>
                                    <li>Option B: Add 1 lazy route</li>
                                    <li>Option C: Add hash to bundles</li>
                                </ul>
                            </li>
                            <li><strong>Measure again</strong>
                                <ul>
                                    <li>Lighthouse</li>
                                    <li>Bundle size</li>
                                    <li>Compare before and after</li>
                                </ul>
                            </li>
                            <li><strong>Repeat 2-3 times</strong></li>
                        </ol>
                    </div>
                </div>

                <!-- INTERVIEW -->
                <div class="interview-block">
                    <div class="interview-title">
                        <span>üß† Summary for Interview</span>
                        <span class="toggle-arrow">‚ñ∂</span>
                    </div>
                    <div class="interview-content">
                        <p><strong>If tomorrow they ask: "How do you optimize the bundle in an SPA?"</strong></p>
                        <p><strong>Senior answer:</strong></p>
                        <blockquote>
                            <p>"There are two costs: network and CPU.</p>
                            <p>First I measure: Lighthouse + Coverage + Bundle analyzer.</p>
                            <p>I clean dependencies (proper tree-shaking).</p>
                            <p>I code split by routes and heavy features.</p>
                            <p>Async/defer for 3rd-party.</p>
                            <p>Hash + long cache for statics.</p>
                            <p>If it's still slow, I check CPU (Performance panel), not just network."</p>
                        </blockquote>
                    </div>
                </div>

                <!-- SENIOR REFLECTION -->
                <div class="interview-block">
                    <div class="interview-title">
                        <span>üí° What Sets a Senior Apart</span>
                        <span class="toggle-arrow">‚ñ∂</span>
                    </div>
                    <div class="interview-content">
                        <p>A junior: "I need to use React.memo and useMemo."</p>
                        <p>A senior: "My bundle is 200KB. React optimization is 20KB."</p>
                        <p><strong>The difference:</strong> Measure first, reduce dependencies, then optimize React.</p>
                        <p><strong>That's what separates a project that "works" from one that "flies".</strong></p>
                    </div>
                </div>

                <!-- REFERENCES -->
                <div class="solution-block">
                    <h3>üìö References and Resources</h3>
                    <ul>
                        <li><a href="https://chatgpt.com/g/g-p-69925f6597e88191b8bcb93447c5bb78-dragos/c/6993bb8e-62b4-8392-929e-2351d1b96787" target="_blank">ChatGPT Dragos - Performance Expert</a></li>
                    </ul>
                </div>

                <!-- NAVIGATION BUTTONS -->
                <div class="navigation-buttons">
                    <button class="btn btn-secondary" onclick="window.location.href='19-static-assets.html'">‚Üê Previous</button>
                    <button class="btn btn-primary" onclick="window.location.href='../../../index.html'">Back to Home ‚Üí</button>
                </div>
            </section>
        </main>
    </div>

    <script src="../../../assets/js/app.js"></script>
</body>
</html>
